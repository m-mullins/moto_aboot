//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t fboot_cmd_flash_name_mangle(int32_t a1, int32_t a2);
int32_t fdt_get_alias_namelen(char * a1, int32_t a2, int32_t a3);
int32_t fdt_getprop(int32_t a1, int32_t a2, char * str);
int32_t fdt_next_tag(int32_t a1, int32_t a2, int32_t * a3);
int32_t font_draw_char_moto_horizontal(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t font_set_type(char * str, int32_t a2, int32_t a3);
int32_t get_code128_checksum(char * str, int32_t a2, int32_t a3);
int32_t get_num_of_sims(char * a1, int32_t a2, int32_t a3);
int32_t get_sku(char * a1, int32_t a2);
int32_t get_termination_code128(int32_t a1, int32_t a2, int32_t a3);
int32_t gpio_set_value(uint32_t a1, int32_t a2, int32_t a3);
int32_t gpio_status(int32_t a1, int32_t a2, int32_t a3);
int32_t is_fastboot_screen(int32_t a1, int32_t a2, int32_t a3);
int32_t lines(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_multi_multiply(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_multi_shift_left(int32_t * a1, int32_t a2, uint32_t a3);
int32_t nexus_usbpidvid(int32_t a1, int32_t a2);
int32_t pmic_get_extra_reset_info(int32_t a1, int32_t a2);
int32_t secure_allow_console(int32_t a1, int32_t a2);
int32_t set_flash_fail(void);
int32_t set_show_battery_fn(char * a1, int32_t a2, int32_t a3);
int32_t show_fastboot_menu(int32_t a1, int32_t a2);
void thread_become_idle(int32_t a1, int32_t a2, int32_t a3);
int32_t timer_cancel(int32_t result, int32_t a2);
int32_t timer_set_periodic(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t type_atoi_11(char * str, int32_t a2, int32_t a3);
int32_t wait_queue_init(int32_t * a1, int32_t a2);
int32_t XXH32_init(char * a1, int32_t a2);
int32_t XXH32_update(char * a1, char * a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g15 = 0; // R2
int32_t g16 = 0; // R4
int32_t g17 = 0; // R5
int32_t g18 = 0; // R6
int32_t g19 = 0; // R7
int32_t g20 = 0; // R8
int32_t g21 = 0; // R9
int32_t g1 = -0x16d2bfc9; // 0x8f638578
int32_t g2 = 0; // 0x8f69eef0
int32_t g3 = 0x66c06cc; // 0x8f6a28d8
char * g4 = "\x01"; // 0x8f6a3f48
int32_t g6 = 0x10100; // 0x8f6a9f58
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = -1; // 0x8f6ac214
int32_t g9 = 0; // 0x8f6e0850
int32_t g10 = 0; // 0x8f6e09b0
int32_t g11 = 0; // 0x8f6e09b4
int32_t g12 = 0; // 0x8f7112f4
int32_t g13 = 0; // 0x8f7114a8
int32_t g14 = 0; // 0x8f7114ac
int32_t * g5 = &g2; // 0x8f6a9eec

// ------------------------ Functions -------------------------

// Address range: 0x8f6677a8 - 0x8f667883
int32_t mcs_multi_shift_left(int32_t * a1, int32_t a2, uint32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t result = a2; // R1
    int32_t v2 = g12;
    int32_t v3 = a3 % 16; // 0x8f6677bc
    int32_t v4 = a3 / 16; // 0x8f6677c0
    int32_t v5 = a2; // 0x8f6677d0
    int32_t * v6; // 0x8f667838_1
    int32_t * v7; // 0x8f667854_0
    int32_t v8; // 0x8f6677d0
    uint32_t v9; // 0x8f667844
    int32_t v10; // 0x8f667830
    uint32_t v11; // 0x8f667840
    uint32_t v12; // 0x8f667858
    int32_t v13; // 0x8f6677dc
    int32_t v14; // 0x8f667828
    int32_t v15; // 0x8f6677dc
    int32_t v16; // 0x8f667840
    int32_t v17; // 0x8f667854
    uint32_t v18; // 0x8f667858
    int32_t v19; // 0x8f667838
    uint32_t v20; // 0x8f667838
    if (a3 >= 16) {
        int32_t v21 = 4 * v4; // 0x8f6677e8
        int32_t v22 = a2 - v4; // 0x8f6677ec
        int32_t v23 = a2; // 0x8f6678148
        int32_t v24; // 0x8f6677d023
        int32_t v25; // 0x8f667820
        int32_t v26; // 0x8f66782037
        int32_t v27; // 0x8f667814
        int32_t v28; // 0x8f66781438
        if (v4 != a2) {
            // if_8f667800_0_true.preheader
            *a1 = *(int32_t *)(v1 + v21);
            int32_t v29 = 1; // 0x8f6677f847
            if (v29 < v22) {
                int32_t v30 = v1 + 4;
                *(int32_t *)v30 = *(int32_t *)(v30 + v21);
                while (v29 + 1 < v22) {
                    // if_8f667800_0_true.if_8f667800_0_true_crit_edge
                    v29++;
                    v30 += 4;
                    *(int32_t *)v30 = *(int32_t *)(v30 + v21);
                    // continue -> if_8f667800_0_true.if_8f667800_0_true_crit_edge
                }
                // 0x8f6677f8
                v23 = result;
                // branch -> 0x8f667810
                // 0x8f667810
                v24 = v23;
                if (v22 >= v23) {
                    // 0x8f66781c
                    *(int32_t *)(4 * v22 + v1) = 0;
                    v26 = v22 + 1;
                    v28 = result;
                    if (v26 >= v28) {
                        *(int32_t *)(4 * v26 + v1) = 0;
                        v25 = v26 + 1;
                        v27 = result;
                        while (v25 >= v27) {
                            // 0x8f66781c
                            *(int32_t *)(4 * v25 + v1) = 0;
                            v25++;
                            v27 = result;
                            // continue -> 0x8f66781c
                        }
                        // 0x8f6677c8
                        // branch -> 0x8f6677c8
                        // 0x8f6677c8
                        if (v3 != 0) {
                            // 0x8f6677d0
                            v8 = v27 - 1;
                            v13 = v4;
                            v15 = v8 - v13;
                            result = v15;
                            if (v8 == v13) {
                                int32_t v31 = 0; // 0x8f66783c
                                v10 = v1 + 4;
                                while (true) {
                                    // 0x8f667830
                                    v6 = (int32_t *)(v10 - 4);
                                    v19 = *v6;
                                    v20 = *(int32_t *)v10;
                                    v11 = v3 % 256;
                                    v16 = v11 == 0 ? v19 : v11 < 32 ? v19 << v11 : 0;
                                    v9 = (16 - v3) % 256;
                                    *v6 = (v16 | v20 >> (v9 > 32 ? 32 : v9)) % 0x10000;
                                    v14 = v31 + 1;
                                    if (v14 < result) {
                                        // 0x8f667828
                                        // branch -> 0x8f667854
                                        // 0x8f667854
                                        v7 = (int32_t *)(4 * result + v1);
                                        v17 = *v7;
                                        v12 = v3 % 256;
                                        v18 = v12 == 0 ? v17 : v12 < 32 ? v17 << v12 : 0;
                                        *v7 = v18 % 0x10000;
                                        // branch -> 0x8f667864
                                        // 0x8f667864
                                        if (v2 != g12) {
                                            // 0x8f667874
                                            __stack_chk_fail();
                                            // branch -> 0x8f667878
                                        }
                                        // 0x8f667878
                                        return result;
                                    }
                                  lab_0x8f667830_3:
                                    // 0x8f667830
                                    v31 = v14;
                                    v10 += 4;
                                    // branch -> 0x8f667830
                                }
                            }
                            // 0x8f667854
                            v7 = (int32_t *)(4 * v15 + v1);
                            v17 = *v7;
                            v12 = v3 % 256;
                            v18 = v12 == 0 ? v17 : v12 < 32 ? v17 << v12 : 0;
                            *v7 = v18 % 0x10000;
                            // branch -> 0x8f667864
                        }
                        // 0x8f667864
                        if (v2 != g12) {
                            // 0x8f667874
                            __stack_chk_fail();
                            // branch -> 0x8f667878
                        }
                        // 0x8f667878
                        return result;
                    }
                    v24 = v28;
                }
                // 0x8f6677c8
                // branch -> 0x8f6677c8
                // 0x8f6677c8
                if (v3 != 0) {
                    // 0x8f6677d0
                    v8 = v24 - 1;
                    v13 = v4;
                    v15 = v8 - v13;
                    result = v15;
                    if (v8 == v13) {
                        v10 = v1 + 4;
                        while (true) {
                            // 0x8f667830
                            v6 = (int32_t *)(v10 - 4);
                            v19 = *v6;
                            v20 = *(int32_t *)v10;
                            v11 = v3 % 256;
                            v16 = v11 == 0 ? v19 : v11 < 32 ? v19 << v11 : 0;
                            v9 = (16 - v3) % 256;
                            *v6 = (v16 | v20 >> (v9 > 32 ? 32 : v9)) % 0x10000;
                            v14 = 1;
                            if (v14 >= result) {
                                goto lab_0x8f667830_3;
                            }
                            // 0x8f667828
                            // branch -> 0x8f667854
                        }
                    }
                    // 0x8f667854
                    v7 = (int32_t *)(4 * v15 + v1);
                    v17 = *v7;
                    v12 = v3 % 256;
                    v18 = v12 == 0 ? v17 : v12 < 32 ? v17 << v12 : 0;
                    *v7 = v18 % 0x10000;
                    // branch -> 0x8f667864
                }
                // 0x8f667864
                if (v2 != g12) {
                    // 0x8f667874
                    __stack_chk_fail();
                    // branch -> 0x8f667878
                }
                // 0x8f667878
                return result;
            }
            // 0x8f6677f8
            v23 = result;
            // branch -> 0x8f667810
        }
        // 0x8f667810
        v24 = v23;
        if (v22 >= v23) {
            // 0x8f66781c
            *(int32_t *)(4 * v22 + v1) = 0;
            v26 = v22 + 1;
            v28 = result;
            if (v26 >= v28) {
                *(int32_t *)(4 * v26 + v1) = 0;
                v25 = v26 + 1;
                v27 = result;
                while (v25 >= v27) {
                    // 0x8f66781c
                    *(int32_t *)(4 * v25 + v1) = 0;
                    v25++;
                    v27 = result;
                    // continue -> 0x8f66781c
                }
                // 0x8f6677c8
                // branch -> 0x8f6677c8
                // 0x8f6677c8
                if (v3 != 0) {
                    // 0x8f6677d0
                    v8 = v27 - 1;
                    v13 = v4;
                    v15 = v8 - v13;
                    result = v15;
                    if (v8 == v13) {
                        v10 = v1 + 4;
                        while (true) {
                            // 0x8f667830
                            v6 = (int32_t *)(v10 - 4);
                            v19 = *v6;
                            v20 = *(int32_t *)v10;
                            v11 = v3 % 256;
                            v16 = v11 == 0 ? v19 : v11 < 32 ? v19 << v11 : 0;
                            v9 = (16 - v3) % 256;
                            *v6 = (v16 | v20 >> (v9 > 32 ? 32 : v9)) % 0x10000;
                            v14 = 1;
                            if (v14 >= result) {
                                goto lab_0x8f667830_3;
                            }
                            // 0x8f667828
                            // branch -> 0x8f667854
                        }
                    }
                    // 0x8f667854
                    v7 = (int32_t *)(4 * v15 + v1);
                    v17 = *v7;
                    v12 = v3 % 256;
                    v18 = v12 == 0 ? v17 : v12 < 32 ? v17 << v12 : 0;
                    *v7 = v18 % 0x10000;
                    // branch -> 0x8f667864
                }
                // 0x8f667864
                if (v2 != g12) {
                    // 0x8f667874
                    __stack_chk_fail();
                    // branch -> 0x8f667878
                }
                // 0x8f667878
                return result;
            }
            v24 = v28;
        }
        // 0x8f6677c8
        v5 = v24;
        // branch -> 0x8f6677c8
    }
    // 0x8f6677c8
    if (v3 != 0) {
        // 0x8f6677d0
        v8 = v5 - 1;
        v13 = v4;
        v15 = v8 - v13;
        result = v15;
        if (v8 == v13) {
            v10 = v1 + 4;
            while (true) {
                // 0x8f667830
                v6 = (int32_t *)(v10 - 4);
                v19 = *v6;
                v20 = *(int32_t *)v10;
                v11 = v3 % 256;
                v16 = v11 == 0 ? v19 : v11 < 32 ? v19 << v11 : 0;
                v9 = (16 - v3) % 256;
                *v6 = (v16 | v20 >> (v9 > 32 ? 32 : v9)) % 0x10000;
                v14 = 1;
                if (v14 >= result) {
                    goto lab_0x8f667830_3;
                }
                // 0x8f667828
                // branch -> 0x8f667854
            }
        }
        // 0x8f667854
        v7 = (int32_t *)(4 * v15 + v1);
        v17 = *v7;
        v12 = v3 % 256;
        v18 = v12 == 0 ? v17 : v12 < 32 ? v17 << v12 : 0;
        *v7 = v18 % 0x10000;
        // branch -> 0x8f667864
    }
    // 0x8f667864
    if (v2 != g12) {
        // 0x8f667874
        __stack_chk_fail();
        // branch -> 0x8f667878
    }
    // 0x8f667878
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:10:18
