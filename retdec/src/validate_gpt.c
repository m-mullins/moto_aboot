//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_104(char * a1, char * a2, int32_t a3, int32_t a4);
int32_t get_default_backup_zone(int32_t a1, int32_t a2);
int32_t get_default_backup_zone_size(int32_t a1, int32_t a2);
char * get_ram(char * a1, int32_t a2);
char * get_storage(char * a1, int32_t a2);
int32_t index_value_cb(int32_t a1, int32_t * a2);
int32_t is_gpt_initialized(int32_t a1);
int32_t next_valpair(int32_t * a1, int32_t * a2, int32_t a3, int32_t * a4, int32_t a5);
char * notify_user(char * format, int32_t a2, int32_t a3);
int32_t resize_gpt_entry(uint32_t a1, int32_t a2);
int32_t str_to_utf(char * str, int32_t a2);
int32_t type_atoi_103(char * str, int32_t a2, int32_t a3);
int32_t type_itoa_102(int32_t a1, int32_t a2, int32_t a3);
char * utag_set_cmdline_cb(char * a1, char * a2, int32_t * a3);
int32_t utags_set_chosen(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t utags_set_chosen_cb(char * a1, char * str, int32_t * a3);
int32_t utf_to_str_constprop_3(int32_t a1, int32_t a2, int32_t a3);
int32_t validate_gpt(char * a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

bool g16 = false; // LR
int32_t g17 = 0; // R0
int32_t g18 = 0; // R1
int32_t g19 = 0; // R10
int32_t g20 = 0; // R2
int32_t g21 = 0; // R3
int32_t g22 = 0; // R4
int32_t g23 = 0; // R5
int32_t g24 = 0; // R6
int32_t g25 = 0; // R7
int32_t g26 = 0; // R8
int32_t g27 = 0; // R9
int32_t g1 = -0x1a60df84; // 0x8f654f64
int32_t g2 = -0x16d2b810; // 0x8f655294
int32_t g3 = 0x2020003a; // 0x8f686ac4
int32_t g4 = 0x5542003d; // 0x8f69c373
int32_t g5 = 0x70750020; // 0x8f6a4f1e
int32_t (*g6)(int32_t) = NULL; // 0x8f6afe28
int32_t g7 = 0; // 0x8f6e130c
int32_t g8 = 0; // 0x8f6e1310
char * g9; // 0x8f6e1318
char * g10; // 0x8f6e131c
int32_t g11 = 0; // 0x8f6e1320
int32_t g12 = 0; // 0x8f6e1328
int32_t g13 = 0; // 0x8f7112f4
char * g14; // 0x8f711464
int32_t g15 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f652888 - 0x8f652b8f
int32_t validate_gpt(char * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g22; // 0x8f652888
    int32_t v2 = g24; // 0x8f652888
    g22 = &g13;
    int32_t v3 = (int32_t)a1; // R10
    g24 = a3;
    int32_t v4 = g13;
    int32_t v5 = *(int32_t *)(g15 + 20); // 0x8f6528bc
    print_log(2, (int32_t)"validating GPT header, lba=0x%llx, secotr_count=0x%llx\n", a3, g21, v5, 0, 0, v4, 0, v1, g23, v2, g25);
    char v6 = *(char *)(v3 + 1); // 0x8f6528cc
    char v7 = *(char *)v3; // 0x8f6528d0
    char v8 = *(char *)(v3 + 2); // 0x8f6528d8
    char v9 = *(char *)(v3 + 3); // 0x8f6528e0
    int32_t v10 = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v8 | (int32_t)v7 | 256 * (int32_t)v6; // 0x8f6528e4
    char v11 = *(char *)(v3 + 5); // 0x8f6528e8
    char v12 = *(char *)(v3 + 4); // 0x8f6528ec
    char v13 = *(char *)(v3 + 6); // 0x8f6528f4
    char v14 = *(char *)(v3 + 7); // 0x8f6528fc
    int32_t v15 = 0x1000000 * (int32_t)v14 | 0x10000 * (int32_t)v13 | (int32_t)v12 | 256 * (int32_t)v11; // 0x8f652900
    if (v10 == 0x20494645 && v15 == 0x54524150) {
        char v16 = *(char *)(v3 + 41); // 0x8f65292c
        char v17 = *(char *)(v3 + 40); // 0x8f652930
        char v18 = *(char *)(v3 + 42); // 0x8f652938
        char v19 = *(char *)(v3 + 43); // 0x8f652940
        uint32_t v20 = 0x1000000 * (int32_t)v19 | 0x10000 * (int32_t)v18 | (int32_t)v17 | 256 * (int32_t)v16; // 0x8f652944
        char v21 = *(char *)(v3 + 45); // 0x8f652948
        char v22 = *(char *)(v3 + 44); // 0x8f65294c
        char v23 = *(char *)(v3 + 46); // 0x8f652954
        char v24 = *(char *)(v3 + 47); // 0x8f65295c
        uint32_t v25 = 0x1000000 * (int32_t)v24 | 0x10000 * (int32_t)v23 | (int32_t)v22 | 256 * (int32_t)v21; // 0x8f652960
        char v26 = *(char *)(v3 + 49); // 0x8f652964
        char v27 = *(char *)(v3 + 48); // 0x8f652968
        char v28 = *(char *)(v3 + 50); // 0x8f652970
        char v29 = *(char *)(v3 + 51); // 0x8f652978
        uint32_t v30 = 0x1000000 * (int32_t)v29 | 0x10000 * (int32_t)v28 | (int32_t)v27 | 256 * (int32_t)v26; // 0x8f65297c
        g22 = v30;
        char v31 = *(char *)(v3 + 53); // 0x8f652980
        char v32 = *(char *)(v3 + 52); // 0x8f652984
        char v33 = *(char *)(v3 + 54); // 0x8f65298c
        char v34 = *(char *)(v3 + 55); // 0x8f652994
        uint32_t v35 = 0x1000000 * (int32_t)v34 | 0x10000 * (int32_t)v33 | (int32_t)v32 | 256 * (int32_t)v31; // 0x8f652998
        bool v36 = true; // 0x8f6529a4
        bool v37 = v25 >= v35; // 0x8f6529a4
        if (v25 == v35) {
            // if_8f6529a0_0_true
            v36 = v20 != v30;
            v37 = v20 >= v30;
            // branch -> after_if_8f6529a0_0
        }
        // after_if_8f6529a0_0
        if (!v36 || !v37) {
            uint32_t v38 = v5 - 1; // 0x8f6529a8
            uint32_t v39 = -(int32_t)(v5 == 0); // 0x8f6529ac
            bool v40 = false; // 0x8f6529b8
            bool v41 = v35 >= v39; // 0x8f6529b8
            if (v35 == v39) {
                // if_8f6529b4_0_true
                v40 = v30 == v38;
                v41 = v30 >= v38;
                // branch -> after_if_8f6529b4_0
            }
            // after_if_8f6529b4_0
            if (v40 || v41 ^ true) {
                char v42 = *(char *)(v3 + 17); // 0x8f6529d0
                g22 = 0;
                char * v43 = (char *)(v3 + 16); // 0x8f6529d8_0
                char v44 = *v43; // 0x8f6529d8
                char v45 = *(char *)(v3 + 13); // 0x8f6529e0
                char v46 = *(char *)(v3 + 18); // 0x8f6529ec
                *v43 = 0;
                *(char *)(v3 + 17) = (char)g22;
                char v47 = *(char *)(v3 + 19); // 0x8f6529fc
                *(char *)(v3 + 18) = (char)g22;
                *(char *)(v3 + 19) = (char)g22;
                int32_t v48 = 0x1000000 * (int32_t)v47 | 0x10000 * (int32_t)v46 | (int32_t)v44 | 256 * (int32_t)v42; // R5
                char v49 = *(char *)(v3 + 12); // 0x8f652a0c
                char v50 = *(char *)(v3 + 14); // 0x8f652a14
                int32_t v51 = 0x10000 * (int32_t)v50 | (int32_t)v49 | 256 * (int32_t)v45; // 0x8f652a18
                char v52 = *(char *)(v3 + 15); // 0x8f652a1c
                int32_t v53 = 0x1000000 * (int32_t)v52 | v51; // 0x8f652a20
                uint32_t v54 = crc32(0, (char *)v3, v53); // 0x8f652a24
                if (v48 != v54) {
                    // if_8f652a2c_0_true
                    // branch -> 0x8f652920
                    // 0x8f652920
                    print_log(g22, (int32_t)"Invalid CRC 32\n", v53, v51, v5, 0, 0, v4, 0, v1, g23, v2, g25);
                    // branch -> 0x8f652b44
                    // 0x8f652b44
                    if (v4 != g13) {
                        // 0x8f652b58
                        __stack_chk_fail();
                        // branch -> 0x8f652b5c
                    }
                    // 0x8f652b5c
                    g22 = v1;
                    g24 = v2;
                    return 0;
                }
                // 0x8f652a38
                *(char *)(v3 + 17) = (char)(v54 / 256);
                *(char *)(v3 + 18) = (char)(v48 / 0x10000);
                uint32_t v55 = v48 / 0x1000000; // 0x8f652a54
                *(char *)(v3 + 16) = (char)v48;
                *(char *)(v3 + 19) = (char)v55;
                print_log(2, (int32_t)"valid GPT header CRC32: 0x%x\n", v48, v55, v5, 0, 0, v4, 0, v1, g23, v2, g25);
                char v56 = *(char *)(v3 + 25); // 0x8f652a64
                char v57 = *(char *)(v3 + 24); // 0x8f652a68
                char v58 = *(char *)(v3 + 26); // 0x8f652a70
                char v59 = *(char *)(v3 + 27); // 0x8f652a78
                char v60 = *(char *)(v3 + 29); // 0x8f652a80
                char v61 = *(char *)(v3 + 28); // 0x8f652a84
                char v62 = *(char *)(v3 + 30); // 0x8f652a8c
                char v63 = *(char *)(v3 + 31); // 0x8f652a94
                int32_t v64 = g24; // 0x8f652aa0
                int32_t v65;
                int32_t result;
                if ((0x1000000 * (int32_t)v59 || 0x10000 * (int32_t)v58 || (int32_t)v57 || 256 * (int32_t)v56) == v64 && (0x1000000 * (int32_t)v63 || 0x10000 * (int32_t)v62 || (int32_t)v61 || 256 * (int32_t)v60) == g21) {
                    char v66 = *(char *)(v3 + 85); // 0x8f652ac0
                    char v67 = *(char *)(v3 + 84); // 0x8f652ac8
                    char v68 = *(char *)(v3 + 81); // 0x8f652acc
                    char v69 = *(char *)(v3 + 86); // 0x8f652ad4
                    char v70 = *(char *)(v3 + 87); // 0x8f652adc
                    char v71 = *(char *)(v3 + 80); // 0x8f652ae4
                    char v72 = *(char *)(v3 + 82); // 0x8f652aec
                    char v73 = *(char *)(v3 + 83); // 0x8f652af4
                    int32_t v74 = crc32(g22, (char *)v65, (0x1000000 * (int32_t)v73 | 0x10000 * (int32_t)v72 | (int32_t)v71 | 256 * (int32_t)v68) * (0x1000000 * (int32_t)v70 | 0x10000 * (int32_t)v69 | (int32_t)v67 | 256 * (int32_t)v66)); // 0x8f652b04
                    char v75 = *(char *)(v3 + 89); // 0x8f652b08
                    char v76 = *(char *)(v3 + 88); // 0x8f652b0c
                    char v77 = *(char *)(v3 + 90); // 0x8f652b14
                    char v78 = *(char *)(v3 + 91); // 0x8f652b1c
                    int32_t v79 = 0x1000000 * (int32_t)v78 | 0x10000 * (int32_t)v77 | (int32_t)v76 | 256 * (int32_t)v75; // 0x8f652b20
                    if (v74 != v79) {
                        // 0x8f652b34
                        print_log(g22, (int32_t)"Invalid partition entry array crc32: original=0x%x, caluated=0x%x.\n", v79, v74, v65, 0, 0, 0, 0, 0, 0, 0, 0);
                        result = 0;
                        // branch -> 0x8f652b44
                    } else {
                        result = 1;
                    }
                } else {
                    // 0x8f652aa8
                    print_log(g22, (int32_t)"mismatched my lba: 0x%llx\n", v64, g21, v65, 0, 0, 0, 0, 0, 0, 0, 0);
                    result = 0;
                    // branch -> 0x8f652b44
                }
                // 0x8f652b44
                if (v4 != g13) {
                    // 0x8f652b58
                    __stack_chk_fail();
                    // branch -> 0x8f652b5c
                }
                // 0x8f652b5c
                g22 = v1;
                g24 = v2;
                return result;
            }
        }
        // 0x8f6529bc
        print_log(0, (int32_t)"Invalid usable lba range(0x%llx..0x%llx)\n", v20, v25, v30, v35, 0, v4, 0, v1, g23, v2, g25);
        // branch -> 0x8f652b44
    } else {
        // 0x8f652918
        // branch -> 0x8f652920
        // 0x8f652920
        print_log(0, (int32_t)"Invalid GPT header!\n", v10, v15, v5, 0, 0, v4, 0, v1, g23, v2, g25);
        // branch -> 0x8f652b44
    }
    // 0x8f652b44
    if (v4 != g13) {
        // 0x8f652b58
        __stack_chk_fail();
        // branch -> 0x8f652b5c
    }
    // 0x8f652b5c
    g22 = v1;
    g24 = v2;
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// uLong crc32(uLong crc, const Bytef * buf, uInt len);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 18
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:49:00
