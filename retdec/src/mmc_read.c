//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t board_foundry_id(int32_t a1, int32_t a2, int32_t a3);
int32_t board_hardware_subtype(int32_t a1, int32_t a2, int32_t a3);
int32_t confession_clear(int32_t a1, int32_t a2, int32_t a3);
int32_t confession_gather(int32_t a1, int32_t a2);
int32_t display_draw_horizontal_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t display_draw_vertical_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t fdt_get_property(int32_t a1, int32_t a2, char * str, int32_t a4);
int32_t fdt_get_property_namelen(int32_t a1, int32_t a2, char * a3, int32_t a4);
int32_t freeset(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t get_char_array_prop(char a1, int32_t a2, int32_t a3, int32_t a4);
char * get_hw_id_by_rev(char * a1, int32_t a2);
int32_t get_validated_piv_size(int32_t a1, int32_t a2, int32_t a3);
int32_t handle_fboot_oem_command_lock(int32_t a1, int32_t a2);
int32_t handle_fboot_oem_command_verified(int32_t a1, int32_t a2);
int32_t is_emu_charger_present(int32_t a1, int32_t a2, int32_t a3);
int32_t is_inductive_charger_present(int32_t a1, int32_t a2, int32_t a3);
int32_t is_resin_n_asserted(void);
int32_t mipi_dsi_calibration(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_uninit(int32_t a1);
int32_t mmc_read(int64_t a1, int32_t a2);
int32_t mmc_sdhci_get_wp_group_size(void);
int32_t mmc_zero_out(int32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_resin_status(int32_t a1, int32_t a2);
int32_t power_check(int32_t a1, int32_t a2);
int32_t qgic_init(void);
int32_t SecTest(int32_t a1, int32_t a2);
int32_t try_load_clogo(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t validate_boot_components_version(int32_t a1);
int32_t wait_clogo(int32_t a1, int32_t a2, int32_t a3);
int32_t write_protect_partition(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g20 = 0; // LR
int32_t g21 = 0; // R0
int32_t g22 = 0; // R1
int32_t g23 = 0; // R2
int32_t g24 = 0; // R3
int32_t g25 = 0; // R4
int32_t g26 = 0; // R5
int32_t g27 = 0; // R6
int32_t g28 = 0; // R7
int32_t g29 = 0; // R8
bool g1 = false; // flagc
int32_t g2 = -0x16d2bc09; // 0x8f638ab0
int32_t g3 = -0x16d2b010; // 0x8f639250
char * g4 = "\xd0\x0d\xfe\xed"; // 0x8f68ac00
int32_t g5 = 0; // 0x8f6ac06c
int32_t g6 = 0; // 0x8f6ac078
char * g7 = "\n"; // 0x8f6afe00
char * g8; // 0x8f6e06a0
int32_t g9 = 0; // 0x8f6e08b8
int32_t g10 = 0; // 0x8f6e0918
int32_t g11 = 0; // 0x8f6e0c00
int32_t g12 = 0; // 0x8f6e0c08
int32_t g13 = 0; // 0x8f6e0c38
char * g14; // 0x8f6e0c40
char * g15; // 0x8f6e12ec
int32_t g16 = 0; // 0x8f6e12f0
int32_t g17 = 0; // 0x8f70da60
int32_t g18 = 0; // 0x8f70f724
char * g19; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f60b8ec - 0x8f60bafb
int32_t mmc_read(int64_t a1, int32_t a2) {
    uint32_t v1 = (int32_t)a1;
    int32_t v2 = g25; // 0x8f60b8ec
    int32_t v3 = g27; // 0x8f60b8ec
    g25 = g20;
    char * v4 = g19;
    int32_t v5 = (int32_t)v4;
    int32_t v6 = target_mmc_device(v1); // 0x8f60b910
    int32_t v7 = mmc_get_device_blocksize(v6); // 0x8f60b918
    int32_t v8 = 0; // R3
    int32_t v9 = v7; // R2
    g27 = v7;
    int64_t v10 = v7;
    __aeabi_uldivmod(a1, v10);
    int32_t v11;
    if (v9 != v8) {
        // 0x8f60b93c
        v9 = (int32_t)"platform/msm_shared/mmc_wrapper.c";
        v8 = 188;
        _panic(g25, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/mmc_wrapper.c", 188, (int32_t)"!(data_addr % block_size)", v11, 0);
        // branch -> 0x8f60b958
    }
    int32_t v12 = 0; // 0x8f60b988
    int32_t v13 = g24 / g27; // 0x8f60b988
    if (g24 % g27 != 0) {
        // 0x8f60b96c
        v9 = (int32_t)"platform/msm_shared/mmc_wrapper.c";
        v8 = 189;
        v12 = (int32_t)"ASSERT FAILED at (%s:%d): %s\n";
        v13 = _panic(g25, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/mmc_wrapper.c", 189, (int32_t)"!(data_len % block_size)", v11, 0);
        // branch -> 0x8f60b988
    }
    // 0x8f60b988
    int32_t result; // R7
    int32_t v14;
    int32_t v15;
    if (platform_boot_dev_isemmc(v13, v12, v9, v8) == 0) {
        int32_t v16 = ufs_read(v6, g27, v1, a2); // 0x8f60ba90
        result = v16;
        if (v16 != 0) {
            // 0x8f60ba9c
            print_log(-1, (int32_t)"Error: UFS read failed writing to block: %llu\n", v1, a2, g23, g24 / g27, 0, v15, v1, a2, v7, 0, v14);
            // branch -> 0x8f60baac
        }
        // 0x8f60baac
        function_8f6193f8(g23);
        // branch -> 0x8f60bab8
    } else {
        // 0x8f60b994
        g25 = 0;
        int32_t v17 = 0; // R5
        int32_t v18 = 0; // 0x8f60b9b0
        int32_t v19 = 0; // 0x8f60b9a4
        // branch -> 0x8f60b9a0
        int32_t v20; // 0x8f60b9c4
        int32_t v21;
        int32_t v22; // 0x8f60b9c8
        while (true) {
            int32_t v23 = g24 - v19; // 0x8f60b9a4
            result = v23;
            int32_t v24 = g23 + v19; // R10
            int32_t v25 = v19 + v1; // 0x8f60b9ac
            int64_t v26 = v25;
            int32_t v27 = v18 + a2 + (int32_t)(v25 < v1); // R1
            int32_t v28;
            if (v23 > 0x1fffe00) {
                // 0x8f60b9bc
                v20 = __aeabi_uldivmod(v26, v10);
                v22 = v27;
                v21 = 0x1fffe00 / g27;
                char * v29 = mmc_sdhci_read(v6, v24, v20, v22, v21, v11, 0, 0x1fffe00, v1, a2, v7, 0, v20, v22, 0, v5, 0, v2, g26, v3, g28); // 0x8f60b9e8
                uint32_t v30 = g25; // 0x8f60b9f8
                int32_t v31 = v30 + 0x1fffe00; // 0x8f60b9f8
                g25 = v31;
                int32_t v32 = (int32_t)(v30 > 0xfe0001ff) + v17; // 0x8f60b9fc
                v17 = v32;
                result = (int32_t)v29;
                if (v29 != NULL) {
                    // break -> 0x8f60ba08
                    break;
                }
                v18 = v32;
                v19 = v31;
                v28 = v22;
                v14 = v20;
                v15 = 0x1fffe00;
                // continue -> 0x8f60b9a0
                continue;
            } else {
                // 0x8f60ba18
                if (g24 != v19) {
                    int32_t v33 = __aeabi_uldivmod(v26, v10); // 0x8f60ba24
                    g25 = v33;
                    int32_t v34 = result / g27;
                    char * v35 = mmc_sdhci_read(v6, v24, v33, v27, v34, v11, 0, v15, v1, a2, v7, 0, v14, v28, 0, v5, 0, v2, g26, v3, g28); // 0x8f60ba50
                    result = (int32_t)v35;
                    if (v35 != NULL) {
                        // 0x8f60ba5c
                        // branch -> 0x8f60ba6c
                        // 0x8f60ba6c
                        print_log(-1, (int32_t)"Failed Reading block @ %llx\n", g25, v27, v34, v11, 0, v15, v1, a2, v7, 0, v14);
                        // branch -> 0x8f60bab8
                    }
                }
            }
            // 0x8f60bab8
            if (v4 != g19) {
                // 0x8f60bad0
                __stack_chk_fail();
                // branch -> 0x8f60bad4
            }
            // 0x8f60bad4
            g25 = v2;
            g27 = v3;
            return result;
        }
        // 0x8f60ba08
        // branch -> 0x8f60ba6c
        // 0x8f60ba6c
        print_log(-1, (int32_t)"Failed Reading block @ %llx\n", v20, v22, v21, v11, 0, 0x1fffe00, v1, a2, v7, 0, v20);
        // branch -> 0x8f60bab8
    }
    // 0x8f60bab8
    if (v4 != g19) {
        // 0x8f60bad0
        __stack_chk_fail();
        // branch -> 0x8f60bad4
    }
    // 0x8f60bad4
    g25 = v2;
    g27 = v3;
    return result;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:40:14
