//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __find_first_utag(int32_t a1, int32_t a2);
int32_t __utag_delete(int32_t a1, int32_t a2, int32_t a3);
int32_t __utag_gets_107(char * a1, char * a2, int32_t a3, int32_t a4);
int32_t __utags_init(int32_t a1, int32_t a2, int32_t a3);
int32_t board_hardware_id(int32_t a1, int32_t a2, int32_t a3);
int32_t board_hardware_subtype(int32_t a1, int32_t a2, int32_t a3);
int32_t disable_smb1359_stat_gpio_irq(int32_t a1, int32_t a2, int32_t a3);
int32_t enable_smb1359_stat_gpio_irq(int32_t a1, int32_t a2, int32_t a3);
int32_t flash_utags(void);
int32_t free_tags(char * a1, int32_t a2);
void function_8f64aa3c(void);
void function_8f64aa80(char * str, char * format, int32_t a3, int32_t a4);
int32_t get_utags(int32_t a1, int32_t a2);
int32_t get_utags_name(int32_t a1, int32_t a2);
int32_t mcs_X509Certificate_getSignature(int32_t a1, int32_t * a2);
int32_t mcs_X509Certificate_getSubjectPublicKey(int32_t a1);
int32_t names_match(int32_t a1, int32_t a2);
int32_t on_utag_change(int32_t a1, int32_t a2);
int32_t sdhci_init(int32_t * a1, int32_t a2, int32_t a3);
int32_t sdhci_int_handler(int32_t * a1, int32_t a2);
int32_t thaw_partition_isra_3(int32_t * a1, int32_t a2);
int32_t type_atoi_106(char * str, int32_t a2);

// --------------------- Global Variables ---------------------

bool g8 = false; // LR
int32_t g9 = 0; // R0
int32_t g10 = 0; // R1
int32_t g11 = 0; // R2
int32_t g12 = 0; // R3
int32_t g13 = 0; // R4
int32_t g14 = 0; // R5
int32_t g15 = 0; // R6
int32_t g16 = 0; // R7
int32_t g17 = 0; // R8
int32_t g18 = 0; // R9
int32_t g1 = -0x1a60cfc8; // 0x8f602dd0
int32_t g2 = 0x2020003a; // 0x8f686ac4
int32_t g3 = 0; // 0x8f6ac074
int32_t g4 = 0; // 0x8f6ac078
int32_t g5 = 1; // 0x8f6ac0f0
char * g6[3] = {
    "config",
    "utags",
    "utagsBackup"
}; // 0x8f6b009c
int32_t g7 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f6789d8 - 0x8f678d13
int32_t flash_utags(void) {
    // 0x8f6789d8
    int32_t v1;
    int32_t v2 = v1; // bp-88
    int32_t v3 = g7;
    int32_t v4 = get_utags(g9, g10); // 0x8f6789ec
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x8f6789f4
    int32_t v6;
    int32_t v7;
    int32_t v8 = partition_get_index(v5, g10, g11, v3, v7, v6); // 0x8f6789f8
    int32_t v9 = partition_get_offset(v8, g10, g11); // 0x8f678a00
    int32_t v10 = g10; // 0x8f678a08
    int32_t v11 = v10; // R5
    int32_t v12 = v10 | v9; // 0x8f678a0c
    if (v9 != v10) {
        int32_t v13 = partition_get_size(v8, v10, g11, v12, v7, v6, v1, 0); // 0x8f678a18
        int32_t str = *(int32_t *)(v4 + 12); // 0x8f678a1c
        int32_t str4 = str; // R8
        if (str != 0) {
            // 0x8f678a2c
            if (strncmp((char *)str, "__UTAG_HEAD__", 32) == 0) {
                int32_t str2 = str4; // 0x8f678a44
                int32_t v14 = 0; // 0x8f678a68
                // branch -> 0x8f678a4c
                while (true) {
                    int32_t size2 = (*(int32_t *)(str2 + 32) + 47 & -4) + v14; // R6
                    int32_t strncmp_rc = strncmp((char *)str2, "__UTAG_TAIL__", 32); // 0x8f678a6c
                    int32_t v15 = *(int32_t *)(str2 + 48); // 0x8f678a70
                    if (strncmp_rc == 0) {
                        // 0x8f678a7c
                        if (v15 == 0) {
                            int32_t size = size2 + 511 & -512; // 0x8f678aa0
                            size2 = size;
                            if (size > v13) {
                                // 0x8f678ba0
                                // branch -> 0x8f678bac
                            } else {
                                char * mem = malloc(size); // 0x8f678ab0
                                int32_t result = (int32_t)mem; // 0x8f678ab0_3
                                str2 = result;
                                if (mem == NULL) {
                                    // 0x8f678ba8
                                    // branch -> 0x8f678bac
                                } else {
                                    int32_t v16 = str4; // 0x8f678ac0
                                    // branch -> 0x8f678ac0
                                    while (true) {
                                        // 0x8f678ac0
                                        memcpy((char *)&v2, (char *)v16, 32);
                                        int32_t v17 = result; // 0x8f678ad4
                                        result = v17 + 44;
                                        memcpy((char *)v17, (char *)&v2, 44);
                                        int32_t v18 = str4; // 0x8f678afc
                                        int32_t v19 = *(int32_t *)(v18 + 32); // 0x8f678afc
                                        int32_t str3 = v18; // 0x8f678b1c
                                        if (v19 != 0) {
                                            int32_t v20 = *(int32_t *)(v18 + 44); // 0x8f678b0c
                                            memcpy((char *)result, (char *)v20, v19);
                                            int32_t v21 = str4; // 0x8f678b14
                                            result += *(int32_t *)(v21 + 32);
                                            str3 = v21;
                                            // branch -> 0x8f678b1c
                                        }
                                        int32_t v22 = *(int32_t *)(str3 + 32); // 0x8f678b1c
                                        int32_t v23 = v22 + 3 & -4; // 0x8f678b24
                                        int32_t v24 = v23 - v22; // 0x8f678b28
                                        if (v23 != v22) {
                                            // 0x8f678b30
                                            memset((char *)result, 0, v24);
                                            result += v24;
                                            str3 = str4;
                                            // branch -> 0x8f678b4c
                                        }
                                        // 0x8f678b4c
                                        if (strncmp((char *)str3, "__UTAG_TAIL__", 32) == 0) {
                                            int32_t v25 = result; // 0x8f678b70
                                            memset((char *)v25, 0, str2 + size2 - v25);
                                            if (str2 == 0) {
                                                // 0x8f678b68
                                                // branch -> 0x8f678bac
                                                // 0x8f678bac
                                                g10 = (int32_t)"%s: failed to freeze utags: %d\n";
                                                print_log(0, (int32_t)"%s: failed to freeze utags: %d\n", (int32_t)"flash_utags", 0, v7, 0, v2, 0, 0, 0, 0, 0, 0);
                                                // branch -> 0x8f678ce0
                                              lab_0x8f678ce0:;
                                                // 0x8f678ce0
                                                // branch -> 0x8f678cc8
                                            } else {
                                                // 0x8f678bc0
                                                if (mmc_write(v9, v11, size2, str2, v7, 0, v2, 0, 0, 0, 0, 0) == 0) {
                                                    char * mem2 = malloc(size2); // 0x8f678be8
                                                    int32_t v26 = (int32_t)mem2; // 0x8f678be8_3
                                                    str4 = v26;
                                                    if (mem2 == NULL) {
                                                        // 0x8f678bf4
                                                        g10 = (int32_t)"ERROR: out of memory\n";
                                                        // branch -> 0x8f678bfc
                                                        // 0x8f678bfc
                                                        print_log(-2, (int32_t)"ERROR: out of memory\n", size2, str2, v7, 0, v2, 0, 0, 0, 0, 0, 0);
                                                        // branch -> 0x8f678cc0
                                                    } else {
                                                        // 0x8f678c08
                                                        if (mmc_read(v9, v11, v26, size2, v7, 0, v2, 0, 0, 0, 0, 0, 0) == 0) {
                                                            // 0x8f678c2c
                                                            g10 = str4;
                                                            int32_t memcmp_rc = memcmp((char *)str2, (char *)str4, size2); // 0x8f678c38
                                                            if (memcmp_rc == 0) {
                                                                int32_t v27 = *(int32_t *)(v4 + 8); // 0x8f678c58
                                                                if (v27 != 0) {
                                                                    int32_t v28 = partition_get_index(v27, str4, size2, size2, v7, 0); // 0x8f678c64
                                                                    int32_t v29 = partition_get_offset(v28, str4, size2); // 0x8f678c6c
                                                                    v11 = str4;
                                                                    int32_t v30 = v29 | str4; // 0x8f678c78
                                                                    if (v29 != str4) {
                                                                        // 0x8f678c80
                                                                        if (!((str4 == 0 & partition_get_size(v28, str4, size2, v30, v7, 0, v2, 0) < size2))) {
                                                                            // 0x8f678c9c
                                                                            g10 = v11;
                                                                            mmc_write(v29, v11, size2, str2, v7, 0, v2, 0, 0, 0, 0, 0);
                                                                            // branch -> 0x8f678cb8
                                                                            // 0x8f678cb8
                                                                            free((char *)str4);
                                                                            // branch -> 0x8f678cc0
                                                                            // 0x8f678cc0
                                                                            free((char *)str2);
                                                                            // branch -> 0x8f678cc8
                                                                            // 0x8f678cc8
                                                                            g11 = v3;
                                                                            if (v3 == g7) {
                                                                                // 0x8f678ce8
                                                                                return memcmp_rc;
                                                                            }
                                                                          lab_0x8f678cdc_3:
                                                                            // 0x8f678cdc
                                                                            __stack_chk_fail();
                                                                            // branch -> 0x8f678ce0
                                                                            goto lab_0x8f678ce0;
                                                                        }
                                                                    }
                                                                }
                                                                // 0x8f678cb4
                                                                result = 0;
                                                                // branch -> 0x8f678cb8
                                                            } else {
                                                                // 0x8f678c44
                                                                g10 = (int32_t)"ERROR: Device info corrupted\n";
                                                                // branch -> 0x8f678c4c
                                                                // 0x8f678c4c
                                                                print_log(-2, (int32_t)"ERROR: Device info corrupted\n", size2, size2, v7, 0, v2, 0, 0, 0, 0, 0, 0);
                                                                result = -1;
                                                                // branch -> 0x8f678cb8
                                                            }
                                                            // 0x8f678cb8
                                                            free((char *)str4);
                                                            // branch -> 0x8f678cc0
                                                            // 0x8f678cc0
                                                            free((char *)str2);
                                                            // branch -> 0x8f678cc8
                                                            // 0x8f678cc8
                                                            g11 = v3;
                                                            if (v3 != g7) {
                                                                goto lab_0x8f678cdc_3;
                                                            }
                                                            // 0x8f678ce8
                                                            return result;
                                                        }
                                                        // if_8f678c20_0_true
                                                        g10 = (int32_t)"ERROR: Cannot read device info\n";
                                                        // branch -> 0x8f678c4c
                                                        // 0x8f678c4c
                                                        print_log(-1, (int32_t)"ERROR: Cannot read device info\n", v26, size2, v7, 0, v2, 0, 0, 0, 0, 0, 0);
                                                        // branch -> 0x8f678cb8
                                                        // 0x8f678cb8
                                                        free((char *)str4);
                                                        // branch -> 0x8f678cc0
                                                    }
                                                    // 0x8f678cc0
                                                    free((char *)str2);
                                                    // branch -> 0x8f678cc8
                                                    // 0x8f678cc8
                                                    g11 = v3;
                                                    if (v3 != g7) {
                                                        goto lab_0x8f678cdc_3;
                                                    }
                                                    // 0x8f678ce8
                                                    return -1;
                                                }
                                                // if_8f678bd8_0_true
                                                g10 = (int32_t)"ERROR: Cannot write device info\n";
                                                // branch -> 0x8f678bfc
                                                // 0x8f678bfc
                                                print_log(-1, (int32_t)"ERROR: Cannot write device info\n", size2, str2, v7, 0, v2, 0, 0, 0, 0, 0, 0);
                                                // branch -> 0x8f678cc0
                                                // 0x8f678cc0
                                                free((char *)str2);
                                                // branch -> 0x8f678cc8
                                            }
                                          lab_0x8f678cc8_4:
                                            // 0x8f678cc8
                                            g11 = v3;
                                            if (v3 != g7) {
                                                goto lab_0x8f678cdc_3;
                                            }
                                            // 0x8f678ce8
                                            return -1;
                                        }
                                        int32_t v31 = *(int32_t *)(str4 + 48); // 0x8f678b60
                                        str4 = v31;
                                        v16 = v31;
                                        // branch -> 0x8f678ac0
                                    }
                                }
                                // 0x8f678bac
                                g10 = (int32_t)"%s: failed to freeze utags: %d\n";
                                print_log(0, (int32_t)"%s: failed to freeze utags: %d\n", (int32_t)"flash_utags", 4, v7, v6, v1, 0, 0, 0, 0, 0, 0);
                                // branch -> 0x8f678ce0
                                // 0x8f678ce0
                                // branch -> 0x8f678cc8
                                goto lab_0x8f678cc8_4;
                            }
                            // 0x8f678bac
                            g10 = (int32_t)"%s: failed to freeze utags: %d\n";
                            print_log(0, (int32_t)"%s: failed to freeze utags: %d\n", (int32_t)"flash_utags", 7, v7, v6, v1, 0, 0, 0, 0, 0, 0);
                            // branch -> 0x8f678ce0
                            // 0x8f678ce0
                            // branch -> 0x8f678cc8
                            goto lab_0x8f678cc8_4;
                        }
                    } else {
                        // 0x8f678a88
                        if (v15 != 0) {
                            // 0x8f678a88
                            v14 = size2;
                            str2 = v15;
                            // branch -> 0x8f678a4c
                            continue;
                        }
                    }
                    // 0x8f678b98
                    // branch -> 0x8f678bac
                    // 0x8f678bac
                    g10 = (int32_t)"%s: failed to freeze utags: %d\n";
                    print_log(0, (int32_t)"%s: failed to freeze utags: %d\n", (int32_t)"flash_utags", 6, v7, v6, v1, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f678ce0
                    // 0x8f678ce0
                    // branch -> 0x8f678cc8
                    goto lab_0x8f678cc8_4;
                }
            }
        }
        // 0x8f678b90
        // branch -> 0x8f678bac
        // 0x8f678bac
        g10 = (int32_t)"%s: failed to freeze utags: %d\n";
        print_log(0, (int32_t)"%s: failed to freeze utags: %d\n", (int32_t)"flash_utags", 5, v7, v6, v1, 0, 0, 0, 0, 0, 0);
        // branch -> 0x8f678ce0
    }
    // 0x8f678ce0
    // branch -> 0x8f678cc8
    goto lab_0x8f678cc8_4;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);
// int vsprintf(char * restrict s, const char * restrict format, _G_va_list arg);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 22
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:53:23
