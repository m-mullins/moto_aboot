//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_defined(int32_t a1, int32_t a2);
char * __utag_typeof(void);
int32_t handle_fboot_command_boot(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t handle_fboot_command_continue(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t heap_alloc(uint32_t a1, uint32_t a2);
int32_t heap_free(void);
int32_t is_piv_magic(char * str, int32_t a2);
char * is_secure_boot_enable(int32_t a1);
int32_t mcs_clear_rng_ctx(int32_t a1, int32_t a2);
int32_t mcs_habp_rsa_core(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, int32_t * a7);
int32_t mcs_habp_rsa_crt_large(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_rsa_do_rsa(char * a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t mdp_dsi_cmd_config(int32_t a1, int32_t a2);
int32_t mdp_dsi_video_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdss_qos_remapper_setup(int32_t result, int32_t a2, int32_t a3);
char * mdss_vbif_qos_remapper_setup(int32_t a1);
int32_t mipi_dsi_cmd_bta_sw_trigger(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_cmds_rx(int32_t * a1, int32_t result);
int32_t misc_check_mode(char * a1, int32_t a2);
int32_t pm8x41_chgr_led_enable(int32_t a1, int32_t a2);
int32_t rtc_get(void);
char * scm_io_write(int32_t a1, int32_t a2, int32_t a3);
int32_t set_accessory_type(int32_t a1);
int32_t thread_init(int32_t a1, int32_t a2);
int32_t thread_init_early(void);
int32_t thread_sleep(int32_t a1);
int32_t type_atoi_98(char * str, int32_t a2, int32_t a3);
int32_t XXH32(char * a1, int32_t a2, int32_t a3);
int32_t XXH32_resetState(int32_t * a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g25 = 0; // R0
int32_t g26 = 0; // R1
int32_t g27 = 0; // R11
int32_t g28 = 0; // R2
int32_t g29 = 0; // R4
int32_t g30 = 0; // R5
int32_t g31 = 0; // R6
int32_t g32 = 0; // R7
int32_t g33 = 0; // R8
int32_t g34 = 0; // R9
int32_t g1 = -0x16d2bfc9; // 0x8f61b264
char * g2; // 0x8f622364
int32_t g3 = -0x16d2bfc9; // 0x8f6387c0
int32_t g4 = -0x16d2bc09; // 0x8f638ab0
char * g5 = "\x01"; // 0x8f6a3f48
char * g6 = "\x4d\x4f\x54\x4f\x13\x57\x9b"; // 0x8f6a42ac
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = 10; // 0x8f6afe00
char (*g9)[14] = "boot-recovery"; // 0x8f6aff94
int32_t g10 = 0; // 0x8f6c0064
int32_t g11 = 0; // 0x8f6c0164
int32_t g12 = 0; // 0x8f6c0168
char * g13; // 0x8f6c016c
int32_t g14 = 0; // 0x8f6c0170
int32_t g15 = 0; // 0x8f6c0174
int32_t g16 = 0; // 0x8f6c0180
int32_t g17 = 0; // 0x8f6c0184
int32_t g18 = 0; // 0x8f6c0188
int32_t g19 = 0; // 0x8f6c01b0
int32_t g20 = 0; // 0x8f6e0bf0
int32_t g21 = 0; // 0x8f6e0bf4
char * g22; // 0x8f6ed840
int32_t g23 = 0; // 0x8f7112f4
int32_t g24 = 0; // 0x8f7114ac

// ------------------------ Functions -------------------------

// Address range: 0x8f621dcc - 0x8f62226f
int32_t handle_fboot_command_boot(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // 0x8f621dcc
    int32_t str = *a1; // R4
    int32_t v3 = g23;
    clear_flash_fail(print_log(2, (int32_t)"start handling boot command...\n", a3, v3, v1, a2, a3, v3, g29, g30, g31, g32, g33), (int32_t)"start handling boot command...\n", a3);
    if (memcmp((char *)str, "ANDROID!", 8) == 0) {
        int32_t v4 = *(int32_t *)(str + 36); // 0x8f621e28
        int32_t v5 = v4; // R5
        int32_t v6 = *(int32_t *)(str + 8); // 0x8f621e38
        int32_t v7 = *(int32_t *)(str + 16); // 0x8f621e3c
        int32_t v8 = v4; // 0x8f621e44
        if (v4 == 0) {
            // if_8f621e40_0_true
            v5 = 2048;
            v8 = 2048;
            // branch -> after_if_8f621e40_0
        }
        int32_t str2 = v8 + str; // R7
        print_log(2, (int32_t)"boot.img validated: kernel_size=0x%x, ramdisk_size=0x%x\n", v6, v7, v1, a2, a3, v3, g29, g30, g31, g32, g33);
        int32_t v9 = *(int32_t *)(str2 + 56); // 0x8f621e50
        int32_t v10 = -v5; // R10
        update_ker_tags_rdisk_addr(str, (int32_t)(v9 == 0x644d5241), v9 - 0x644d5241, 0x644d5241, v1, a2, a3);
        int32_t * v11 = (int32_t *)(str + 8); // 0x8f621e6c_0
        int32_t v12 = *(int32_t *)(str + 12); // R3
        int32_t v13 = v10 & v5 + *v11 - 1; // 0x8f621e84
        *v11 = v13;
        print_log(1, (int32_t)"copy kernel data (size=0x%x) to 0x%x\n", v13, v12, v1, a2, a3, v3, g29, g30, g31, g32, g33);
        int32_t v14 = *(int32_t *)(str + 12); // 0x8f621e90
        int32_t v15 = *(int32_t *)(str + 8); // 0x8f621e98
        int32_t v16 = v15; // R2
        memcpy((char *)v14, (char *)str2, v15);
        int32_t v17 = *(int32_t *)(str + 16); // 0x8f621ea0
        int32_t v18; // R6
        int32_t v19;
        int32_t v20; // 0x8f621f34
        if (v17 == 0) {
            // 0x8f621f2c
            v20 = str2;
            // branch -> 0x8f621f30
        } else {
            uint32_t v21 = *(int32_t *)(str + 20); // 0x8f621eac
            uint32_t v22 = *(int32_t *)(str + 12); // 0x8f621eb4
            int32_t v23 = v10 & v5 + v17 - 1; // 0x8f621ec0
            v18 = v23;
            if (v21 >= v22) {
                int32_t v24 = v23 + v21; // 0x8f621ecc
                if (v24 > v22) {
                    // 0x8f621ef0
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(4, (int32_t)"ramdisk too big!\n", v24, v22, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                    // 0x8f6221d8
                    if (v3 != g23) {
                        // 0x8f6221ec
                        __stack_chk_fail();
                        // branch -> 0x8f6221f0
                    }
                    // 0x8f6221f0
                    return 3;
                }
            }
            uint32_t v25 = *(int32_t *)(str + 32); // 0x8f621ed8
            if (v21 >= v25) {
                int32_t v26 = v23 + v21; // 0x8f621ee4
                if (v26 > v25) {
                    // 0x8f621ef0
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(4, (int32_t)"ramdisk too big!\n", v26, v25, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                    // 0x8f6221d8
                    if (v3 != g23) {
                        // 0x8f6221ec
                        __stack_chk_fail();
                        // branch -> 0x8f6221f0
                    }
                    // 0x8f6221f0
                    return 3;
                }
            }
            int32_t v27 = str2 + *(int32_t *)(str + 8); // 0x8f621efc
            memcpy((char *)v21, (char *)v27, v23);
            *(int32_t *)(str + 16) = v18;
            int32_t v28 = *(int32_t *)(str + 20); // 0x8f621f1c
            v16 = v28;
            v12 = v18;
            print_log(1, (int32_t)"ramdisk copied to 0x%x, size is 0x%x\n", v28, v18, v1, a2, a3, v3, g29, g30, g31, g32, g33);
            v20 = v27 + v23;
            // branch -> 0x8f621f30
        }
        int32_t v29 = select_device_tree(str, v20, v16, v12, v1, a2, a3, v3, g29, g30, g31, g32, g33, g34, v2); // 0x8f621f38
        v18 = v29;
        int32_t v30; // 0x8f622130
        int32_t v31; // 0x8f62213020
        int32_t v32; // 0x8f6221cc3
        int32_t v33; // 0x8f621fa0
        int32_t v34; // 0x8f621fb4
        int32_t memcmp_rc; // 0x8f621fd8
        int32_t v35; // 0x8f622048
        int32_t v36; // 0x8f6220c0
        int32_t v37; // 0x8f622120
        int32_t v38; // 0x8f622160
        int32_t v39; // 0x8f622164
        int32_t v40; // 0x8f622168
        int32_t v41; // 0x8f622170
        int32_t v42; // 0x8f6221a8
        int32_t v43; // 0x8f62216c
        int32_t v44; // R1
        int32_t v45; // 0x8f622130
        int32_t v46; // 0x8f622138
        int32_t v47; // 0x8f62219c
        int32_t v48;
        int32_t v49;
        int32_t v50; // 0x8f62200c
        int32_t v51; // 0x8f622078
        int32_t v52; // 0x8f6220e0
        int32_t v53; // 0x8f622078
        int32_t v54; // 0x8f6220e0
        int32_t v55; // 0x8f62210c
        int32_t v56; // 0x8f6221c0
        int32_t v57; // 0x8f622068
        int32_t v58; // 0x8f6221a0
        int32_t v59; // 0x8f6221ac
        int32_t v60; // 0x8f6220b8
        int32_t v61; // 0x8f622198
        int32_t v62; // 0x8f621ff0
        int32_t v63; // 0x8f622010
        int32_t v64; // 0x8f622068
        int32_t v65; // 0x8f622080
        int32_t v66; // 0x8f622088
        int32_t v67; // 0x8f6220bc
        int32_t v68; // 0x8f6220dc
        int32_t v69; // 0x8f6220e4
        int32_t v70; // 0x8f6221a0
        int32_t v71; // 0x8f6221a4
        int32_t v72; // 0x8f6221ac
        int32_t v73; // 0x8f6221b8
        int32_t v74; // 0x8f622020
        int32_t v75; // 0x8f622094
        int32_t v76; // 0x8f622114
        int32_t v77; // 0x8f62211c
        if (v29 == 0) {
            // 0x8f621f50
            print_log(1, (int32_t)"Device tree not found from downloaded boot image\n", v16, v12, v1, a2, a3, v3, g29, g30, g31, g32, g33);
            *(char *)(str + 575) = 0;
            if (v18 == 0) {
                // 0x8f621f8c
                v16 = 0;
                v12 = 0;
                v33 = load_partition_by_name((int32_t)"boot", -0x6e000000, 0, 0, 0, 0, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                if (v33 == -1) {
                    // 0x8f621fac
                    v44 = (int32_t)"failed to load boot image\n";
                    // branch -> 0x8f621fb4
                    // 0x8f621fb4
                    v34 = print_log(0, (int32_t)"failed to load boot image\n", v16, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    if (v18 != 0) {
                        // 0x8f621ff0
                        v62 = *(int32_t *)(str + 16);
                        v12 = v62;
                        if (v62 != 0) {
                            v48 = 0;
                            v32 = 0;
                            // 0x8f622130
                            v45 = enable_cont_splash_screen(v34, v44);
                            v46 = set_logo(0, v44, v45, v12);
                            v16 = v46;
                            v12 = &g4;
                            show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                            fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                            v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                            v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                            v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                            v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                            v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                            if (v41 == 0) {
                                // 0x8f62218c
                                print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                                v61 = v41;
                                v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                                v58 = str;
                                v70 = *(int32_t *)(v58 + 12);
                                v71 = *(int32_t *)(v58 + 32);
                                v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                                v59 = str;
                                v72 = *(int32_t *)(v59 + 20);
                                v73 = *(int32_t *)(v59 + 16);
                                v56 = v59 + 64;
                                boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                                set_current_boot_mode(6, v71, v56, v42);
                                // branch -> 0x8f6221d8
                            } else {
                                // 0x8f62217c
                                // branch -> 0x8f622184
                                // 0x8f622184
                                print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                                // branch -> 0x8f6221d8
                            }
                            // 0x8f6221d8
                            if (v3 != g23) {
                                // 0x8f6221ec
                                __stack_chk_fail();
                                // branch -> 0x8f6221f0
                            }
                            // 0x8f6221f0
                            return 3;
                        }
                    }
                    // 0x8f621fc0
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(5, (int32_t)"Incomplete boot image for booting", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                    // 0x8f6221d8
                    if (v3 != g23) {
                        // 0x8f6221ec
                        __stack_chk_fail();
                        // branch -> 0x8f6221f0
                    }
                    // 0x8f6221f0
                    return 3;
                }
                // 0x8f621fcc
                memcmp_rc = memcmp((char *)-0x6e000000, "ANDROID!", 8);
                v16 = memcmp_rc;
                if (memcmp_rc != 0) {
                    // if_8f621fe0_0_true
                    v44 = (int32_t)"Boot image on flash is invalid\n";
                    // branch -> 0x8f621fb4
                    // 0x8f621fb4
                    v34 = print_log(0, (int32_t)"Boot image on flash is invalid\n", memcmp_rc, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    if (v18 != 0) {
                        // 0x8f621ff0
                        v62 = *(int32_t *)(str + 16);
                        v12 = v62;
                        if (v62 != 0) {
                            v48 = 0;
                            v32 = 0;
                            // 0x8f622130
                            v45 = enable_cont_splash_screen(v34, v44);
                            v46 = set_logo(0, v44, v45, v12);
                            v16 = v46;
                            v12 = &g4;
                            show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                            fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                            v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                            v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                            v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                            v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                            v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                            if (v41 == 0) {
                                // 0x8f62218c
                                print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                                v61 = v41;
                                v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                                v58 = str;
                                v70 = *(int32_t *)(v58 + 12);
                                v71 = *(int32_t *)(v58 + 32);
                                v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                                v59 = str;
                                v72 = *(int32_t *)(v59 + 20);
                                v73 = *(int32_t *)(v59 + 16);
                                v56 = v59 + 64;
                                boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                                set_current_boot_mode(6, v71, v56, v42);
                                // branch -> 0x8f6221d8
                            } else {
                                // 0x8f62217c
                                // branch -> 0x8f622184
                                // 0x8f622184
                                print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                                // branch -> 0x8f6221d8
                            }
                            // 0x8f6221d8
                            if (v3 != g23) {
                                // 0x8f6221ec
                                __stack_chk_fail();
                                // branch -> 0x8f6221f0
                            }
                            // 0x8f6221f0
                            return 3;
                        }
                    }
                    // 0x8f621fc0
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(5, (int32_t)"Incomplete boot image for booting", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                    // 0x8f6221d8
                    if (v3 != g23) {
                        // 0x8f6221ec
                        __stack_chk_fail();
                        // branch -> 0x8f6221f0
                    }
                    // 0x8f6221f0
                    return 3;
                }
                // 0x8f622000
                *(char *)-0x6dfffdc1 = 0;
                v50 = *(int32_t *)-0x6dffffdc;
                v63 = *(int32_t *)(str2 + 56);
                str2 = str + 64;
                if (v50 != 0) {
                    // if_8f622018_0_true
                    v5 = v50;
                    // branch -> after_if_8f622018_0
                }
                // after_if_8f622018_0
                v74 = v63 - 0x644d5241;
                update_ker_tags_rdisk_addr(-0x6e000000, (int32_t)(v74 == 0), v16, v74, 0, 0, a3);
                if (strlen((char *)str2) == 0) {
                    // 0x8f622050
                    print_log(1, (int32_t)"Use existing boot command line\n", v16, v74, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    v44 = -0x6dffffc0;
                    v16 = 512;
                    v49 = strlcat(str2, -0x6dffffc0, 512, v74, 0, 0, a3, v3, g29, g30, g31, g32);
                    // branch -> 0x8f622068
                } else {
                    // 0x8f622044
                    v44 = (int32_t)"Override existing boot command line\n";
                    v35 = print_log(1, (int32_t)"Override existing boot command line\n", v16, v74, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    v49 = v35;
                    // branch -> 0x8f622068
                }
                // 0x8f622068
                v57 = str;
                v64 = *(int32_t *)(v57 + 16);
                v12 = v64;
                v31 = v49;
                if (v64 == 0) {
                    // 0x8f622074
                    v51 = v5;
                    v53 = -v51;
                    v65 = *(int32_t *)-0x6dfffff8;
                    v66 = *(int32_t *)(v57 + 20);
                    v75 = *(int32_t *)-0x6dfffff0 - 1 + v51 & v53;
                    str2 = v75;
                    memcpy((char *)v66, (char *)(2 * v51 - 0x6e000001 + v65 & v53), v75);
                    *(int32_t *)(str + 16) = str2;
                    v44 = (int32_t)"load ramdisk from emmc(size=0x%x) to 0x%x\n";
                    v60 = str2;
                    v16 = v60;
                    v67 = *(int32_t *)(str + 20);
                    v12 = v67;
                    v36 = print_log(1, (int32_t)"load ramdisk from emmc(size=0x%x) to 0x%x\n", v60, v67, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    v31 = v36;
                    // branch -> 0x8f6220c4
                }
                // 0x8f6220c4
                if (v18 == 0) {
                    // 0x8f6220cc
                    print_log(1, (int32_t)"try to use device tree from existing boot image...\n", v16, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                    v68 = *(int32_t *)-0x6dfffff8;
                    v52 = v5;
                    v54 = -v52;
                    v69 = *(int32_t *)-0x6dfffff0;
                    v55 = *(int32_t *)-0x6dffffe8 - 1;
                    v76 = v55 + v52 & v54;
                    v12 = v76;
                    v77 = v52 - 0x6e000000 + (v52 - 1 + v69 & v54) + (v68 - 1 + v52 & v54) + v76;
                    v44 = v77;
                    v37 = select_device_tree(-0x6e000000, v77, v55, v76, 0, 0, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                    if (v37 == 0) {
                        // if_8f622128_0_true
                        // branch -> 0x8f622184
                        // 0x8f622184
                        print_log(0, (int32_t)"not found valid device tree in existing boot image\n", v55, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                        // branch -> 0x8f6221d8
                        // 0x8f6221d8
                        if (v3 != g23) {
                            // 0x8f6221ec
                            __stack_chk_fail();
                            // branch -> 0x8f6221f0
                        }
                        // 0x8f6221f0
                        return 3;
                    }
                    v30 = v37;
                    v48 = 0;
                    v32 = 0;
                } else {
                    v30 = v31;
                    v48 = 0;
                    v32 = 0;
                }
                // 0x8f622130
                v45 = enable_cont_splash_screen(v30, v44);
                v46 = set_logo(0, v44, v45, v12);
                v16 = v46;
                v12 = &g4;
                show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                if (v41 == 0) {
                    // 0x8f62218c
                    print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    v61 = v41;
                    v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                    v58 = str;
                    v70 = *(int32_t *)(v58 + 12);
                    v71 = *(int32_t *)(v58 + 32);
                    v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                    v59 = str;
                    v72 = *(int32_t *)(v59 + 20);
                    v73 = *(int32_t *)(v59 + 16);
                    v56 = v59 + 64;
                    boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                    set_current_boot_mode(6, v71, v56, v42);
                    // branch -> 0x8f6221d8
                } else {
                    // 0x8f62217c
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                }
                // 0x8f6221d8
                if (v3 != g23) {
                    // 0x8f6221ec
                    __stack_chk_fail();
                    // branch -> 0x8f6221f0
                }
                // 0x8f6221f0
                return 3;
            }
        } else {
            // 0x8f621f50
            *(char *)(str + 575) = 0;
            // branch -> 0x8f621f60
        }
        int32_t v78 = *(int32_t *)(str + 16); // 0x8f621f60
        v12 = v78;
        if (v78 != 0) {
            // 0x8f621f6c
            if (strlen((char *)(str + 64)) != 0) {
                // 0x8f621f7c
                v44 = (int32_t)"got everything for booting\n";
                v30 = print_log(1, (int32_t)"got everything for booting\n", v16, v12, v1, a2, a3, v3, g29, g30, g31, g32, g33);
                v48 = v1;
                v32 = a2;
                // branch -> 0x8f622130
                // 0x8f622130
                v45 = enable_cont_splash_screen(v30, v44);
                v46 = set_logo(0, v44, v45, v12);
                v16 = v46;
                v12 = &g4;
                show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                if (v41 == 0) {
                    // 0x8f62218c
                    print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    v61 = v41;
                    v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                    v58 = str;
                    v70 = *(int32_t *)(v58 + 12);
                    v71 = *(int32_t *)(v58 + 32);
                    v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                    v59 = str;
                    v72 = *(int32_t *)(v59 + 20);
                    v73 = *(int32_t *)(v59 + 16);
                    v56 = v59 + 64;
                    boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                    set_current_boot_mode(6, v71, v56, v42);
                    // branch -> 0x8f6221d8
                } else {
                    // 0x8f62217c
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                }
                // 0x8f6221d8
                if (v3 != g23) {
                    // 0x8f6221ec
                    __stack_chk_fail();
                    // branch -> 0x8f6221f0
                }
                // 0x8f6221f0
                return 3;
            }
        }
        // 0x8f621f8c
        v16 = 0;
        v12 = 0;
        v33 = load_partition_by_name((int32_t)"boot", -0x6e000000, 0, 0, 0, 0, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
        if (v33 != -1) {
            // 0x8f621fcc
            memcmp_rc = memcmp((char *)-0x6e000000, "ANDROID!", 8);
            v16 = memcmp_rc;
            if (memcmp_rc != 0) {
                // if_8f621fe0_0_true
                v44 = (int32_t)"Boot image on flash is invalid\n";
                // branch -> 0x8f621fb4
                // 0x8f621fb4
                v34 = print_log(0, (int32_t)"Boot image on flash is invalid\n", memcmp_rc, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                if (v18 != 0) {
                    // 0x8f621ff0
                    v62 = *(int32_t *)(str + 16);
                    v12 = v62;
                    if (v62 != 0) {
                        v48 = 0;
                        v32 = 0;
                        // 0x8f622130
                        v45 = enable_cont_splash_screen(v34, v44);
                        v46 = set_logo(0, v44, v45, v12);
                        v16 = v46;
                        v12 = &g4;
                        show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                        fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                        v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                        v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                        v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                        v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                        v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                        if (v41 == 0) {
                            // 0x8f62218c
                            print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                            v61 = v41;
                            v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                            v58 = str;
                            v70 = *(int32_t *)(v58 + 12);
                            v71 = *(int32_t *)(v58 + 32);
                            v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                            v59 = str;
                            v72 = *(int32_t *)(v59 + 20);
                            v73 = *(int32_t *)(v59 + 16);
                            v56 = v59 + 64;
                            boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                            set_current_boot_mode(6, v71, v56, v42);
                            // branch -> 0x8f6221d8
                        } else {
                            // 0x8f62217c
                            // branch -> 0x8f622184
                            // 0x8f622184
                            print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                            // branch -> 0x8f6221d8
                        }
                        // 0x8f6221d8
                        if (v3 != g23) {
                            // 0x8f6221ec
                            __stack_chk_fail();
                            // branch -> 0x8f6221f0
                        }
                        // 0x8f6221f0
                        return 3;
                    }
                }
                // 0x8f621fc0
                // branch -> 0x8f622184
                // 0x8f622184
                print_log(5, (int32_t)"Incomplete boot image for booting", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                // branch -> 0x8f6221d8
                // 0x8f6221d8
                if (v3 != g23) {
                    // 0x8f6221ec
                    __stack_chk_fail();
                    // branch -> 0x8f6221f0
                }
                // 0x8f6221f0
                return 3;
            }
            // 0x8f622000
            *(char *)-0x6dfffdc1 = 0;
            v50 = *(int32_t *)-0x6dffffdc;
            v63 = *(int32_t *)(str2 + 56);
            str2 = str + 64;
            if (v50 != 0) {
                // if_8f622018_0_true
                v5 = v50;
                // branch -> after_if_8f622018_0
            }
            // after_if_8f622018_0
            v74 = v63 - 0x644d5241;
            update_ker_tags_rdisk_addr(-0x6e000000, (int32_t)(v74 == 0), v16, v74, 0, 0, a3);
            if (strlen((char *)str2) == 0) {
                // 0x8f622050
                print_log(1, (int32_t)"Use existing boot command line\n", v16, v74, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                v44 = -0x6dffffc0;
                v16 = 512;
                v49 = strlcat(str2, -0x6dffffc0, 512, v74, 0, 0, a3, v3, g29, g30, g31, g32);
                // branch -> 0x8f622068
            } else {
                // 0x8f622044
                v44 = (int32_t)"Override existing boot command line\n";
                v35 = print_log(1, (int32_t)"Override existing boot command line\n", v16, v74, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                v49 = v35;
                // branch -> 0x8f622068
            }
            // 0x8f622068
            v57 = str;
            v64 = *(int32_t *)(v57 + 16);
            v12 = v64;
            v31 = v49;
            if (v64 == 0) {
                // 0x8f622074
                v51 = v5;
                v53 = -v51;
                v65 = *(int32_t *)-0x6dfffff8;
                v66 = *(int32_t *)(v57 + 20);
                v75 = *(int32_t *)-0x6dfffff0 - 1 + v51 & v53;
                str2 = v75;
                memcpy((char *)v66, (char *)(2 * v51 - 0x6e000001 + v65 & v53), v75);
                *(int32_t *)(str + 16) = str2;
                v44 = (int32_t)"load ramdisk from emmc(size=0x%x) to 0x%x\n";
                v60 = str2;
                v16 = v60;
                v67 = *(int32_t *)(str + 20);
                v12 = v67;
                v36 = print_log(1, (int32_t)"load ramdisk from emmc(size=0x%x) to 0x%x\n", v60, v67, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                v31 = v36;
                // branch -> 0x8f6220c4
            }
            // 0x8f6220c4
            if (v18 == 0) {
                // 0x8f6220cc
                print_log(1, (int32_t)"try to use device tree from existing boot image...\n", v16, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
                v68 = *(int32_t *)-0x6dfffff8;
                v52 = v5;
                v54 = -v52;
                v69 = *(int32_t *)-0x6dfffff0;
                v55 = *(int32_t *)-0x6dffffe8 - 1;
                v76 = v55 + v52 & v54;
                v12 = v76;
                v77 = v52 - 0x6e000000 + (v52 - 1 + v69 & v54) + (v68 - 1 + v52 & v54) + v76;
                v44 = v77;
                v37 = select_device_tree(-0x6e000000, v77, v55, v76, 0, 0, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                if (v37 == 0) {
                    // if_8f622128_0_true
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(0, (int32_t)"not found valid device tree in existing boot image\n", v55, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                    // 0x8f6221d8
                    if (v3 != g23) {
                        // 0x8f6221ec
                        __stack_chk_fail();
                        // branch -> 0x8f6221f0
                    }
                    // 0x8f6221f0
                    return 3;
                }
                v30 = v37;
                v48 = 0;
                v32 = 0;
            } else {
                v30 = v31;
                v48 = 0;
                v32 = 0;
            }
            // 0x8f622130
            v45 = enable_cont_splash_screen(v30, v44);
            v46 = set_logo(0, v44, v45, v12);
            v16 = v46;
            v12 = &g4;
            show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
            fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
            v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
            v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
            v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
            v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
            v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
            if (v41 == 0) {
                // 0x8f62218c
                print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                v61 = v41;
                v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                v58 = str;
                v70 = *(int32_t *)(v58 + 12);
                v71 = *(int32_t *)(v58 + 32);
                v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                v59 = str;
                v72 = *(int32_t *)(v59 + 20);
                v73 = *(int32_t *)(v59 + 16);
                v56 = v59 + 64;
                boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                set_current_boot_mode(6, v71, v56, v42);
                // branch -> 0x8f6221d8
            } else {
                // 0x8f62217c
                // branch -> 0x8f622184
                // 0x8f622184
                print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                // branch -> 0x8f6221d8
            }
            // 0x8f6221d8
            if (v3 != g23) {
                // 0x8f6221ec
                __stack_chk_fail();
                // branch -> 0x8f6221f0
            }
            // 0x8f6221f0
            return 3;
        }
        // 0x8f621fac
        v44 = (int32_t)"failed to load boot image\n";
        // branch -> 0x8f621fb4
        // 0x8f621fb4
        v34 = print_log(0, (int32_t)"failed to load boot image\n", v16, v12, 0, 0, a3, v3, g29, g30, g31, g32, g33);
        if (v18 != 0) {
            // 0x8f621ff0
            v62 = *(int32_t *)(str + 16);
            v12 = v62;
            if (v62 != 0) {
                v48 = 0;
                v32 = 0;
                // 0x8f622130
                v45 = enable_cont_splash_screen(v34, v44);
                v46 = set_logo(0, v44, v45, v12);
                v16 = v46;
                v12 = &g4;
                show((int32_t)"logo_screen", 1, v46, (int32_t)&g4, v48, v32, a3, v3, g29, g30, g31, g32, g33, g34, v2);
                fboot_ack((int32_t)"OKAY", (int32_t)"booting kernel...", v16, v12, v48, v32, a3, v3, g29, g30);
                v38 = mdelay(100, (int32_t)"booting kernel...", v16, v12);
                v39 = udc_stop(v38, (int32_t)"booting kernel...", v16, v12, v48);
                v40 = pmic_charger_cleanup(v39, (int32_t)"booting kernel...", v16, v12);
                v43 = reset_current_secure_state(v40, (int32_t)"booting kernel...", v16, v12);
                v41 = finalize_security_policies(v40, v43, v16, v12, v19, 0, 0, 0, 0, 0, 0);
                if (v41 == 0) {
                    // 0x8f62218c
                    print_log(2, (int32_t)"start booting kernel...\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    v61 = v41;
                    v47 = set_current_boot_mode(v61, (int32_t)"start booting kernel...\n", v16, v12);
                    v58 = str;
                    v70 = *(int32_t *)(v58 + 12);
                    v71 = *(int32_t *)(v58 + 32);
                    v42 = board_machtype(v61, (int32_t)"start booting kernel...\n", v47, v12);
                    v59 = str;
                    v72 = *(int32_t *)(v59 + 20);
                    v73 = *(int32_t *)(v59 + 16);
                    v56 = v59 + 64;
                    boot_linux(v70, v71, v56, v42, v72, v73, a3, v3, g29, g30, g31, g32, g33, g34, v2, 0, v19, 0, 0, 0, 0);
                    set_current_boot_mode(6, v71, v56, v42);
                    // branch -> 0x8f6221d8
                } else {
                    // 0x8f62217c
                    // branch -> 0x8f622184
                    // 0x8f622184
                    print_log(-1, (int32_t)"finalize sp failure\n", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f6221d8
                }
                // 0x8f6221d8
                if (v3 != g23) {
                    // 0x8f6221ec
                    __stack_chk_fail();
                    // branch -> 0x8f6221f0
                }
                // 0x8f6221f0
                return 3;
            }
        }
        // 0x8f621fc0
        // branch -> 0x8f622184
        // 0x8f622184
        print_log(5, (int32_t)"Incomplete boot image for booting", v16, v12, v19, 0, 0, 0, 0, 0, 0, 0, 0);
        // branch -> 0x8f6221d8
    } else {
        // 0x8f621e08
        print_log(0, (int32_t)"%s: Invalid boot image header\n", (int32_t)"handle_fboot_command_boot", v3, v1, a2, a3, v3, g29, g30, g31, g32, g33);
        fboot_info((int32_t)"INFO", (int32_t)"Invalid boot image header", (int32_t)"handle_fboot_command_boot", v3, v1, a2, a3, v3, g29, g30, g31);
        // branch -> 0x8f6221d8
    }
    // 0x8f6221d8
    if (v3 != g23) {
        // 0x8f6221ec
        __stack_chk_fail();
        // branch -> 0x8f6221f0
    }
    // 0x8f6221f0
    return 3;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strrchr(char * s, int c);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:29:06
