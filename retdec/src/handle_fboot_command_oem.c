//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t __utag_defined(int32_t a1, int32_t a2);
int32_t __utag_exists(int32_t a1, int32_t a2);
int32_t bootstrap2(int32_t a1, int32_t a2);
int32_t clock_config_cdc(int32_t a1, int32_t a2, int32_t a3);
int32_t dbval_pal_cid_get_secondary_serial_num_type(char * a1, int32_t a2, int32_t a3);
int32_t dbval_pal_cid_get_secondary_serial_number(int32_t a1, int32_t a2);
void event_unsignal(int32_t a1);
int32_t fboot_oem_init(void);
int32_t fboot_usb_write_queue(int32_t a1, uint32_t a2, int32_t a3);
int32_t fboot_usb_write_wait(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_code_hash_verification(int32_t a1, int32_t a2, char * str);
int32_t hab_publickey_verification(int32_t a1, int32_t a2, char * a3);
int32_t handle_fboot_command_oem(int32_t a1, int32_t a2);
int32_t heap_free(void);
int32_t heap_realloc(char * a1);
int32_t is_charging_enabled(int32_t a1, int32_t a2, int32_t a3);
int32_t max17042_get_battery_temperature(void);
int32_t max17050_get_battery_capacity(int32_t a1, int32_t a2);
int32_t platform_boot_dev_isemmc(int32_t a1, int32_t a2, int32_t a3);
int32_t pmic_arb_write_cmd(char * a1);
int32_t pmic_charger_cleanup(int32_t a1, int32_t a2);
int32_t register_spmi_int_handler(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t sod_ramdump_set_test_cookie(int32_t a1, int32_t a2);
int32_t sod_share(char * a1, int32_t a2, int32_t a3);
int32_t spmi_acc_irq(uint32_t a1, int32_t a2, int32_t result2, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t spmi_init(int32_t a1, int32_t a2, int32_t a3);
int32_t unregister_spmi_int_handler(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

bool g27 = false; // LR
int32_t g28 = 0; // R0
int32_t g29 = 0; // R1
int32_t g30 = 0; // R2
int32_t g31 = 0; // R3
int32_t g32 = 0; // R4
int32_t g33 = 0; // R5
int32_t g34 = 0; // R6
int32_t g35 = 0; // R7
int32_t g36 = 0; // R8
int32_t g37 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f626204
int32_t g2 = -0x16d2be0d; // 0x8f627388
int32_t g3 = -0x1a60cf3c; // 0x8f627420
int32_t g4 = -0x1a60cfc4; // 0x8f62d6e8
int32_t g5 = 0x746e6300; // 0x8f6a4e20
int32_t g6 = 0x10100; // 0x8f6a9f58
int32_t g7 = 0x10100; // 0x8f6a9f64
int32_t g8 = 0x7ffd14f4; // 0x8f6aa114
int32_t g9 = 1; // 0x8f6ac0f0
int32_t g10 = 0; // 0x8f6b8afc
int32_t g11 = 0; // 0x8f6b8b00
int32_t g12 = 0; // 0x8f6b8b04
int32_t g13 = 0; // 0x8f6b8b08
char * g14; // 0x8f6b8b0c
char * g15; // 0x8f6b8b10
int32_t g16 = 0; // 0x8f6c064c
int32_t g17 = 0; // 0x8f6c0650
int32_t g18 = 0; // 0x8f6c0654
int32_t g19 = 0; // 0x8f6c0658
int32_t g20 = 0; // 0x8f6c0660
int32_t g21 = 0; // 0x8f6c066c
int32_t g22 = 0; // 0x8f6e0b48
char * g23; // 0x8f6e0b60
int32_t g24 = 0; // 0x8f7112f4
int32_t g25 = 0; // 0x8f7129dc
int32_t g26 = 0; // 0x8f712a1c

// ------------------------ Functions -------------------------

// Address range: 0x8f62b344 - 0x8f62b563
int32_t handle_fboot_command_oem(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-40
    int32_t v2 = g32; // 0x8f62b344
    int32_t v3 = g33; // 0x8f62b344
    int32_t v4 = g34; // 0x8f62b344
    int32_t v5 = g35; // 0x8f62b344
    int32_t v6 = g36; // 0x8f62b344
    int32_t v7 = &v1; // 0x8f62b344_1
    int32_t v8 = *(int32_t *)(a1 + 12); // 0x8f62b350
    int32_t v9 = g24;
    g36 = &g24;
    v1 = 0;
    g29 = v7;
    int32_t v10 = arg_split(v8 + 1, v7, g30, 0, 0, v9, v2, v3, v4); // 0x8f62b370
    g33 = v10;
    if (v10 == 0) {
        // if_8f62b378_0_true
        // branch -> 0x8f62b50c
    } else {
        int32_t v11 = v1; // 0x8f62b380
        g31 = v11;
        int32_t v12;
        if (v11 != 0) {
            int32_t str = *(int32_t *)v10; // 0x8f62b38c
            g34 = str;
            g29 = (int32_t)"help";
            g35 = &g8;
            int32_t result; // R4
            if (strcmp((char *)str, "help") == 0) {
                // 0x8f62b3ac
                result = &g7;
                int32_t v13 = &g5; // R9
                int32_t v14 = (int32_t)"..."; // R10
                g31 = (int32_t)&g7 - 12;
                if (g35 != (int32_t)&g7 - 12) {
                    int32_t v15 = 0; // 0x8f62b3d0
                    int32_t v16 = &g7; // 0x8f62b3c4
                    while (true) {
                        char v17 = *(char *)(v16 - 12); // 0x8f62b3c4
                        int32_t v18 = v17; // 0x8f62b3c4
                        int32_t v19 = v18; // R3
                        int32_t v20 = v15; // 0x8f62b3d021
                        int32_t v21; // 0x8f62b474
                        int32_t v22; // 0x8f62b474
                        if (v17 == 0) {
                            int32_t v23 = is_verified_boot_flow(v15, g29, g30, v18); // 0x8f62b3d0
                            int32_t v24 = 0; // 0x8f62b3dc
                            if (v23 != 0) {
                                int32_t v25 = get_current_secure_state(v23, g29, g30, v19, v1, v9); // 0x8f62b3ec
                                if (v25 == 3) {
                                    int32_t str2 = *(int32_t *)(result - 8); // 0x8f62b3f8
                                    int32_t str3 = str2; // R6
                                    g29 = (int32_t)"unlock";
                                    if (strcmp((char *)str2, "unlock") != 0) {
                                        // 0x8f62b410
                                        g29 = (int32_t)"verified";
                                        int32_t strcmp_rc = strcmp((char *)str3, "verified"); // 0x8f62b418
                                        if (strcmp_rc != 0) {
                                            v20 = strcmp_rc;
                                          lab_0x8f62b474_4:
                                            // 0x8f62b474
                                            v21 = result;
                                            v22 = v21 + 12;
                                            result = v22;
                                            g31 = v21;
                                            if (v21 == g35) {
                                                // break -> 0x8f62b47c
                                                break;
                                            }
                                            v15 = v20;
                                            v16 = v22;
                                            // continue -> 0x8f62b3c4
                                            continue;
                                        } else {
                                            v24 = 0;
                                        }
                                    } else {
                                        v24 = 0;
                                    }
                                } else {
                                    v24 = v25;
                                }
                            }
                            int32_t v26 = is_validation_enabled((char *)v24, g29, g30, v19); // 0x8f62b3dc
                            if (v26 == 0) {
                                // 0x8f62b3dc
                                // branch -> 0x8f62b434
                            } else {
                                char v27 = *(char *)(result - 10); // 0x8f62b428
                                int32_t v28 = v27; // 0x8f62b428
                                if (v27 == 0) {
                                    v20 = v26;
                                    goto lab_0x8f62b474_4;
                                }
                                // 0x8f62b434
                                int32_t v29; // 0x8f62b470
                                int32_t v30;
                                int32_t v31; // 0x8f62b454
                                char v32; // 0x8f62b454
                                int32_t v33; // 0x8f62b464
                                if (is_verified_boot_flow(v26, g29, g30, v28) == 0) {
                                  lab_0x8f62b440:
                                    // 0x8f62b440
                                    g29 = (int32_t)"verified";
                                    if (strcmp((char *)*(int32_t *)(result - 8), "verified") == 0) {
                                        v20 = 0;
                                        goto lab_0x8f62b474_4;
                                    }
                                    // 0x8f62b454
                                    v31 = result;
                                    v32 = *(char *)(v31 - 11);
                                    g29 = (int32_t)"%s%s";
                                    v33 = *(int32_t *)(v31 - 8);
                                    g30 = v33;
                                    v30 = v32 == 0 ? v13 : v14;
                                    v29 = fboot_info((int32_t)"INFO", (int32_t)"%s%s", v33, v30, v1, v9, v2, v3, v4, v5, v6);
                                    v20 = v29;
                                    // branch -> 0x8f62b474
                                    goto lab_0x8f62b474_4;
                                } else {
                                  lab_0x8f62b454:
                                    // 0x8f62b454
                                    v31 = result;
                                    v32 = *(char *)(v31 - 11);
                                    g29 = (int32_t)"%s%s";
                                    v33 = *(int32_t *)(v31 - 8);
                                    g30 = v33;
                                    v30 = v32 == 0 ? v13 : v14;
                                    v29 = fboot_info((int32_t)"INFO", (int32_t)"%s%s", v33, v30, v1, v9, v2, v3, v4, v5, v6);
                                    v20 = v29;
                                    // branch -> 0x8f62b474
                                    goto lab_0x8f62b474_4;
                                }
                            }
                            // 0x8f62b434
                            if (is_verified_boot_flow(v26, g29, g30, v19) == 0) {
                                goto lab_0x8f62b440;
                            }
                            goto lab_0x8f62b454;
                        }
                        // 0x8f62b474
                        v21 = result;
                        v22 = v21 + 12;
                        result = v22;
                        g31 = v21;
                        if (v21 == g35) {
                            // break -> 0x8f62b47c
                            break;
                        }
                        v15 = v20;
                        v16 = v22;
                        // continue -> 0x8f62b3c4
                    }
                    // 0x8f62b47c
                    // branch -> 0x8f62b504
                    // 0x8f62b504
                    arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
                    // branch -> 0x8f62b50c
                    // 0x8f62b50c
                    if (v9 != g24) {
                        // 0x8f62b520
                        __stack_chk_fail();
                        // branch -> 0x8f62b524
                    }
                    // 0x8f62b524
                    return 1;
                }
                // 0x8f62b47c
                result = 1;
                // branch -> 0x8f62b504
            } else {
                // 0x8f62b4a0
                g32 = &g6;
                int32_t v34;
                int32_t v35; // 0x8f62b4e8
                if (g35 != (int32_t)&g6) {
                    int32_t v36 = &g6; // 0x8f62b484
                    while (true) {
                        int32_t str4 = *(int32_t *)(v36 + 4); // 0x8f62b484
                        int32_t str5 = g34; // 0x8f62b488
                        int32_t v37 = str5; // R1
                        g30 = 32;
                        if (strncmp((char *)str4, (char *)str5, 32) == 0) {
                            int32_t v38 = g32;
                            if (is_validation_enabled(NULL, v37, g30, g31) != 0) {
                                char v39 = *(char *)(v38 + 2); // 0x8f62b4b8
                                int32_t v40 = v39; // 0x8f62b4b8
                                g31 = v40;
                                if (v39 == 0) {
                                    v34 = (int32_t)"command restricted";
                                    // 0x8f62b4fc
                                    g29 = v34;
                                    fboot_info((int32_t)"INFO", v34, g30, v40, v12, 0, 0, 0, 0, 0, 0);
                                    // branch -> 0x8f62b500
                                    // 0x8f62b500
                                    // branch -> 0x8f62b504
                                    // 0x8f62b504
                                    arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
                                    // branch -> 0x8f62b50c
                                    // 0x8f62b50c
                                    if (v9 != g24) {
                                        // 0x8f62b520
                                        __stack_chk_fail();
                                        // branch -> 0x8f62b524
                                    }
                                    // 0x8f62b524
                                    return 3;
                                }
                            }
                            int32_t v41 = *(int32_t *)(v38 + 8); // 0x8f62b4cc
                            g31 = v41;
                            int32_t v42 = g33; // 0x8f62b4d0
                            g29 = v42;
                            g28 = v1;
                            g27 = true;
                            ((int32_t (*)(int32_t, int32_t, int32_t))v41)(v1, v42, v41);
                            // branch -> 0x8f62b504
                            // 0x8f62b504
                            arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
                            // branch -> 0x8f62b50c
                            // 0x8f62b50c
                            if (v9 != g24) {
                                // 0x8f62b520
                                __stack_chk_fail();
                                // branch -> 0x8f62b524
                            }
                            // 0x8f62b524
                            return g28;
                        }
                        int32_t v43 = g32 + 12; // 0x8f62b49c
                        g32 = v43;
                        if (v43 == g35) {
                            // break -> 0x8f62b4e4
                            break;
                        }
                        v36 = v43;
                        // continue -> 0x8f62b484
                    }
                    // 0x8f62b4e4
                    v35 = g34;
                    g30 = v35;
                    fboot_info((int32_t)"INFO", (int32_t)"'%s' is not a supported oem command", v35, g31, v12, 0, 0, 0, 0, 0, 0);
                    v34 = (int32_t)"See 'fastboot oem help'\n";
                    // branch -> 0x8f62b4fc
                    // 0x8f62b4fc
                    g29 = v34;
                    fboot_info((int32_t)"INFO", v34, g30, g31, v12, 0, 0, 0, 0, 0, 0);
                    // branch -> 0x8f62b500
                    // 0x8f62b500
                    // branch -> 0x8f62b504
                    // 0x8f62b504
                    arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
                    // branch -> 0x8f62b50c
                    // 0x8f62b50c
                    if (v9 != g24) {
                        // 0x8f62b520
                        __stack_chk_fail();
                        // branch -> 0x8f62b524
                    }
                    // 0x8f62b524
                    return 3;
                }
                // 0x8f62b4e4
                v35 = g34;
                g30 = v35;
                fboot_info((int32_t)"INFO", (int32_t)"'%s' is not a supported oem command", v35, g31, v12, 0, 0, 0, 0, 0, 0);
                v34 = (int32_t)"See 'fastboot oem help'\n";
                // branch -> 0x8f62b4fc
                // 0x8f62b4fc
                g29 = v34;
                fboot_info((int32_t)"INFO", v34, g30, g31, v12, 0, 0, 0, 0, 0, 0);
                // branch -> 0x8f62b500
                // 0x8f62b500
                result = 3;
                // branch -> 0x8f62b504
            }
            // 0x8f62b504
            arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
            // branch -> 0x8f62b50c
            // 0x8f62b50c
            if (v9 != g24) {
                // 0x8f62b520
                __stack_chk_fail();
                // branch -> 0x8f62b524
            }
            // 0x8f62b524
            return result;
        }
        // 0x8f62b500
        // branch -> 0x8f62b504
        // 0x8f62b504
        arg_free(g33, g29, g30, g31, v12, 0, 0, 0);
        // branch -> 0x8f62b50c
    }
    // 0x8f62b50c
    if (v9 != g24) {
        // 0x8f62b520
        __stack_chk_fail();
        // branch -> 0x8f62b524
    }
    // 0x8f62b524
    return 3;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int strcmp(const char * s1, const char * s2);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 27
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:33:17
