//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_constprop_3_6(char * a1, int32_t a2);
int32_t __utag_gets_constprop_5(char * a1, int32_t a2, int32_t a3);
int32_t boot_handler(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t check_wififlash_mode(char * a1, int32_t a2);
int32_t fastboot_reason(int32_t a1);
int32_t fboot_ack(char * str, char * format, int32_t a3);
int32_t get_sku(char * a1, int32_t a2);
int32_t init_boot_event(int32_t a1, int32_t a2);
int32_t load_and_validate_kernel_image(int32_t a1);
char * mbm_entry(void);
char * mbm_init(void);
int32_t select_device_tree(int32_t a1, int32_t a2);
int32_t set_boot_item(int32_t result, int32_t a2, int32_t a3);
int32_t sparse_fill_value_in_blocks(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t type_atoi_5(char * str, int32_t a2, int32_t a3);
int32_t type_atoi_7(char * str, int32_t a2, int32_t a3);
int32_t update_console_token(char * a1, char * str, char * a3);

// --------------------- Global Variables ---------------------

int32_t g24 = 0; // LR
int32_t g25 = 0; // R0
int32_t g26 = 0; // R1
int32_t g27 = 0; // R10
int32_t g28 = 0; // R11
int32_t g29 = 0; // R2
int32_t g30 = 0; // R3
int32_t g31 = 0; // R4
int32_t g32 = 0; // R5
int32_t g33 = 0; // R6
int32_t g34 = 0; // R7
int32_t g35 = 0; // R8
int32_t g36 = 0; // R9
int32_t g1 = -0x16d2bf90; // 0x8f61db1c
int32_t g2 = -0x16d2bf81; // 0x8f61dca0
int32_t g3 = -0x16d2bfc9; // 0x8f6387c0
int32_t g4 = -0x16d2bc09; // 0x8f638ab0
int32_t g5 = 0x2020003a; // 0x8f686ac4
char g6[2] = " "; // 0x8f6a4f1e
int32_t g7 = 1; // 0x8f6ac0f0
char * g10 = "\xd4\xc7\x61\x8f\x90\x15\x60\x8f"; // 0x8f6ac19c
char * g11[2] = {
    "ttyHSL0,115200,n8",
    "ttyHSL0,115200,n8"
}; // 0x8f6ac1a8
int32_t g12 = -0x709c73f8; // 0x8f6ac374
char * g13; // 0x8f6c0298
int32_t g14 = 0; // 0x8f6c02e0
int32_t g15 = 0; // 0x8f6c02ec
char * g16; // 0x8f6c0334
int32_t g17 = 0; // 0x8f7112f4
char * g18; // 0x8f7114b0
int32_t g19 = 0; // 0x8f7114b4
int32_t g20 = 0; // 0x8f7114b8
int32_t g21 = 0; // 0x8f7114d4
char * g22; // 0x8f7114f0
int32_t g23 = 0; // 0x8f7125ec
char * g8[4] = {
    "null",
    "fastboot",
    (char *)&g1,
    (char *)&g2
}; // 0x8f6ac108
char * g9[3] = {
    "fastboot",
    (char *)&g1,
    (char *)&g2
}; // 0x8f6ac10c

// ------------------------ Functions -------------------------

// Address range: 0x8f621418 - 0x8f621533
int32_t sparse_fill_value_in_blocks(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g31; // 0x8f621418
    int32_t v2 = g33; // 0x8f621418
    uint32_t v3 = a4 * a3; // 0x8f621420
    int32_t v4 = 0; // R5
    g33 = a1;
    int32_t v5 = g17;
    int32_t v6 = 0; // R11
    g31 = v3;
    int32_t v7 = v3 > 0x8000000 ? 0x8000000 : v3; // R10
    if (v3 > 0x8000000) {
        // if_8f621468_0_true
        v6 = 0;
        // branch -> after_if_8f621468_0
    }
    // after_if_8f621468_0
    function_8f64ae60(-0x79000000);
    int32_t v8 = v4; // 0x8f621470
    int32_t v9;
    int32_t v10;
    print_log(2, (int32_t)"Fill value(0x%x) to %d blocks: size=0x%llx\n", v9, a4, g31, v8, 0, v10, 0, v5, 0, v1, g32);
    int32_t v11 = v4; // 0x8f62148c2
    int32_t v12 = g31; // 0x8f62148c4
    if ((v12 || v11) == 0) {
        // 0x8f621508
        if (v5 != g17) {
            // 0x8f62151c
            __stack_chk_fail();
            // branch -> 0x8f621520
        }
        // 0x8f621520
        g31 = v1;
        g33 = v2;
        return 0;
    }
    while (true) {
        bool v13 = false; // 0x8f6214ac
        bool v14 = v11 >= v6; // 0x8f6214ac
        if (v11 == v6) {
            // if_8f621498_0_true
            v13 = v12 == v7;
            v14 = v12 >= v7;
            // branch -> after_if_8f621498_0
        }
        int32_t v15 = v12; // R8
        int32_t v16 = v11; // R9
        int32_t v17 = v12; // 0x8f6214b819
        int32_t v18 = v11; // 0x8f6214bc
        if (v14 && v13 ^ true) {
            // if_8f6214ac_0_true
            v15 = v7;
            v16 = v6;
            v17 = v7;
            v18 = v6;
            // branch -> after_if_8f6214ac_0
        }
        // after_if_8f6214ac_0
        if (generic_mmc_write_logical(g33, a2, v17, v18, -0x79000000, v8, 0, -0x79000000, 0, v5, 0, v1, g32, v2, g34, g35, g36, g27, g28, g24, v9, 0, 0, 0, 0, 0, 0, 0) == 0) {
            uint32_t v19 = g33; // 0x8f6214f0
            int32_t v20 = v19 + v15; // 0x8f6214f0
            g33 = v20;
            a2 = a2 + v16 + (int32_t)(v20 < v19);
            uint32_t v21 = g31; // 0x8f6214f8
            int32_t v22 = v21 - v15; // 0x8f6214f8
            g31 = v22;
            int32_t v23 = v4 - v16 + (int32_t)(v21 < v15); // 0x8f6214fc
            v4 = v23;
            if ((v23 || v22) == 0) {
                // break -> 0x8f621508
                break;
            }
            v12 = v22;
            v11 = v23;
            // continue -> 0x8f621494
            continue;
        } else {
            // 0x8f6214d4
            print_log(-1, (int32_t)"Failed to fill value at 0x%llx\n", g33, a2, -0x79000000, v8, 0, -0x79000000, 0, v5, 0, v1, g32);
            // branch -> 0x8f621508
        }
        // 0x8f621508
        if (v5 != g17) {
            // 0x8f62151c
            __stack_chk_fail();
            // branch -> 0x8f621520
        }
        // 0x8f621520
        g31 = v1;
        g33 = v2;
        return -1;
    }
    // 0x8f621508
    if (v5 != g17) {
        // 0x8f62151c
        __stack_chk_fail();
        // branch -> 0x8f621520
    }
    // 0x8f621520
    g31 = v1;
    g33 = v2;
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// char * asctime(const struct tm * tp);
// struct tm * gmtime(const time_t * timer);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// char * strncat(char * restrict dest, const char * restrict src, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// size_t strnlen(const char * string, size_t maxlen);
// char * strrchr(char * s, int c);
// char * strtok(char * restrict s, const char * restrict delim);
// time_t time(time_t * timer);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 17
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:36:36
