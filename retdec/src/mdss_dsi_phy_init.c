//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t backlight_set_brightness(int32_t a1, int32_t a2);
int32_t backlight_set_brightness_level(int32_t a1);
int32_t cxo_clk_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t cxo_clk_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t disable_source_detect_irq(void);
int32_t enable_fastchg_irq(int32_t a1);
int32_t fdt32_to_cpu_100(int32_t a1, int32_t a2, int32_t a3);
int32_t fdt_move(char * a1, char * a2, int32_t a3);
int32_t fti_serialno(int32_t a1, int32_t a2, int32_t a3);
int32_t get_default_backup_zone(int32_t a1, int32_t a2);
int32_t halt(int32_t result, int32_t a2, int32_t a3);
int32_t init_gpt(void);
int32_t max17050_get_battery_voltage(int32_t a1, int32_t a2);
int32_t max17050_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t max17058_get_temp_thresholds(char * a1, int32_t a2, int32_t a3);
int32_t max17058_is_batt_temp_ok(void);
int32_t mdss_dsi_phy_contention_detection(int32_t a1, int32_t a2);
int32_t mdss_dsi_phy_init(int32_t a1, int32_t a2, int32_t a3);
int32_t scm_call(int32_t a1, int32_t a2, char * a3, int32_t a4, char * a5);
int32_t scm_call_a32(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t SecAESDecrypt(char * a1, int32_t a2, int32_t a3);
int32_t SecBoundSigAllowed(void);
int32_t SecLockFuse(void);
int32_t SecMakeProduction(int32_t a1, int32_t a2, int32_t a3);
int32_t set_gpt_opts(char * a1, int32_t result, int32_t a3);
int32_t sod_has_error(int32_t a1, int32_t a2);
int32_t sod_update(char * a1, int32_t a2, int32_t a3);
int32_t strings_delete(char * a1, int32_t a2);
int32_t strings_new(int32_t a1, int32_t a2, int32_t a3);
int32_t tps65132_config(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

bool g31 = false; // LR
int32_t g32 = 0; // R0
int32_t g33 = 0; // R1
int32_t g34 = 0; // R10
int32_t g35 = 0; // R11
int32_t g36 = 0; // R2
int32_t g37 = 0; // R4
int32_t g38 = 0; // R5
int32_t g39 = 0; // R6
int32_t g40 = 0; // R7
int32_t g41 = 0; // R8
int32_t g42 = 0; // R9
int32_t g1 = 1; // 0x8f6ac0f0
int32_t g2 = 100; // 0x8f6aca78
int32_t g3 = 768; // 0x8f6acab7
char * g4 = "\x03"; // 0x8f6acab8
int32_t g5 = -0x709adbb4; // 0x8f6afe20
char * g6; // 0x8f6b7c28
int32_t g7 = 0; // 0x8f6b7c48
int32_t g8 = 0; // 0x8f6e0a88
int32_t g9 = 0; // 0x8f6e0b48
int32_t g10 = 0; // 0x8f6e0b4c
int32_t g11 = 0; // 0x8f6e0b54
int32_t g12 = 0; // 0x8f6e0b90
int32_t g13 = 0; // 0x8f6e0bd0
int32_t g14 = 0; // 0x8f6e0bd8
int32_t g15 = 0; // 0x8f6e0bdc
int32_t g16 = 0; // 0x8f6e0be0
char * g17; // 0x8f6e12f4
char * g18; // 0x8f6e12f8
int32_t g19 = 0; // 0x8f6e130c
int32_t g20 = 0; // 0x8f6e1310
int32_t g21 = 0; // 0x8f6e1318
char * g22; // 0x8f6e131c
char * g23; // 0x8f6e1320
char * g24; // 0x8f6e1328
char * g25; // 0x8f6e1400
char g26 = 0; // 0x8f6e15c2
char * g27; // 0x8f6e9600
int32_t g28 = 0; // 0x8f6ed600
int32_t g29 = 0; // 0x8f7112f4
int32_t g30 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f6113f0 - 0x8f61165b
int32_t mdss_dsi_phy_init(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g31 ? -0x709c0700 : 0; // 0x8f6113f0
    int32_t v2 = a1; // R6
    int32_t v3 = *(int32_t *)(a1 + 12); // 0x8f611400
    int32_t v4 = v3; // R5
    int32_t v5 = g29;
    int32_t v6; // R3
    int32_t v7; // R9
    int32_t v8; // 0x8f611594
    int32_t v9; // 0x8f611598
    if (*(int32_t *)(v3 + 152) == 0) {
        int32_t result = mdp_get_revision(a1, a2, a3, 0); // 0x8f611510
        if (result == 5) {
            // 0x8f61151c
            if (v5 == g29) {
                // 0x8f61152c
                int32_t v10;
                return mdss_dsi_v2_phy_init(v2, a2, v5, v5, g37, g38, g39, g40, g41, g42, g34, g35, v1, v10, 0, 0, 0, 0);
            }
            // 0x8f61163c
            __stack_chk_fail();
            // branch -> 0x8f611640
        } else {
            int32_t v11 = *(int32_t *)(v2 + 12); // 0x8f611540
            v2 = v11;
            v4 = 320;
            int32_t v12 = *(int32_t *)(v11 + 92); // 0x8f61154c
            *(int32_t *)(a3 + 388) = v12;
            mdss_dsi_phy_regulator_init(v11, a3, a3, v12, a1, v5, a3, g37, g38, g39, g40, g41);
            int32_t v13 = v11; // 0x8f611560
            *(int32_t *)(a3 + v4) = *(int32_t *)(v13 + 28);
            v4 += 4;
            function_8f61951c();
            // branch -> 0x8f611560
            while (v4 != 368) {
                // 0x8f611560
                v13 += 4;
                *(int32_t *)(a3 + v4) = *(int32_t *)(v13 + 28);
                v4 += 4;
                function_8f61951c();
                // continue -> 0x8f611560
            }
            // 0x8f61157c
            v4 = 0;
            *(int32_t *)(a3 + 372) = 0;
            *(int32_t *)(a3 + 368) = 95;
            function_8f61951c();
            int32_t v14 = v4; // 0x8f611590
            // branch -> 0x8f611590
          lab_0x8f611590:
            while (true) {
                // 0x8f611590
                v8 = a3 + 64 * v14;
                v9 = v2 + 9 * v14;
                v7 = 0;
                int32_t v15 = 0; // 0x8f6115a8
                // branch -> 0x8f6115a0
                while (true) {
                    char v16 = *(char *)(v15 + v9 + 106); // 0x8f6115a4
                    *(int32_t *)(4 * v15 + v8) = (int32_t)v16;
                    v7++;
                    function_8f61951c();
                    int32_t v17 = v7; // 0x8f6115b4
                    if (v17 == 9) {
                        int32_t v18 = v4 + 1; // 0x8f6115bc
                        v4 = v18;
                        if (v18 == 5) {
                            // break (via goto) -> 0x8f6115c8
                            goto lab_0x8f6115c8;
                        }
                        v14 = v18;
                        // continue (via goto) -> 0x8f611590
                        goto lab_0x8f611590;
                    } else {
                        // 0x8f6115a0
                        v15 = v17;
                        // branch -> 0x8f6115a0
                        continue;
                    }
                }
              lab_0x8f6115c8:
                // 0x8f6115c8
                *(int32_t *)(a3 + 368) = 95;
                int32_t v19; // 0x8f61160c
                int32_t v20; // 0x8f611600
                if (a3 != 0x1a98500) {
                    // 0x8f6115dc
                    if (*(int32_t *)0x1a98000 != 0x10030001) {
                        // 0x8f6115f4
                        *(int32_t *)(a3 + 468) = 0;
                        function_8f61951c();
                        v20 = v2;
                        *(int32_t *)(a3 + 436) = (int32_t)*(char *)(v20 + 100);
                        v19 = 440;
                        v6 = v19;
                        // branch -> 0x8f611600
                        while (v19 != 460) {
                            // 0x8f611600
                            v20++;
                            *(int32_t *)(a3 + v19) = (int32_t)*(char *)(v20 + 100);
                            v19 = v6 + 4;
                            v6 = v19;
                            // continue -> 0x8f611600
                        }
                        // 0x8f611618
                        function_8f61951c();
                        *(int32_t *)(a2 + 196) = v6 & -0x10000 | 1051;
                        function_8f61951c();
                        if (v5 != g29) {
                            // 0x8f61163c
                            __stack_chk_fail();
                            // branch -> 0x8f611640
                        }
                        // 0x8f611640
                        return 0;
                    }
                }
                // 0x8f6115f0
                // branch -> 0x8f6115f4
                // 0x8f6115f4
                *(int32_t *)(a3 + 468) = 1;
                function_8f61951c();
                v20 = v2;
                v2 = v20 + 1;
                *(int32_t *)(a3 + 436) = (int32_t)*(char *)(v20 + 100);
                v19 = 440;
                v6 = v19;
                // branch -> 0x8f611600
                while (v19 != 460) {
                    // 0x8f611600
                    v20 = v2;
                    v2 = v20 + 1;
                    *(int32_t *)(a3 + v19) = (int32_t)*(char *)(v20 + 100);
                    v19 = v6 + 4;
                    v6 = v19;
                    // continue -> 0x8f611600
                }
                // 0x8f611618
                function_8f61951c();
                *(int32_t *)(a2 + 196) = v6 & -0x10000 | 1051;
                function_8f61951c();
                if (v5 != g29) {
                    // 0x8f61163c
                    __stack_chk_fail();
                    // branch -> 0x8f611640
                    // 0x8f611640
                    return 0;
                }
            }
        }
        // 0x8f611640
        return result;
    }
    int32_t v21 = *(int32_t *)(v3 + 92); // 0x8f611420
    v2 = 320;
    *(int32_t *)(a3 + 388) = v21;
    mdss_dsi_phy_regulator_init(v3, a3, a3, v21, a1, v5, a3, g37, g38, g39, g40, g41);
    int32_t v22 = v3; // 0x8f61143c
    *(int32_t *)(a3 + v2) = *(int32_t *)(v22 + 28);
    v2 += 4;
    function_8f61951c();
    // branch -> 0x8f61143c
    while (v2 != 368) {
        // 0x8f61143c
        v22 += 4;
        *(int32_t *)(a3 + v2) = *(int32_t *)(v22 + 28);
        v2 += 4;
        function_8f61951c();
        // continue -> 0x8f61143c
    }
    // 0x8f611458
    if (a3 == 0x1aa0500) {
        // 0x8f611464
        v2 = 0x1aa0000;
        v7 = 0;
        *(int32_t *)0x1aa0674 = 0;
        *(int32_t *)(v2 + 1648) = 5;
        function_8f61951c();
        *(int32_t *)(v2 + 1648) = 127;
        function_8f61951c();
        *(int32_t *)(v2 + 1748) = v7;
        *(int32_t *)(v2 + 1656) = v7;
        *(int32_t *)(v2 + 1656) = 2;
        *(int32_t *)(v2 + 1656) = 3;
        function_8f61951c();
        // branch -> 0x8f6114a4
    }
    // 0x8f6114a4
    v2 = 0;
    *(int32_t *)(a3 + 392) = *(int32_t *)(v4 + 96);
    function_8f61951c();
    int32_t v23 = v2; // 0x8f6114b4
    // branch -> 0x8f6114b4
  lab_0x8f6114b4:
    while (true) {
        int32_t v24 = a3 + 64 * v23; // 0x8f6114b8
        v8 = v24;
        int32_t v25 = v4 + 9 * v23; // 0x8f6114bc
        v9 = v25;
        v7 = 0;
        int32_t v26 = 0; // 0x8f6114cc
        // branch -> 0x8f6114c4
        while (true) {
            char v27 = *(char *)(v26 + v25 + 106); // 0x8f6114c8
            *(int32_t *)(4 * v26 + v24) = (int32_t)v27;
            v7++;
            function_8f61951c();
            if (v7 == 9) {
                int32_t v28 = v2 + 1; // 0x8f6114e0
                v2 = v28;
                if (v28 == 5) {
                    // break (via goto) -> 0x8f6114ec
                    goto lab_0x8f6114ec;
                }
                v23 = v28;
                // continue (via goto) -> 0x8f6114b4
                goto lab_0x8f6114b4;
            } else {
                // 0x8f6114c4
                v24 = v8;
                v25 = v9;
                v26 = v7;
                // branch -> 0x8f6114c4
                continue;
            }
        }
      lab_0x8f6114ec:
        // 0x8f6114ec
        function_8f61951c();
        int32_t v29 = v4; // 0x8f6114f4
        *(int32_t *)(a3 + 436) = (int32_t)*(char *)(v29 + 100);
        int32_t v30 = 440; // 0x8f611500
        v6 = v30;
        // branch -> 0x8f6114f4
        while (v30 != 460) {
            // 0x8f6114f4
            v29++;
            *(int32_t *)(a3 + v30) = (int32_t)*(char *)(v29 + 100);
            v30 = v6 + 4;
            v6 = v30;
            // continue -> 0x8f6114f4
        }
        // 0x8f611618
        function_8f61951c();
        *(int32_t *)(a2 + 196) = v6 & -0x10000 | 1051;
        function_8f61951c();
        if (v5 == g29) {
            // 0x8f611640
            return 0;
        }
        // 0x8f61163c
        __stack_chk_fail();
        // branch -> 0x8f611640
        // 0x8f611640
        return 0;
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:59:59
