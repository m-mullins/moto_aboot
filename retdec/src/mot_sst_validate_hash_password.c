//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __aeabi_idivmod(int32_t a1, int32_t a2);
int32_t __utag_describe(int32_t a1, int32_t a2, int32_t a3);
int32_t arg_free(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t atoull(char * a1, int32_t a2);
int32_t decode_hw_type(char * a1, int32_t a2, int32_t a3);
int32_t display_render_done(int32_t a1, int32_t a2);
int32_t fdt_pack(int32_t a1, int32_t a2, int32_t a3);
int32_t font_draw_char_moto(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t font_draw_char_moto_horizontal(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
void function_8f649e14(void);
void function_8f67b584(void);
int32_t get_timestamp(int32_t a1, int32_t a2, int32_t a3);
int32_t initialize_montgomery_alg(int32_t * a1, int32_t a2, int32_t a3);
int32_t is_charging_enabled(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data_length(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_is_warranty_void(int32_t a1);
int32_t mot_sst_set_state_values_for_nonhlos(void);
int32_t mot_sst_validate_hash_password(int32_t a1, char * a2);
int32_t mp_mont_sqr(int32_t * a1, int32_t result, int32_t a3);
int32_t pm8x41_gpio_config(int32_t a1, int32_t * a2, int32_t a3);
int32_t pm8x41_set_boot_done(int32_t a1);
int32_t pmic_set_chg_set_mode(char a1, int32_t a2, int32_t a3);
int32_t qtimer_irq(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t SecGetSVNum(uint32_t a1, int32_t a2);
int32_t set_logo(char a1, int32_t a2, int32_t a3);
int32_t sod_update(char * a1, int32_t a2, int32_t a3);
int32_t target_set_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t udc_start(int32_t a1, int32_t a2);
int32_t udc_stop(int32_t a1, int32_t a2);
int32_t wait_clogo(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g16 = 0; // LR
int32_t g17 = 0; // R0
int32_t g18 = 0; // R1
int32_t g19 = 0; // R10
int32_t g20 = 0; // R2
int32_t g21 = 0; // R3
int32_t g22 = 0; // R4
int32_t g23 = 0; // R5
int32_t g24 = 0; // R6
int32_t g25 = 0; // R7
int32_t g26 = 0; // R8
int32_t g27 = 0; // R9
int32_t g1 = -0x16d2bf10; // 0x8f60569c
int32_t g2 = -1; // 0x8f6ac0e0
int32_t g3 = 1; // 0x8f6ac0f0
char * g4 = "\x01"; // 0x8f6afe10
int32_t g5 = 0; // 0x8f6b792c
char * g6; // 0x8f6b794c
int32_t g7 = 0; // 0x8f6b8abc
int32_t g8 = 0; // 0x8f6b8ac0
int32_t g9 = 0; // 0x8f6b8ac4
int32_t (*g10)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t) = NULL; // 0x8f6b8ac8
int32_t g11 = 0; // 0x8f6b8acc
int32_t g12 = 0; // 0x8f6e08b8
char * g13; // 0x8f6e08f9
char * g14; // 0x8f6e0b60
int32_t g15 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f671fd8 - 0x8f672317
int32_t mot_sst_validate_hash_password(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = g23; // 0x8f671fd8
    int32_t v3 = g25; // 0x8f671fd8
    int32_t v4 = 20; // R8
    g25 = 16;
    int32_t size = 20;
    int32_t v5 = g15;
    int32_t v6 = 16; // bp-65
    if (a2 == NULL) {
        // 0x8f6722c0
        // branch -> 0x8f6722c4
        // 0x8f6722c4
        if (v5 != g15) {
            // 0x8f6722d4
            __stack_chk_fail();
            // branch -> 0x8f6722d8
        }
        // 0x8f6722d8
        g23 = v2;
        g25 = v3;
        return 255;
    }
    // 0x8f672008
    int32_t v7;
    mot_sst_pal_get_processor_uid((int32_t)&v7, v1, g20, v5);
    char * mem = malloc(36); // 0x8f672014
    int32_t v8 = (int32_t)mem; // 0x8f672014_3
    g23 = v8;
    int32_t v9;
    if (mem == NULL) {
        // 0x8f672020
        print_log(1, (int32_t)"%s: temp buffer malloc failure!\n", (int32_t)"mot_sst_validate_hash_password", v5, v9, 0, 0, 0, size, v7, 0, 0, 0);
        *(char *)v1 = 1;
        // branch -> 0x8f6722c0
    } else {
        char * mem2 = malloc(v8 & -0x10000 | 2630); // 0x8f672040
        int32_t v10 = (int32_t)mem2; // R4
        if (mem2 != NULL) {
            // 0x8f672064
            memcpy((char *)g23, (char *)&v7, g25);
            char * mem3 = malloc(size); // 0x8f672078
            g25 = (int32_t)mem3;
            int32_t * v11;
            if (mem3 == NULL) {
                // 0x8f672084
                print_log(1, (int32_t)"%s: hash_ptr malloc failure!\n", (int32_t)"mot_sst_validate_hash_password", v5, v9, 0, 0, 0, size, v7, 0, 0, 0);
                *(char *)v1 = 1;
                free((char *)v10);
                v11 = &g23;
                // branch -> 0x8f672258
            } else {
                int32_t v12 = v4; // 0x8f6720b4
                int32_t v13 = &size; // 0x8f6720bc_0
                size = v12;
                int32_t v14;
                if (dbval_calc_hash(a1, v12, g23 + 16, v13, v9, 0, 0, 0, v12, v7, 0, 0, 0, v5, v14) == 15) {
                    int32_t v15 = g25; // 0x8f6720e0
                    int32_t v16 = v4; // 0x8f6720e8
                    size = v16;
                    if (dbval_calc_hash(g23, 36, v15, v13, v9, 0, 0, 0, v16, v7, 0, 0, 0, v5, v14) != 15) {
                        // 0x8f6720f8
                        // branch -> 0x8f672100
                        // 0x8f672100
                        print_log(1, (int32_t)"%s: hash calculation failure!\n", (int32_t)"mot_sst_validate_hash_password", v13, v9, 0, 0, 0, size, v7, 0, 0, 0);
                        // branch -> 0x8f672240
                        // 0x8f672240
                        *(char *)v1 = 2;
                        free((char *)v10);
                        free((char *)g23);
                        // branch -> 0x8f672258
                        // 0x8f672258
                        free((char *)g25);
                        // branch -> 0x8f6722c0
                        // 0x8f6722c0
                        // branch -> 0x8f6722c4
                        // 0x8f6722c4
                        if (v5 != g15) {
                            // 0x8f6722d4
                            __stack_chk_fail();
                            // branch -> 0x8f6722d8
                        }
                        // 0x8f6722d8
                        g23 = v2;
                        g25 = v3;
                        return 255;
                    }
                    // 0x8f672110
                    if (dbval_read_partition(v10, 2630, v15, v13, v9, 0, 0, 0, size, v7, 0) == 0) {
                        // 0x8f672124
                        print_log(1, (int32_t)"read datablock error: %x\n", 255, v13, v9, 0, 0, 0, size, v7, 0, 0, 0);
                        // branch -> 0x8f672240
                        // 0x8f672240
                        *(char *)v1 = 3;
                        free((char *)v10);
                        free((char *)g23);
                        // branch -> 0x8f672258
                        // 0x8f672258
                        free((char *)g25);
                        // branch -> 0x8f6722c0
                        // 0x8f6722c0
                        // branch -> 0x8f6722c4
                        // 0x8f6722c4
                        if (v5 != g15) {
                            // 0x8f6722d4
                            __stack_chk_fail();
                            // branch -> 0x8f6722d8
                        }
                        // 0x8f6722d8
                        g23 = v2;
                        g25 = v3;
                        return 255;
                    }
                    char v17 = *(char *)(v10 + 2); // 0x8f67213c
                    int32_t v18 = v17; // 0x8f67213c
                    int32_t v19; // 0x8f672180
                    int32_t v20; // 0x8f6721b8
                    int32_t v21; // 0x8f6721f0
                    int32_t v22; // 0x8f6721dc
                    int32_t v23; // 0x8f6721e4
                    int32_t v24; // 0x8f672220
                    int32_t v25; // 0x8f6721e0
                    int32_t v26; // 0x8f6721ac
                    char v27; // 0x8f67221c
                    int32_t v28; // 0x8f67221c
                    if (v17 == 0) {
                        char v29 = *(char *)(v10 + 3); // 0x8f672148
                        if (v29 == 1) {
                            // 0x8f672154
                            v4 = 54;
                            print_log((int32_t)v29, (int32_t)"cid_get_cid_data: Version 1 datablock\n", v15, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                            // branch -> 0x8f672174
                            // 0x8f672174
                            v19 = dbval_db_validate_gen_hdr(v10, 240, (int32_t)&v6, v18, v9, 0, 0, 0, size, v7, 0, 0, 0, v5);
                            if (v19 != 15) {
                                // 0x8f67218c
                                print_log(1, (int32_t)"validate header error: %x\n", 255, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                                // branch -> 0x8f672240
                                // 0x8f672240
                                *(char *)v1 = 4;
                                free((char *)v10);
                                free((char *)g23);
                                // branch -> 0x8f672258
                                // 0x8f672258
                                free((char *)g25);
                                // branch -> 0x8f6722c0
                                // 0x8f6722c0
                                // branch -> 0x8f6722c4
                                // 0x8f6722c4
                                if (v5 != g15) {
                                    // 0x8f6722d4
                                    __stack_chk_fail();
                                    // branch -> 0x8f6722d8
                                }
                                // 0x8f6722d8
                                g23 = v2;
                                g25 = v3;
                                return 255;
                            }
                            // 0x8f6721a4
                            v26 = v4 + 172 + v10;
                            v20 = dbval_validate_cert_chain(v26, 0, 0, v18, v9, 0, 0, 0, size, v7, 0, 0, 0, v5, v14, g22, v2);
                            if (v20 != 15) {
                                // 0x8f6721c4
                                print_log(1, (int32_t)"validate cert chain error: %x\n", 255, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                                // branch -> 0x8f672240
                                // 0x8f672240
                                *(char *)v1 = 5;
                                free((char *)v10);
                                free((char *)g23);
                                // branch -> 0x8f672258
                                // 0x8f672258
                                free((char *)g25);
                                // branch -> 0x8f6722c0
                                // 0x8f6722c0
                                // branch -> 0x8f6722c4
                                // 0x8f6722c4
                                if (v5 != g15) {
                                    // 0x8f6722d4
                                    __stack_chk_fail();
                                    // branch -> 0x8f6722d8
                                }
                                // 0x8f6722d8
                                g23 = v2;
                                g25 = v3;
                                return 255;
                            }
                            // 0x8f6721dc
                            v22 = v4 + 44;
                            v25 = v26;
                            v23 = v10;
                            v21 = dbval_validate_signature(v23, v22, v23 + v22, 128, v25, 0, 0, 0, size, v7, 0, 0, 0, v5, v14, g22, v2, g24, v3, g26, g27, g19);
                            if (v21 != 15) {
                                // 0x8f6721fc
                                print_log(1, (int32_t)"validate signature error: %x\n", 255, 128, v25, 0, 0, 0, size, v7, 0, 0, 0);
                                // branch -> 0x8f672240
                                // 0x8f672240
                                *(char *)v1 = 6;
                                free((char *)v10);
                                free((char *)g23);
                                // branch -> 0x8f672258
                                // 0x8f672258
                                free((char *)g25);
                                // branch -> 0x8f6722c0
                                // 0x8f6722c0
                                // branch -> 0x8f6722c4
                                // 0x8f6722c4
                                if (v5 != g15) {
                                    // 0x8f6722d4
                                    __stack_chk_fail();
                                    // branch -> 0x8f6722d8
                                }
                                // 0x8f6722d8
                                g23 = v2;
                                g25 = v3;
                                return 255;
                            }
                            int32_t v30 = v10 + 77; // 0x8f672220
                            // branch -> 0x8f67221c
                            for (uint32_t i = 0; i < 20; i++) {
                                // 0x8f67221c
                                v27 = *(char *)(i + g25);
                                v28 = v27;
                                v24 = v30 + 1;
                                if (*(char *)v24 == v27) {
                                  lab_0x8f672260:
                                    // 0x8f672260
                                    v4 = i + 1;
                                    // PHI copies at the loop end
                                    v30 = v24;
                                    // loop 0x8f67221c end
                                    continue;
                                } else {
                                    // 0x8f67222c
                                    print_log(1, (int32_t)"hash at offset i: %02d : %02x does not match\n", i, v28, v25, 0, 0, 0, size, v7, 0, 0, 0);
                                    // branch -> 0x8f672240
                                    // 0x8f672240
                                    *(char *)v1 = 7;
                                    free((char *)v10);
                                    free((char *)g23);
                                    // branch -> 0x8f672258
                                    // 0x8f672258
                                    free((char *)g25);
                                    // branch -> 0x8f6722c0
                                    // 0x8f6722c0
                                    // branch -> 0x8f6722c4
                                }
                                // 0x8f6722c4
                                if (v5 != g15) {
                                    // 0x8f6722d4
                                    __stack_chk_fail();
                                    // branch -> 0x8f6722d8
                                }
                                // 0x8f6722d8
                                g23 = v2;
                                g25 = v3;
                                return 255;
                            }
                            // 0x8f67226c
                            dbval_memset(g23, 0, 16, v28);
                            free((char *)g23);
                            dbval_memset(g25, 0, v4, v28);
                            free((char *)g25);
                            dbval_memset(v10, 0, v4 & -0x10000 | 2630, v28);
                            free((char *)v10);
                            *(char *)v1 = 0;
                            // branch -> 0x8f6722c4
                            // 0x8f6722c4
                            if (v5 != g15) {
                                // 0x8f6722d4
                                __stack_chk_fail();
                                // branch -> 0x8f6722d8
                            }
                            // 0x8f6722d8
                            g23 = v2;
                            g25 = v3;
                            return 0;
                        }
                    }
                    // 0x8f672164
                    print_log(1, (int32_t)"cid_get_cid_data: Version 0 datablock\n", v15, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                    v4 = 0;
                    // branch -> 0x8f672174
                    // 0x8f672174
                    v19 = dbval_db_validate_gen_hdr(v10, 240, (int32_t)&v6, v18, v9, 0, 0, 0, size, v7, 0, 0, 0, v5);
                    if (v19 != 15) {
                        // 0x8f67218c
                        print_log(1, (int32_t)"validate header error: %x\n", 255, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                        // branch -> 0x8f672240
                        // 0x8f672240
                        *(char *)v1 = 4;
                        free((char *)v10);
                        free((char *)g23);
                        // branch -> 0x8f672258
                        // 0x8f672258
                        free((char *)g25);
                        // branch -> 0x8f6722c0
                        // 0x8f6722c0
                        // branch -> 0x8f6722c4
                        // 0x8f6722c4
                        if (v5 != g15) {
                            // 0x8f6722d4
                            __stack_chk_fail();
                            // branch -> 0x8f6722d8
                        }
                        // 0x8f6722d8
                        g23 = v2;
                        g25 = v3;
                        return 255;
                    }
                    // 0x8f6721a4
                    v26 = v4 + 172 + v10;
                    v20 = dbval_validate_cert_chain(v26, 0, 0, v18, v9, 0, 0, 0, size, v7, 0, 0, 0, v5, v14, g22, v2);
                    if (v20 != 15) {
                        // 0x8f6721c4
                        print_log(1, (int32_t)"validate cert chain error: %x\n", 255, v18, v9, 0, 0, 0, size, v7, 0, 0, 0);
                        // branch -> 0x8f672240
                        // 0x8f672240
                        *(char *)v1 = 5;
                        free((char *)v10);
                        free((char *)g23);
                        // branch -> 0x8f672258
                        // 0x8f672258
                        free((char *)g25);
                        // branch -> 0x8f6722c0
                        // 0x8f6722c0
                        // branch -> 0x8f6722c4
                        // 0x8f6722c4
                        if (v5 != g15) {
                            // 0x8f6722d4
                            __stack_chk_fail();
                            // branch -> 0x8f6722d8
                        }
                        // 0x8f6722d8
                        g23 = v2;
                        g25 = v3;
                        return 255;
                    }
                    // 0x8f6721dc
                    v22 = v4 + 44;
                    v25 = v26;
                    v23 = v10;
                    v21 = dbval_validate_signature(v23, v22, v23 + v22, 128, v25, 0, 0, 0, size, v7, 0, 0, 0, v5, v14, g22, v2, g24, v3, g26, g27, g19);
                    char v31;
                    if (v21 == 15) {
                        int32_t v32 = g25;
                        // branch -> 0x8f67221c
                        for (uint32_t i = 0; i < 20; i++) {
                            // 0x8f67221c
                            v27 = *(char *)(i + v32);
                            v28 = v27;
                            v24 = 78 + v10;
                            if (*(char *)v24 == v27) {
                                goto lab_0x8f672260;
                            }
                            // 0x8f67222c
                            print_log(1, (int32_t)"hash at offset i: %02d : %02x does not match\n", i, v28, v25, 0, 0, 0, size, v7, 0, 0, 0);
                            v31 = 7;
                            // branch -> 0x8f672240
                        }
                    } else {
                        // 0x8f6721fc
                        print_log(1, (int32_t)"validate signature error: %x\n", 255, 128, v25, 0, 0, 0, size, v7, 0, 0, 0);
                        v31 = 6;
                        // branch -> 0x8f672240
                    }
                    // 0x8f672240
                    *(char *)v1 = v31;
                    free((char *)v10);
                    free((char *)g23);
                    // branch -> 0x8f672258
                    // 0x8f672258
                    free((char *)g25);
                    // branch -> 0x8f6722c0
                    // 0x8f6722c0
                    // branch -> 0x8f6722c4
                    // 0x8f6722c4
                    if (v5 != g15) {
                        // 0x8f6722d4
                        __stack_chk_fail();
                        // branch -> 0x8f6722d8
                    }
                    // 0x8f6722d8
                    g23 = v2;
                    g25 = v3;
                    return 255;
                }
                // if_8f6720cc_0_true
                // branch -> 0x8f672100
                // 0x8f672100
                print_log(1, (int32_t)"%s: hash calculation faliure!\n", (int32_t)"mot_sst_validate_hash_password", v13, v9, 0, 0, 0, size, v7, 0, 0, 0);
                // branch -> 0x8f672240
                // 0x8f672240
                *(char *)v1 = 2;
                free((char *)v10);
                free((char *)g23);
                v11 = &g25;
                // branch -> 0x8f672258
            }
            // 0x8f672258
            free((char *)*v11);
            // branch -> 0x8f6722c0
            // 0x8f6722c0
            // branch -> 0x8f6722c4
            // 0x8f6722c4
            if (v5 != g15) {
                // 0x8f6722d4
                __stack_chk_fail();
                // branch -> 0x8f6722d8
            }
            // 0x8f6722d8
            g23 = v2;
            g25 = v3;
            return 255;
        }
        // 0x8f67204c
        print_log(1, (int32_t)"cid_get_cid_data: malloc failure\n", g20, v5, v9, 0, 0, 0, size, v7, 0, 0, 0);
        *(char *)v1 = 1;
        // branch -> 0x8f672258
        // 0x8f672258
        free((char *)g23);
        // branch -> 0x8f6722c0
    }
    // 0x8f6722c0
    // branch -> 0x8f6722c4
    // 0x8f6722c4
    if (v5 != g15) {
        // 0x8f6722d4
        __stack_chk_fail();
        // branch -> 0x8f6722d8
    }
    // 0x8f6722d8
    g23 = v2;
    g25 = v3;
    return 255;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// int isdigit(int c);
// int isxdigit(int c);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:31:19
