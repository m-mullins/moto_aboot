//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <regex.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int32_t doemit(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t dofwd(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t doinsert(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t dupl(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t enlarge(int32_t a1, int32_t a2);
void function_8f65db8c(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t lstep(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t nonnewline(int32_t * a1);
int32_t ordinary(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t othercase(int32_t c, int32_t a2, int32_t a3, int32_t a4);
int32_t p_b_symbol(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t p_bracket(int32_t * a1);
int32_t p_bre(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t p_ere(int32_t * a1, int32_t a2, uint32_t a3);
int32_t repeat(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t sslow(int32_t * a1, char * a2, int32_t a3, int32_t a4);
int32_t sstep(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);

// --------------------- Global Variables ---------------------

int32_t g7 = 0; // LR
int32_t g8 = 0; // R1
int32_t g9 = 0; // R10
int32_t g10 = 0; // R11
int32_t g11 = 0; // R12
int32_t g12 = 0; // R2
int32_t g13 = 0; // R3
int32_t g14 = 0; // R4
int32_t g15 = 0; // R5
int32_t g16 = 0; // R6
int32_t g17 = 0; // R7
int32_t g18 = 0; // R8
int32_t g19 = 0; // R9
bool g1 = false; // flagc
int32_t g2 = 0x65440030; // 0x8f69c66f
int32_t g3 = 0x746e6300; // 0x8f6a4e20
int32_t g4 = 0xa090807; // 0x8f6a4e27
char * g6; // 0x8f7112f4
char * g5[33] = {
    "alpha",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    (char *)&g3,
    "blank",
    " \t",
    (char *)&g3,
    "cntrl",
    (char *)&g4,
    (char *)&g3,
    "digit",
    "0123456789",
    (char *)&g3,
    "graph",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    (char *)&g3,
    "lower",
    "abcdefghijklmnopqrstuvwxyz",
    (char *)&g3,
    "print",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    (char *)&g3,
    "punct",
    "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
    (char *)&g3,
    "space",
    "\t\n\v\f\r ",
    (char *)&g3,
    "upper",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    (char *)&g3,
    "xdigit",
    "0123456789ABCDEFabcdef",
    (char *)&g3
}; // 0x8f6a4f6c

// ------------------------ Functions -------------------------

// Address range: 0x8f65c98c - 0x8f65cd03
int32_t repeat(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // R0
    int32_t v1 = g14; // 0x8f65c98c
    int32_t v2 = g15; // 0x8f65c98c
    int32_t v3 = g16; // 0x8f65c98c
    int32_t v4 = g17; // 0x8f65c98c
    int32_t v5 = g18; // 0x8f65c98c
    int32_t v6 = g19; // 0x8f65c98c
    int32_t v7 = g9; // 0x8f65c98c
    int32_t v8 = g10; // 0x8f65c98c
    int32_t v9 = g7; // 0x8f65c98c
    g18 = (int32_t)&g6;
    g16 = a4;
    g19 = v9;
    g14 = a1;
    g15 = a2;
    char * v10 = g6;
    int32_t v11 = (int32_t)v10;
    g17 = a3;
    // branch -> 0x8f65c9b8
    while (true) {
        // 0x8f65c9b8
        int32_t v12;
        int32_t v13 = v12; // 0x8f65c9e0
        if (a1 == 0) {
            // 0x8f65c9c0
            result = _panic(g19, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"lib/regex/regcomp.c", (int32_t)"p != ((void *)0)" & -0x10000 | 1141, (int32_t)"p != ((void *)0)", 0, 0);
            v13 = v12;
            // branch -> 0x8f65c9dc
        }
        // 0x8f65c9dc
        g9 = v13 + 1;
        if (v13 > 256) {
            // if_8f65c9e8_0_true
            *(int32_t *)(g14 + 8) = 12;
            // branch -> after_if_8f65c9e8_0
        }
        int32_t v14 = g14; // 0x8f65c9ec
        if (*(int32_t *)(v14 + 8) != 0) {
            // 0x8f65ccd0
            if (v10 != g6) {
                // 0x8f65cce0
                __stack_chk_fail();
                // branch -> 0x8f65cce4
            }
            // 0x8f65cce4
            g14 = v1;
            g15 = v2;
            g16 = v3;
            g17 = v4;
            g18 = v5;
            g19 = v6;
            g9 = v7;
            g10 = v8;
            return result;
        }
        int32_t v15 = g16; // 0x8f65c9f8
        int32_t v16 = g17; // 0x8f65c9f8
        int32_t v17 = v16 - v15; // 0x8f65c9f8
        g10 = *(int32_t *)(v14 + 20);
        int32_t v18 = v16; // 0x8f65cc7c
        if (v16 != v15 && !((v17 < 0 ^ ((v17 ^ v16) & (v16 ^ v15)) < 0))) {
            // 0x8f65ca04
            result = _panic(g19, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"lib/regex/regcomp.c", (int32_t)"from <= to" & -0x10000 | 1150, (int32_t)"from <= to", 0, 0);
            v18 = g17;
            // branch -> 0x8f65ca20
        }
        int32_t v19 = v18 - 1; // 0x8f65ca20
        int32_t v20; // 0x8f65ca38
        int32_t v21; // 0x8f65ca50
        if (v18 != 1 && !((v19 < 0 ^ (v18 & -v18) < 0))) {
            // 0x8f65ca2c
            if (v18 == 256) {
                // if_8f65ca34_0_true
                v21 = 24;
                // branch -> 0x8f65ca38
            } else {
                // after_if_8f65ca30_0
                v21 = 16;
                // branch -> 0x8f65ca38
            }
            // 0x8f65ca38
            v20 = g16;
            int32_t v22; // 0x8f65cc6c
            int32_t * v23; // 0x8f65cab0_0
            int32_t v24; // 0x8f65cbe8
            int32_t v25; // 0x8f65cc80
            int32_t v26; // 0x8f65cca0
            int32_t result2; // 0x8f65cccc
            int32_t v27;
            char * v28;
            char * v29;
            char * v30;
            int32_t v31; // 0x8f65cbec
            int32_t v32; // 0x8f65cac4
            int32_t v33; // 0x8f65caf8
            int32_t v34; // 0x8f65cb0c
            int32_t v35; // 0x8f65cb30
            int32_t v36; // 0x8f65cb64
            int32_t v37; // 0x8f65cb80
            int32_t v38; // 0x8f65cb94
            int32_t v39; // 0x8f65cbb8
            int32_t v40; // 0x8f65cc28
            int32_t v41; // 0x8f65cc50
            int32_t v42; // 0x8f65ca50
            int32_t v43; // 0x8f65cad0
            int32_t v44; // 0x8f65cae0
            int32_t v45; // 0x8f65cb14
            int32_t v46; // 0x8f65cb68
            int32_t v47; // 0x8f65cb98
            int32_t v48; // 0x8f65cc34
            int32_t v49; // 0x8f65ccbc
            int32_t v50; // 0x8f65cc28
            int32_t v51; // 0x8f65cab8
            if (v20 == 1 || v20 < 1 ^ (v20 & -v20) < 0) {
              lab_after_if_8f65ca3c_0_dec_label_pc_8f65ca50_crit_edge:
                // after_if_8f65ca3c_0.dec_label_pc_8f65ca50_crit_edge
                // branch -> 0x8f65ca50
                // 0x8f65ca50
                switch (v21 + v42) {
                    default: {
                        // 0x8f65ccac
                        v30 = g6;
                        if (v10 == v30) {
                            // 0x8f65ccbc
                            v49 = g14;
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            g7 = v9;
                            result2 = seterr(v49, 15, v11, (int32_t)v30, v1, v2, v3, v4, v5, v6);
                            return result2;
                        }
                        break;
                    }
                    case 0: {
                        // 0x8f65cab0
                        v23 = (int32_t *)(g14 + 20);
                        v51 = g15 + *v23 - g10;
                        g11 = v51;
                        *v23 = v51;
                        // branch -> 0x8f65ccd0
                        // 0x8f65ccd0
                        if (v10 == g6) {
                            // 0x8f65cce4
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            return result;
                        }
                        break;
                    }
                    case 1: {
                        // 0x8f65cac4
                        v32 = g14;
                        v43 = g15;
                        doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                        v44 = g16;
                        repeat(g14, g15 + 1, 1, v44);
                        v33 = g14;
                        doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                        v34 = g14;
                        v45 = g15;
                        dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                        doemit(g14, -0x78000000, 0, v44);
                        v35 = g14;
                        result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                        v28 = g6;
                        if (v10 == v28) {
                            // if_8f65cb50_0_true
                            v22 = g14;
                            // branch -> 0x8f65cc64
                            // 0x8f65cc64
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            g7 = v9;
                            return doemit(v22, -0x70000000, 2, (int32_t)v28);
                        }
                        break;
                    }
                    case 2: {
                        // 0x8f65cac4
                        v32 = g14;
                        v43 = g15;
                        doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                        v44 = g16;
                        repeat(g14, g15 + 1, 1, v44);
                        v33 = g14;
                        doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                        v34 = g14;
                        v45 = g15;
                        dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                        doemit(g14, -0x78000000, 0, v44);
                        v35 = g14;
                        result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                        v28 = g6;
                        if (v10 == v28) {
                            // if_8f65cb50_0_true
                            v22 = g14;
                            // branch -> 0x8f65cc64
                            // 0x8f65cc64
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            g7 = v9;
                            return doemit(v22, -0x70000000, 2, (int32_t)v28);
                        }
                        break;
                    }
                    case 3: {
                        // 0x8f65cac4
                        v32 = g14;
                        v43 = g15;
                        doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                        v44 = g16;
                        repeat(g14, g15 + 1, 1, v44);
                        v33 = g14;
                        doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                        v34 = g14;
                        v45 = g15;
                        dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                        doemit(g14, -0x78000000, 0, v44);
                        v35 = g14;
                        result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                        v28 = g6;
                        if (v10 == v28) {
                            // if_8f65cb50_0_true
                            v22 = g14;
                            // branch -> 0x8f65cc64
                            // 0x8f65cc64
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            g7 = v9;
                            return doemit(v22, -0x70000000, 2, (int32_t)v28);
                        }
                        break;
                    }
                    case 9: {
                        // 0x8f65ccd0
                        if (v10 == g6) {
                            // 0x8f65cce4
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            return result;
                        }
                        break;
                    }
                    case 10: {
                        // 0x8f65cb64
                        v36 = g14;
                        v46 = g15;
                        doinsert(v36, 0x78000000, *(int32_t *)(v36 + 20) + 1 - v46, v46);
                        v37 = g14;
                        doemit(v37, -0x80000000, *(int32_t *)(v37 + 20) - g15, g13);
                        v38 = g14;
                        v47 = g15;
                        dofwd(v38, v47, *(int32_t *)(v38 + 20) - v47, g13);
                        doemit(g14, -0x78000000, 0, g13);
                        v39 = g14;
                        dofwd(v39, *(int32_t *)(v39 + 20) - 1, 1, g13);
                        doemit(g14, -0x70000000, 2, g13);
                        v24 = dupl(g14, g15 + 1, g10 + 1, g13);
                        result = v24;
                        v31 = g10 + 4;
                        g11 = v31;
                        g15 = v24;
                        if (v24 == v31) {
                            goto lab_0x8f65cc18;
                        }
                        goto lab_0x8f65cbfc;
                    }
                    case 11: {
                        // 0x8f65cc28
                        v40 = g14;
                        v50 = *(int32_t *)(v40 + 20);
                        v48 = g15;
                        result = doinsert(v40, 0x48000000, v50 + 1 - v48, v48);
                        v29 = g6;
                        if (v10 == v29) {
                            // if_8f65cc50_0_true
                            v41 = g14;
                            v27 = *(int32_t *)(v41 + 20) - g15;
                            // branch -> 0x8f65cc64
                            // 0x8f65cc64
                            g14 = v1;
                            g15 = v2;
                            g16 = v3;
                            g17 = v4;
                            g18 = v5;
                            g19 = v6;
                            g9 = v7;
                            g10 = v8;
                            g7 = v9;
                            return doemit(v41, 0x50000000, v27, (int32_t)v29);
                        }
                        break;
                    }
                    case 18: {
                        // 0x8f65cc70
                        g17 = v19;
                        v25 = dupl(g14, g15, g10, 18);
                        result = v25;
                        g16--;
                        g15 = v25;
                        // branch -> 0x8f65cc20
                        goto lab_0x8f65cc20_4;
                    }
                    case 19: {
                        // 0x8f65cc90
                        g17 = v19;
                        v26 = dupl(g14, g15, g10, 19);
                        result = v26;
                        g15 = v26;
                        // branch -> 0x8f65cc20
                        goto lab_0x8f65cc20_4;
                    }
                }
                // 0x8f65cce0
                __stack_chk_fail();
                // branch -> 0x8f65cce4
                // 0x8f65cce4
                g14 = v1;
                g15 = v2;
                g16 = v3;
                g17 = v4;
                g18 = v5;
                g19 = v6;
                g9 = v7;
                g10 = v8;
                return result;
            }
          lab_0x8f65ca44:
            // 0x8f65ca44
            if (v20 == 256) {
                // if_8f65ca4c_0_true
                v42 = 3;
                // branch -> 0x8f65ca50
            } else {
                // after_if_8f65ca48_0
                v42 = 2;
                // branch -> 0x8f65ca50
            }
            // 0x8f65ca50
            switch (v21 + v42) {
                default: {
                    // 0x8f65ccac
                    v30 = g6;
                    if (v10 == v30) {
                        // 0x8f65ccbc
                        v49 = g14;
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        g7 = v9;
                        result2 = seterr(v49, 15, v11, (int32_t)v30, v1, v2, v3, v4, v5, v6);
                        return result2;
                    }
                    break;
                }
                case 0: {
                    // 0x8f65cab0
                    v23 = (int32_t *)(g14 + 20);
                    v51 = g15 + *v23 - g10;
                    g11 = v51;
                    *v23 = v51;
                    // branch -> 0x8f65ccd0
                    // 0x8f65ccd0
                    if (v10 == g6) {
                        // 0x8f65cce4
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        return result;
                    }
                    break;
                }
                case 1: {
                    // 0x8f65cac4
                    v32 = g14;
                    v43 = g15;
                    doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                    v44 = g16;
                    repeat(g14, g15 + 1, 1, v44);
                    v33 = g14;
                    doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                    v34 = g14;
                    v45 = g15;
                    dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                    doemit(g14, -0x78000000, 0, v44);
                    v35 = g14;
                    result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                    v28 = g6;
                    if (v10 == v28) {
                        // if_8f65cb50_0_true
                        v22 = g14;
                        // branch -> 0x8f65cc64
                        // 0x8f65cc64
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        g7 = v9;
                        return doemit(v22, -0x70000000, 2, (int32_t)v28);
                    }
                    break;
                }
                case 2: {
                    // 0x8f65cac4
                    v32 = g14;
                    v43 = g15;
                    doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                    v44 = g16;
                    repeat(g14, g15 + 1, 1, v44);
                    v33 = g14;
                    doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                    v34 = g14;
                    v45 = g15;
                    dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                    doemit(g14, -0x78000000, 0, v44);
                    v35 = g14;
                    result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                    v28 = g6;
                    if (v10 == v28) {
                        // if_8f65cb50_0_true
                        v22 = g14;
                        // branch -> 0x8f65cc64
                        // 0x8f65cc64
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        g7 = v9;
                        return doemit(v22, -0x70000000, 2, (int32_t)v28);
                    }
                    break;
                }
                case 3: {
                    // 0x8f65cac4
                    v32 = g14;
                    v43 = g15;
                    doinsert(v32, 0x78000000, *(int32_t *)(v32 + 20) + 1 - v43, v43);
                    v44 = g16;
                    repeat(g14, g15 + 1, 1, v44);
                    v33 = g14;
                    doemit(v33, -0x80000000, *(int32_t *)(v33 + 20) - g15, v44);
                    v34 = g14;
                    v45 = g15;
                    dofwd(v34, v45, *(int32_t *)(v34 + 20) - v45, v44);
                    doemit(g14, -0x78000000, 0, v44);
                    v35 = g14;
                    result = dofwd(v35, *(int32_t *)(v35 + 20) - 1, 1, v44);
                    v28 = g6;
                    if (v10 == v28) {
                        // if_8f65cb50_0_true
                        v22 = g14;
                        // branch -> 0x8f65cc64
                        // 0x8f65cc64
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        g7 = v9;
                        return doemit(v22, -0x70000000, 2, (int32_t)v28);
                    }
                    break;
                }
                case 9: {
                    // 0x8f65ccd0
                    if (v10 == g6) {
                        // 0x8f65cce4
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        return result;
                    }
                    break;
                }
                case 10: {
                    // 0x8f65cb64
                    v36 = g14;
                    v46 = g15;
                    doinsert(v36, 0x78000000, *(int32_t *)(v36 + 20) + 1 - v46, v46);
                    v37 = g14;
                    doemit(v37, -0x80000000, *(int32_t *)(v37 + 20) - g15, g13);
                    v38 = g14;
                    v47 = g15;
                    dofwd(v38, v47, *(int32_t *)(v38 + 20) - v47, g13);
                    doemit(g14, -0x78000000, 0, g13);
                    v39 = g14;
                    dofwd(v39, *(int32_t *)(v39 + 20) - 1, 1, g13);
                    doemit(g14, -0x70000000, 2, g13);
                    v24 = dupl(g14, g15 + 1, g10 + 1, g13);
                    result = v24;
                    v31 = g10 + 4;
                    g11 = v31;
                    g15 = v24;
                    if (v24 != v31) {
                      lab_0x8f65cbfc:
                        // 0x8f65cbfc
                        result = _panic(g19, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"lib/regex/regcomp.c", (int32_t)"copy == finish+4" & -0x10000 | 1180, (int32_t)"copy == finish+4", 0, 0);
                        // branch -> 0x8f65cc18
                    }
                  lab_0x8f65cc18:
                    // 0x8f65cc18
                    g16--;
                    g17 = 1;
                    // branch -> 0x8f65cc20
                  lab_0x8f65cc20_4:
                    // 0x8f65cc20
                    v12 = g9;
                    a1 = g14;
                    // branch -> 0x8f65c9b8
                    continue;
                }
                case 11: {
                    // 0x8f65cc28
                    v40 = g14;
                    v50 = *(int32_t *)(v40 + 20);
                    v48 = g15;
                    result = doinsert(v40, 0x48000000, v50 + 1 - v48, v48);
                    v29 = g6;
                    if (v10 == v29) {
                        // if_8f65cc50_0_true
                        v41 = g14;
                        v27 = *(int32_t *)(v41 + 20) - g15;
                        // branch -> 0x8f65cc64
                        // 0x8f65cc64
                        g14 = v1;
                        g15 = v2;
                        g16 = v3;
                        g17 = v4;
                        g18 = v5;
                        g19 = v6;
                        g9 = v7;
                        g10 = v8;
                        g7 = v9;
                        return doemit(v41, 0x50000000, v27, (int32_t)v29);
                    }
                    break;
                }
                case 18: {
                    // 0x8f65cc70
                    g17 = v19;
                    v25 = dupl(g14, g15, g10, 18);
                    result = v25;
                    g16--;
                    g15 = v25;
                    // branch -> 0x8f65cc20
                    goto lab_0x8f65cc20_4;
                    break;
                }
                case 19: {
                    // 0x8f65cc90
                    g17 = v19;
                    v26 = dupl(g14, g15, g10, 19);
                    result = v26;
                    g15 = v26;
                    // branch -> 0x8f65cc20
                    goto lab_0x8f65cc20_4;
                    break;
                }
            }
            // 0x8f65cce0
            __stack_chk_fail();
            // branch -> 0x8f65cce4
            // 0x8f65cce4
            g14 = v1;
            g15 = v2;
            g16 = v3;
            g17 = v4;
            g18 = v5;
            g19 = v6;
            g9 = v7;
            g10 = v8;
            return result;
        }
        // after_if_8f65ca24_0.thread
        v21 = 8 * v18;
        // branch -> 0x8f65ca38
        // 0x8f65ca38
        v20 = g16;
        if (v20 == 1 || v20 < 1 ^ (v20 & -v20) < 0) {
            goto lab_after_if_8f65ca3c_0_dec_label_pc_8f65ca50_crit_edge;
        }
        goto lab_0x8f65ca44;
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// int isalnum(int c);
// int isalpha(int c);
// int isdigit(int c);
// int islower(int c);
// int isupper(int c);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// void * realloc(void * ptr, size_t size);
// void regfree(regex_t * preg);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// int tolower(int c);
// int toupper(int c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 17
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:51:08
