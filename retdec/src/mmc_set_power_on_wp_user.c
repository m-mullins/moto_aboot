//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t _fdt_check_prop_offset(int32_t a1);
int32_t add_panel_to_manager(int32_t * a1, int32_t a2, int32_t a3);
int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t arm_mmu_init(int32_t a1);
int32_t board_machtype(int32_t a1, int32_t a2, int32_t a3);
int32_t display_draw_screen_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t display_draw_screen_line_alignment(int32_t a1);
int32_t factory_mode(int32_t a1, int32_t a2, int32_t a3);
void function_8f67b680(void);
int32_t is_factory_mode(void);
int32_t is_validation_enabled(char * a1, int32_t a2);
int32_t load_and_validate_logo(void);
int32_t load_and_validate_oem_image(void);
int32_t mipi_mot_panel_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_panel_on(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_enable_enhanced_erase(void);
int32_t mmc_sdhci_enable_enhanced_erase(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_sdhci_get_wp_group_size(void);
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data(char * a1, char * a2);
int32_t mot_sst_oem_unlock_handler(void);
int32_t panel_manager_init(int32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_config_s3_source(uint32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_resin_status(int32_t a1, int32_t a2);
int32_t target_serialno(char * a1, int32_t a2);
int32_t validate_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t wait_queue_block(int32_t a1, int32_t a2);
int32_t wait_queue_init(int32_t * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R10
int32_t g23 = 0; // R11
int32_t g24 = 0; // R2
int32_t g25 = 0; // R3
int32_t g26 = 0; // R4
int32_t g27 = 0; // R5
int32_t g28 = 0; // R6
int32_t g29 = 0; // R7
int32_t g30 = 0; // R8
int32_t g31 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f61bf74
char * g2 = "\xff\xff\xff\xff\x6c\x6f\x61\x64\x5f\x61\x6e\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x65\x5f\x6b\x65\x72\x6e\x65\x6c\x5f\x69\x6d\x61\x67\x65"; // 0x8f6826be
char * g3 = "\n"; // 0x8f6ac1b0
int32_t g4 = 4; // 0x8f6acacc
int32_t g5 = 4; // 0x8f6acb18
int32_t g6 = 4; // 0x8f6acb30
int32_t g7 = -1; // 0x8f6affb0
int32_t g8 = 102; // 0x8f6affdc
int32_t g9 = 1; // 0x8f6b0044
char * g10; // 0x8f6b0070
int32_t g11 = 0; // 0x8f6bc000
char * g12; // 0x8f6e06ae
int32_t g13 = 0; // 0x8f6e06b4
int32_t g14 = 0; // 0x8f6e0c38
int32_t g15 = 0; // 0x8f7112f4
int32_t g16 = 0; // 0x8f7114ac
int32_t g17 = 0; // 0x8f711550
int32_t g18 = 0; // 0x8f711554

// ------------------------ Functions -------------------------

// Address range: 0x8f60b160 - 0x8f60b3ef
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3) {
    // 0x8f60b160
    int32_t v1;
    int32_t v2 = v1; // bp-116
    int32_t v3 = g26; // 0x8f60b160
    int32_t v4 = g31; // 0x8f60b160
    g27 = g25;
    int32_t v5 = (int32_t)a1; // R8
    g26 = a3;
    int32_t v6 = g15;
    int32_t v7;
    int32_t v8 = &v7; // 0x8f60b188_0
    memset((char *)&v7, 0, 64);
    g20 = v5;
    if (mmc_enable_enhanced_erase() == 0) {
        // 0x8f60b1a4
        if (mmc_enable_hw_reset(v5, 0, 64, v6) == 0) {
            int32_t v9 = v5 + 48; // 0x8f60b1b4
            int32_t v10 = 1; // R2
            int32_t v11 = 171; // R3
            int32_t v12;
            int32_t v13;
            int32_t v14;
            int32_t v15;
            if (mmc_switch_cmd((char *)v5, v9, 1, 171, 16, 0, v15, v14, 0, v1, v7, v13, 0, v12, 0, 0, 0, 0) == NULL) {
                int32_t v16 = v5 + 80; // 0x8f60b1e8
                if (mmc_get_ext_csd_isra_11((char *)v5, v16, v10, v11, 16, 0, v15, v14, 0, v1, v7, v13, 0, v12, 0) == 0) {
                    int32_t v17 = *(int32_t *)(v5 + 80); // 0x8f60b20c
                    int32_t v18 = (int32_t)*(char *)(v17 + 171); // 0x8f60b210
                    v10 = v18;
                    if ((v18 & 12) == 0) {
                        char v19 = *(char *)(v17 + 175); // 0x8f60b224
                        if (v19 == 0) {
                            // if_8f60b22c_0_true
                            // branch -> 0x8f60b330
                            // 0x8f60b330
                            print_log(-1, (int32_t)"Enhanced erase is not enabled\n", v10, (int32_t)v19, 16, 0, v15, v14, 0, v2, v7, v13, 0);
                            // branch -> 0x8f60b3a4
                            // 0x8f60b3a4
                            // branch -> 0x8f60b3a8
                            // 0x8f60b3a8
                            if (v6 != g15) {
                                // 0x8f60b3bc
                                __stack_chk_fail();
                                // branch -> 0x8f60b3c0
                            }
                            // 0x8f60b3c0
                            g26 = v3;
                            g31 = v4;
                            return;
                        }
                        int32_t v20 = mmc_get_wp_group_size(v5, v16); // 0x8f60b240
                        if (g27 == 0) {
                            // after_if_8f60b250_0
                            g31 = v20;
                            if (g26 < v20) {
                                // after_if_8f60b260_0
                                // branch -> 0x8f60b200
                                // 0x8f60b200
                                print_log(-1, (int32_t)"Length is less than min WP size, WP was not set\n", v20, 0, 16, 0, v20, 0, 0, v1, v7, v13, 0);
                                // branch -> 0x8f60b3a8
                                // 0x8f60b3a8
                                if (v6 != g15) {
                                    // 0x8f60b3bc
                                    __stack_chk_fail();
                                    // branch -> 0x8f60b3c0
                                }
                                // 0x8f60b3c0
                                g26 = v3;
                                g31 = v4;
                                return;
                            }
                        } else {
                            // after_if_8f60b250_0.thread
                            g31 = v20;
                            // branch -> 0x8f60b268
                        }
                        int32_t v21 = 1; // 0x8f60b268
                        char * v22 = mmc_switch_cmd((char *)v5, v9, v21, 171, v21, 0, v20, 0, 0, v1, v7, v13, 0, v12, 0, 0, 0, 0); // 0x8f60b27c
                        int32_t v23 = (int32_t)v22; // 0x8f60b27c_20
                        if (v22 != NULL) {
                            // 0x8f60b288
                            print_log(-1, (int32_t)"Failed to set power on WP for user\n", v21, 171, v21, 0, v20, 0, 0, v1, v7, v13, 0);
                            // branch -> 0x8f60b3a8
                            // 0x8f60b3a8
                            if (v6 != g15) {
                                // 0x8f60b3bc
                                __stack_chk_fail();
                                // branch -> 0x8f60b3c0
                            }
                            // 0x8f60b3c0
                            g26 = v3;
                            g31 = v4;
                            return;
                        }
                        int32_t v24 = g26; // 0x8f60b2a4
                        g26 = v23;
                        int32_t v25 = v23; // R5
                        v10 = v20;
                        int32_t v26 = __aeabi_uldivmod((int64_t)(g31 - 1 + v24 & -g31), (int64_t)v20); // 0x8f60b2c4
                        v7 = 28;
                        if (g26 < v26) {
                            // 0x8f60b39c
                            // branch -> 0x8f60b3a8
                        } else {
                            int32_t v27 = &v2; // 0x8f60b34c_0
                            int32_t v28 = v12 / 512 % 16; // 0x8f60b338
                            int32_t v29 = a2; // 0x8f60b30c
                            // branch -> 0x8f60b304
                            while (true) {
                                // 0x8f60b304
                                if (sdhci_send_command((char *)v5, v8, v10, 2, v21, 0, v20, 0, 0, v1, 28, v29, 0, v12, 0, 0, 0, 0) == 0) {
                                    // 0x8f60b31c
                                    if (v12 > -1) {
                                        // 0x8f60b2e8
                                        v2 = v12;
                                        int32_t v30; // 0x8f60b2f4
                                        if ((v12 & 256) == 0) {
                                            // 0x8f60b338
                                            v11 = v28;
                                            if (v28 != 7) {
                                                int32_t v31 = v12; // 0x8f60b350
                                                while (true) {
                                                    v10 = v27;
                                                    if (mmc_get_card_status_isra_3((char *)v5, v9, v27, v28, v21, 0, v20, 0, 0, v31, v7, v29, 0, v12) != NULL) {
                                                        // if_8f60b358_0_true
                                                        // branch -> 0x8f60b330
                                                        // 0x8f60b330
                                                        print_log(-1, (int32_t)"Failed to get card status afterapplying write protect\n", v10, v11, v21, 0, v20, 0, 0, v2, v7, v29, 0);
                                                        // branch -> 0x8f60b3a4
                                                        // 0x8f60b3a4
                                                        // branch -> 0x8f60b3a8
                                                        // 0x8f60b3a8
                                                        if (v6 != g15) {
                                                            // 0x8f60b3bc
                                                            __stack_chk_fail();
                                                            // branch -> 0x8f60b3c0
                                                        }
                                                        // 0x8f60b3c0
                                                        g26 = v3;
                                                        g31 = v4;
                                                        return;
                                                    }
                                                    int32_t v32 = v2; // 0x8f60b364
                                                    if ((v32 & 256) == 0) {
                                                        int32_t v33 = v32 / 512 % 16; // 0x8f60b370
                                                        v11 = v33;
                                                        if (v33 != 7) {
                                                            // 0x8f60b37c
                                                            v25++;
                                                            udelay(1000, v9, v10, v33);
                                                            if (v25 == (v23 & -0x10000 || 0x2710)) {
                                                                // 0x8f60b390
                                                                // branch -> 0x8f60b330
                                                                // 0x8f60b330
                                                                print_log(-1, (int32_t)"Card status timed out after sending write protect command\n", v10, v11, v21, 0, v20, 0, 0, v2, v7, v29, 0);
                                                                // branch -> 0x8f60b3a4
                                                                // 0x8f60b3a4
                                                                // branch -> 0x8f60b3a8
                                                                // 0x8f60b3a8
                                                                if (v6 != g15) {
                                                                    // 0x8f60b3bc
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x8f60b3c0
                                                                }
                                                                // 0x8f60b3c0
                                                                g26 = v3;
                                                                g31 = v4;
                                                                return;
                                                            }
                                                            // 0x8f60b37c
                                                            v31 = v2;
                                                            v28 = v11;
                                                            // branch -> 0x8f60b344
                                                            continue;
                                                        }
                                                    }
                                                    // 0x8f60b2f4
                                                    v30 = g26 + 1;
                                                    g26 = v30;
                                                    a2 += g31;
                                                    if (v30 < v26) {
                                                        // 0x8f60b39c
                                                        // branch -> 0x8f60b3a8
                                                    } else {
                                                      lab_0x8f60b2f4:
                                                        // 0x8f60b2f4
                                                        // branch -> 0x8f60b304
                                                        break;
                                                    }
                                                    // 0x8f60b3a8
                                                    if (v6 != g15) {
                                                        // 0x8f60b3bc
                                                        __stack_chk_fail();
                                                        // branch -> 0x8f60b3c0
                                                    }
                                                    // 0x8f60b3c0
                                                    g26 = v3;
                                                    g31 = v4;
                                                    return;
                                                }
                                            }
                                        }
                                        // 0x8f60b2f4
                                        v30 = g26 + 1;
                                        g26 = v30;
                                        a2 += g31;
                                        if (v30 >= v26) {
                                            goto lab_0x8f60b2f4;
                                        }
                                        // 0x8f60b39c
                                        // branch -> 0x8f60b3a8
                                    } else {
                                        // 0x8f60b328
                                        // branch -> 0x8f60b330
                                        // 0x8f60b330
                                        print_log(-1, (int32_t)"Address for CMD28/29 is out of range\n", v10, v12, v21, 0, v20, 0, 0, v2, v7, v29, 0);
                                        // branch -> 0x8f60b3a4
                                        // 0x8f60b3a4
                                        // branch -> 0x8f60b3a8
                                    }
                                    // 0x8f60b3a8
                                    if (v6 != g15) {
                                        // 0x8f60b3bc
                                        __stack_chk_fail();
                                        // branch -> 0x8f60b3c0
                                    }
                                    // 0x8f60b3c0
                                    g26 = v3;
                                    g31 = v4;
                                    return;
                                }
                                // 0x8f60b3a4
                                // branch -> 0x8f60b3a8
                            }
                        }
                        // 0x8f60b3a8
                        if (v6 != g15) {
                            // 0x8f60b3bc
                            __stack_chk_fail();
                            // branch -> 0x8f60b3c0
                        }
                        // 0x8f60b3c0
                        g26 = v3;
                        g31 = v4;
                        return;
                    }
                    // if_8f60b218_0_true
                    // branch -> 0x8f60b330
                    // 0x8f60b330
                    print_log(-1, (int32_t)"Power on protection is disabled, cannot be set\n", v10, v17, 16, 0, v15, v14, 0, v2, v7, v13, 0);
                    // branch -> 0x8f60b3a4
                    // 0x8f60b3a4
                    // branch -> 0x8f60b3a8
                } else {
                    // 0x8f60b1f8
                    // branch -> 0x8f60b200
                    // 0x8f60b200
                    print_log(-1, (int32_t)"Failed to read ext csd for the card\n", v10, v11, 16, 0, v15, v14, 0, v1, v7, v13, 0);
                    // branch -> 0x8f60b3a8
                }
                // 0x8f60b3a8
                if (v6 != g15) {
                    // 0x8f60b3bc
                    __stack_chk_fail();
                    // branch -> 0x8f60b3c0
                }
                // 0x8f60b3c0
                g26 = v3;
                g31 = v4;
                return;
            }
            // if_8f60b1d8_0_true
            // branch -> 0x8f60b200
            // 0x8f60b200
            print_log(-1, (int32_t)"Failed to Disable PERM WP\n", v10, v11, 16, 0, v15, v14, 0, v1, v7, v13, 0);
            // branch -> 0x8f60b3a8
        }
    }
    // 0x8f60b3a8
    if (v6 != g15) {
        // 0x8f60b3bc
        __stack_chk_fail();
        // branch -> 0x8f60b3c0
    }
    // 0x8f60b3c0
    g26 = v3;
    g31 = v4;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:56:15
