//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t smem_copy_ram_ptable(char * a1);
int32_t smem_ram_ptable_init_v1(void);

// --------------------- Global Variables ---------------------

int32_t g8 = 0; // R4
bool g9 = false; // R5
int32_t g1 = 0x65440030; // 0x8f69c66f
char * g2; // 0x8f6b50a8
int32_t g3 = 0; // 0x8f6b58c0
int32_t g4 = 0; // 0x8f6b58c4
int32_t g5 = 0; // 0x8f6b58c8
int32_t g6 = 0; // 0x8f6b58d0
int32_t g7 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f6045bc - 0x8f604893
int32_t smem_copy_ram_ptable(char * a1) {
    int32_t v1 = (int32_t)a1; // R4
    int32_t v2 = g7;
    char * dest_mem = memcpy((char *)&g2, a1, 20); // 0x8f6045ec
    int32_t v3 = (int32_t)dest_mem; // 0x8f6045ec_7
    int32_t result2 = v3; // R0
    char v4 = *(char *)(v3 + 9); // 0x8f6045f0
    int32_t v5 = v3; // R7
    char v6 = *(char *)(v3 + 8); // 0x8f6045f8
    char v7 = *(char *)(v3 + 10); // 0x8f604600
    char v8 = *(char *)(v3 + 11); // 0x8f604608
    int32_t v9 = 0x1000000 * (int32_t)v8 | 0x10000 * (int32_t)v7 | (int32_t)v6 | 256 * (int32_t)v4; // 0x8f60460c
    switch (v9) {
        default: {
            int32_t v10 = g9 ? (int32_t)&g7 : 0; // 0x8f6045bc
            int32_t v11;
            print_log(-1, (int32_t)"ERROR: Unknown smem ram ptable version: %u", v9, (int32_t)&g2, v11, 0, 0, 0, 0, v2, 0, g8, v10);
            int32_t result = _panic(0, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/smem_ptable.c", 189, (int32_t)&g1, 0, 0); // 0x8f60485c
            // branch -> 0x8f604860
            // 0x8f604860
            if (v2 != g7) {
                // 0x8f604870
                __stack_chk_fail();
                // branch -> 0x8f604874
            }
            // 0x8f604874
            return result;
        }
        case 1: {
            // 0x8f604618
            if (v2 == g7) {
                // 0x8f604628
                return (int32_t)memcpy(dest_mem, (char *)v1, v2 & -0x10000 | 2072);
            }
            // 0x8f604870
            __stack_chk_fail();
            // branch -> 0x8f604874
            // 0x8f604874
            return result2;
        }
        case 0: {
            char v12 = *(char *)(v1 + 17); // 0x8f604644
            bool v13 = true; // R8
            char v14 = *(char *)(v1 + 16); // 0x8f60464c
            char v15 = *(char *)(v1 + 18); // 0x8f604654
            char v16 = *(char *)(v1 + 19); // 0x8f60465c
            int32_t v17 = 0x1000000 * (int32_t)v16 | 0x10000 * (int32_t)v15 | (int32_t)v14 | 256 * (int32_t)v12; // 0x8f604660
            int32_t v18 = 0; // R3
            if (v17 != 0) {
                char v19 = 0;
                bool v20 = true;
                int32_t v21 = 0; // 0x8f604678
                while (true) {
                    int32_t v22 = (v20 ? 56 : 0) * v21 + v1; // 0x8f604670
                    int32_t v23 = 64 * v21 + v3; // 0x8f604674
                    int32_t v24 = v23; // R1
                    int32_t v25 = v21 + 1; // R2
                    result2 = v22 + 48;
                    char v26 = *(char *)(v22 + 37); // 0x8f604680
                    char v27 = *(char *)(v22 + 36); // 0x8f604684
                    char v28 = *(char *)(v22 + 38); // 0x8f60468c
                    char v29 = *(char *)(v22 + 39); // 0x8f604694
                    *(char *)(v23 + 44) = v19;
                    *(char *)(v24 + 45) = (char)v18;
                    int32_t v30 = 0x1000000 * (int32_t)v29 | 0x10000 * (int32_t)v28 | (int32_t)v27 | 256 * (int32_t)v26; // R10
                    *(char *)(v24 + 46) = (char)v18;
                    *(char *)(v24 + 40) = (char)v30;
                    *(char *)(v24 + 47) = (char)v18;
                    *(char *)(v24 + 41) = (char)(v30 / 256);
                    uint32_t v31 = v30; // 0x8f6046b8
                    *(char *)(v24 + 42) = (char)(v31 / 0x10000);
                    *(char *)(v24 + 43) = (char)(v31 / 0x1000000);
                    int32_t v32 = result2; // 0x8f6046c8
                    char v33 = *(char *)(v32 - 7); // 0x8f6046c8
                    char v34 = *(char *)(v32 - 8); // 0x8f6046cc
                    char v35 = *(char *)(v32 - 5); // 0x8f6046d0
                    char v36 = *(char *)(v32 - 6); // 0x8f6046d8
                    *(char *)(v24 + 52) = (char)v18;
                    *(char *)(v24 + 53) = (char)v18;
                    *(char *)(v24 + 54) = (char)v18;
                    int32_t v37 = 0x1000000 * (int32_t)v35 | (int32_t)v34 | 256 * (int32_t)v33 | 0x10000 * (int32_t)v36; // R12
                    *(char *)(v24 + 55) = (char)v18;
                    *(char *)(v24 + 48) = (char)v37;
                    *(char *)(v24 + 49) = (char)(v37 / 256);
                    uint32_t v38 = v37; // 0x8f604700
                    *(char *)(v24 + 50) = (char)(v38 / 0x10000);
                    *(char *)(v24 + 51) = (char)(v38 / 0x1000000);
                    int32_t v39 = result2; // 0x8f604710
                    char v40 = *(char *)(v39 - 3); // 0x8f604710
                    char v41 = *(char *)(v39 - 4); // 0x8f604714
                    char v42 = *(char *)(v39 - 2); // 0x8f60471c
                    char v43 = *(char *)(v39 - 1); // 0x8f604724
                    v30 = 0x1000000 * (int32_t)v43 | 0x10000 * (int32_t)v42 | (int32_t)v41 | 256 * (int32_t)v40;
                    *(char *)(v24 + 56) = v41;
                    *(char *)(v24 + 57) = (char)(v30 / 256);
                    *(char *)(v24 + 58) = (char)(v30 / 0x10000);
                    *(char *)(v24 + 59) = (char)(v30 / 0x1000000);
                    int32_t v44 = result2; // 0x8f604748
                    char v45 = *(char *)(v44 + 1); // 0x8f604748
                    char v46 = *(char *)v44; // 0x8f60474c
                    char v47 = *(char *)(v44 + 3); // 0x8f604750
                    char v48 = *(char *)(v44 + 2); // 0x8f604758
                    v37 = 0x1000000 * (int32_t)v47 | (int32_t)v46 | 256 * (int32_t)v45 | 0x10000 * (int32_t)v48;
                    *(char *)(v24 + 60) = v46;
                    *(char *)(v24 + 61) = (char)(v37 / 256);
                    uint32_t v49 = v37; // 0x8f604770
                    *(char *)(v24 + 62) = (char)(v49 / 0x10000);
                    *(char *)(v24 + 63) = (char)(v49 / 0x1000000);
                    int32_t v50 = result2; // 0x8f604780
                    char v51 = *(char *)(v50 + 5); // 0x8f604780
                    char v52 = *(char *)(v50 + 4); // 0x8f604784
                    char v53 = *(char *)(v50 + 6); // 0x8f60478c
                    char v54 = *(char *)(v50 + 7); // 0x8f604794
                    int32_t v55 = 0x1000000 * (int32_t)v54 | 0x10000 * (int32_t)v53 | (int32_t)v52 | 256 * (int32_t)v51; // R6
                    int32_t v56 = v5 + 64 * v25; // 0x8f60479c
                    v37 = v56;
                    *(char *)v56 = v52;
                    *(char *)(v37 + 1) = (char)(v55 / 256);
                    uint32_t v57 = v55; // 0x8f6047ac
                    *(char *)(v37 + 2) = (char)(v57 / 0x10000);
                    *(char *)(v37 + 3) = (char)(v57 / 0x1000000);
                    int32_t v58 = result2; // 0x8f6047bc
                    char v59 = *(char *)(v58 + 9); // 0x8f6047bc
                    char v60 = *(char *)(v58 + 8); // 0x8f6047c0
                    char v61 = *(char *)(v58 + 10); // 0x8f6047c8
                    char v62 = *(char *)(v58 + 11); // 0x8f6047cc
                    result2 = 0x10000 * (int32_t)v61 | (int32_t)v60 | 256 * (int32_t)v59 | 0x1000000 * (int32_t)v62;
                    *(char *)(v37 + 4) = v60;
                    *(char *)(v37 + 5) = (char)(result2 / 256);
                    uint32_t v63 = result2; // 0x8f6047e4
                    *(char *)(v37 + 6) = (char)(v63 / 0x10000);
                    v55 = v24 + 72;
                    *(char *)(v37 + 7) = (char)(v63 / 0x1000000);
                    int32_t v64 = v1 + v25 * (v13 ? 56 : 0); // 0x8f6047f8
                    char v65 = *(char *)(v64 + 5); // 0x8f6047fc
                    char v66 = *(char *)(v64 + 4); // 0x8f604800
                    char v67 = *(char *)(v64 + 6); // 0x8f604808
                    char v68 = *(char *)(v64 + 7); // 0x8f60480c
                    result2 = 0x10000 * (int32_t)v67 | (int32_t)v66 | 256 * (int32_t)v65 | 0x1000000 * (int32_t)v68;
                    *(char *)(v24 + 72) = v66;
                    *(char *)(v55 + 1) = (char)(result2 / 256);
                    uint32_t v69 = result2; // 0x8f604824
                    *(char *)(v55 + 2) = (char)(v69 / 0x10000);
                    *(char *)(v55 + 3) = (char)(v69 / 0x1000000);
                    if (v25 != v17) {
                        // 0x8f604670
                        v19 = v18;
                        v3 = v5;
                        v20 = v13;
                        v21 = v25;
                        // branch -> 0x8f604670
                        continue;
                    }
                }
            }
            // 0x8f604860
            if (v2 != g7) {
                // 0x8f604870
                __stack_chk_fail();
                // branch -> 0x8f604874
            }
            // 0x8f604874
            return result2;
        }
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 2
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 05:55:53
