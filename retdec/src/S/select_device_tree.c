//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_107(char * a1, char * a2, int32_t a3, int32_t a4);
int32_t __utag_sizeof(char * a1, int32_t a2, int32_t a3);
int32_t _dputc(char a1, int32_t a2);
int32_t board_baseband(int32_t a1);
int32_t board_hardware_id(int32_t a1, int32_t a2, int32_t a3);
int32_t boot_linux(int32_t (*a1)(int32_t, int32_t, int32_t), int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t bs_set_timestamp(int32_t a1);
int32_t build_sig_for_all(char * str, int32_t (*a2)(int32_t, int32_t), int32_t a3);
int32_t build_sig_is_uniform(void);
int32_t dev_tree_add_mem_info(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t dev_tree_get_entry_info(int32_t a1, int32_t * a2);
int32_t disable_usbin_valid_irq(int32_t a1);
int32_t do_dead_battery_recovery(int32_t a1, int32_t a2, int32_t a3);
int32_t enable_usbin_valid_irq(int32_t a1, int32_t a2);
void function_8f64aa80(void);
void function_8f64aacc(int32_t a1, int32_t a2, int32_t a3);
void function_8f678528(void);
void function_8f6786f0(int32_t * timep, int32_t a2, int32_t a3);
int32_t get_udc_device(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t get_ui_coordinates(int32_t a1, int32_t a2);
int32_t init(int32_t a1, int32_t a2, int32_t a3);
int32_t is_fastboot_busy(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_phy_regulator_init(int32_t * a1, int32_t a2);
int32_t mdss_dsi_phy_sw_reset(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t on_confirm_timeout(int32_t a1, int32_t a2, char * a3);
int32_t select_device_tree(int32_t a1, int32_t a2);
int32_t start_charging(int32_t a1);
int32_t stop_charging(int32_t a1, int32_t a2);
int32_t target_platform_id(char * a1, int32_t a2, int32_t a3);
int32_t target_restart_reason_addr(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g58 = 0; // LR
int32_t g59 = 0; // R0
int32_t g60 = 0; // R1
int32_t g61 = 0; // R10
int32_t g62 = 0; // R11
int32_t g63 = 0; // R2
int32_t g64 = 0; // R3
int32_t g65 = 0; // R4
int32_t g66 = 0; // R5
int32_t g67 = 0; // R6
int32_t g68 = 0; // R7
int32_t g69 = 0; // R8
int32_t g70 = 0; // R9
int32_t g1 = -0x1a60cfd8; // 0x8f603944
int32_t g2 = -0x1a60cfd0; // 0x8f603978
int32_t g3 = -0x16d2bfc9; // 0x8f603ad8
int32_t g4 = -0x16d2bfc9; // 0x8f603c64
int32_t g5 = -0x1a60cd10; // 0x8f637e98
int32_t g6 = -0x1a60cf7c; // 0x8f63867c
int32_t g7 = -0x16d2bfc9; // 0x8f6387c0
int32_t (*g8)() = (int32_t (*)())-0x16d2bf8d; // 0x8f64338c
int32_t g9 = -0x16d2bf8d; // 0x8f64385c
int32_t g10 = -0x16d2bf8d; // 0x8f645798
int32_t g11 = -0x16d2bf10; // 0x8f651560
int32_t g12 = 0x2020003a; // 0x8f686ac4
int32_t g13 = 0x65440030; // 0x8f69c66f
char * g14 = "S"; // 0x8f6a4aed
char * g15; // 0x8f6a4e20
int32_t g16 = 31; // 0x8f6a9020
int32_t g17 = 365; // 0x8f6a9080
char * g18 = "\x01"; // 0x8f6ab02c
int32_t g19 = 0x1000; // 0x8f6ab03c
int32_t g20 = 0; // 0x8f6ab040
int32_t g21 = 0; // 0x8f6ab044
int32_t g22 = 0; // 0x8f6ab048
int32_t g23 = 0x2e8022b8; // 0x8f6ac050
char * g24; // 0x8f6ac05c
int32_t g25 = 0; // 0x8f6ac074
int32_t g26 = 0; // 0x8f6ac080
int32_t g27 = -1; // 0x8f6ac0c0
int32_t g28 = 1; // 0x8f6ac0f0
int32_t g29 = 1; // 0x8f6afe1c
int32_t g30 = 0; // 0x8f6b5064
int32_t g31 = 0; // 0x8f6b5080
char * g32; // 0x8f6b509c
int32_t g33 = 0; // 0x8f6b50a0
int32_t g34 = 0; // 0x8f6b7950
char * g35; // 0x8f6b7954
int32_t g36 = 0; // 0x8f6b8bdc
int32_t g37 = 0; // 0x8f6b8be0
int32_t g38 = 0; // 0x8f6b8be4
int32_t g39 = 0; // 0x8f6b8be8
int32_t g40 = 0; // 0x8f6b8bec
int32_t g41 = 0; // 0x8f6c0398
int32_t g42 = 0; // 0x8f6c03d0
int32_t g43 = 0; // 0x8f6e07ac
int32_t g44 = 0; // 0x8f6e07cc
int32_t g45 = 0; // 0x8f6e07e8
int32_t g46 = 0; // 0x8f6e07ec
int32_t g47 = 0; // 0x8f6e07f4
int32_t g48 = 0; // 0x8f6e0808
int32_t g49 = 0; // 0x8f6e080c
char * g50; // 0x8f6e0848
char * g51; // 0x8f6e1000
char * g52; // 0x8f6e1200
int32_t g53 = 0; // 0x8f6e1228
int32_t g54 = 0; // 0x8f6e12dc
int32_t g55 = 0; // 0x8f6e12e0
struct tm * g56 = NULL; // 0x8f710e90
int32_t g57 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f6203fc - 0x8f62067b
int32_t select_device_tree(int32_t a1, int32_t a2) {
    // 0x8f6203fc
    int32_t v1;
    int32_t v2 = v1; // bp-72
    int32_t v3;
    int32_t v4 = v3; // bp-68
    int32_t v5 = g65; // 0x8f6203fc
    int32_t v6 = g66; // 0x8f6203fc
    int32_t v7 = g67; // 0x8f6203fc
    int32_t v8 = g68; // 0x8f6203fc
    int32_t v9 = g69; // 0x8f6203fc
    g66 = a2;
    int32_t v10 = *(int32_t *)(a1 + 36); // 0x8f620404
    g69 = &g57;
    g65 = a1;
    int32_t v11 = *(int32_t *)(a1 + 8); // 0x8f620418
    int32_t v12 = v10; // 0x8f620424
    if (v10 == 0) {
        // if_8f620420_0_true
        v12 = 2048;
        // branch -> after_if_8f620420_0
    }
    int32_t v13 = g57;
    g64 = v13;
    int32_t v14;
    print_log(1, (int32_t)"Selecting device tree from Appended DTB\n", g63, v13, v14, 0, v1, v3, 0, 0, 0, 0, 0);
    int32_t v15 = *(int32_t *)(g65 + 12); // 0x8f620440
    int32_t v16 = *(int32_t *)(g65 + 32); // 0x8f620448
    int32_t v17 = v16; // R2
    int32_t v18 = dev_tree_appended(v15, v11 - 1 + v12 & -v12, v16, g64, v14, 0, v1, v3, 0, 0, 0, 0, 0, 0); // 0x8f62044c
    g68 = v18;
    int32_t result; // 0x8f620630_2
    if (v18 != 0) {
        // if_8f620458_0_true
        // branch -> 0x8f6205fc
        // 0x8f6205fc
        print_log(1, (int32_t)"Using device tree found from Appended DTB\n", v17, g64, v14, 0, v1, v3, 0, 0, 0, 0, 0);
        g59 = 1;
        // branch -> 0x8f620618
        // 0x8f620618
        g63 = v13;
        if (v13 != g57) {
            // 0x8f620628
            __stack_chk_fail();
            result = g59;
            // branch -> 0x8f62062c
        } else {
            result = 1;
        }
        // 0x8f62062c
        g65 = v5;
        g69 = v9;
        return result;
    }
    // 0x8f620460
    print_log(1, (int32_t)"Device tree NOT found from Appended DTB\n", v17, g64, v14, 0, v1, v3, 0, 0, 0, 0, 0);
    int32_t v19 = *(int32_t *)(g65 + 40); // 0x8f620468
    int32_t v20 = v19; // R6
    int32_t v21; // bp+236
    if (v19 == 0) {
        // 0x8f620608
        print_log(-1, (int32_t)"ERROR: No BOOT DT found!\n", v17, g64, v14, 0, v1, v3, 0, 0, 0, 0, 0);
        g59 = v20;
        v21 = v20;
        // branch -> 0x8f620618
    } else {
        // 0x8f620474
        print_log(1, (int32_t)"Selecting device tree from QCOM Device Tree Table\n", v17, g64, v14, 0, v1, v3, 0, 0, 0, 0, 0);
        v20 = 1;
        int32_t v22 = *(int32_t *)(g65 + 40); // 0x8f620490
        int32_t v23;
        int32_t v24;
        int32_t v25;
        char * v26 = lz4_decode(g66, v22, g68, g68, 1, 0, v1, v3, 0, 0, 0, 0, 0, 0, 0, v25, v24, v13, v5, v6, v7, v8, v9, g58, v23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // 0x8f620498
        int32_t v27 = (int32_t)v26; // 0x8f620498_37
        g64 = v27;
        int32_t v28; // 0x8f6205b4
        int32_t v29; // 0x8f62061014
        int32_t v30; // 0x8f62061015
        int32_t v31; // 0x8f620528_0
        int32_t v32; // 0x8f62052c
        int32_t v33; // 0x8f620568
        int32_t v34; // 0x8f6205e8
        int32_t v35; // 0x8f620524
        uint32_t v36; // 0x8f620568
        uint32_t v37; // 0x8f62056c
        uint32_t v38; // 0x8f620588
        int32_t v39; // 0x8f62057c
        int32_t v40; // 0x8f620594
        if (v26 != NULL) {
            int32_t v41 = 5 * *(int32_t *)(g65 + 40) + v27; // 0x8f6204b4
            int32_t v42 = v3; // 0x8f6204dc
            int32_t v43 = v1; // 0x8f6204dc
            int32_t v44 = v27; // 0x8f6204dc
            int32_t v45 = v41; // 0x8f6204dc
            int32_t v46 = 1; // 0x8f62061018
            if (v41 >= 0x1000001) {
                // 0x8f6204c0
                print_log(v20, (int32_t)"Warning: inflation of QCOM DTB might run out of space: scratch size = %d, LZ4 internal buffer size = %d estimated size needed to inflate = %d\n", 0x1000000, v27, v41, 0, v1, v3, 0, 0, 0, 0, 0);
                v42 = v4;
                v43 = v2;
                v44 = g64;
                v45 = 0x1000000;
                v46 = v41;
                // branch -> 0x8f6204d4
            }
            // 0x8f6204d4
            print_log(1, (int32_t)"Is QCOM DTB compressed?\n", v45, v44, v46, 0, v43, v42, 0, 0, 0, 0, 0);
            int32_t v47 = *(int32_t *)(g65 + 40); // 0x8f6204ec
            v17 = 0x1000000;
            g64 = -0x6c000000;
            if (lz4_decode(g66, v47, 0x1000000, -0x6c000000, 0, 0, v2, v4, 0, 0, 0, 0, 0, 0, 0, v25, v24, v13, v5, v6, v7, v8, v9, g58, v23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) == NULL) {
                // 0x8f6204d4
                v30 = 0;
                // branch -> 0x8f62051c
                // 0x8f62051c
                print_log(1, (int32_t)"Warning: QCOM DTB decompression failed\n", v17, g64, v30, 0, v2, v4, 0, 0, 0, 0, 0);
                v29 = v30;
                // branch -> 0x8f620520
            } else {
                // 0x8f620508
                g66 = -0x6c000000;
                print_log(1, (int32_t)"Inflated QCOM DTB\n", v17, g64, 0, 0, v2, v4, 0, 0, 0, 0, 0);
                v29 = 0;
                // branch -> 0x8f620520
            }
            // 0x8f620520
            v35 = *(int32_t *)(g65 + 36);
            v31 = &v2;
            g63 = v31;
            v32 = dev_tree_validate(g66, v35, v31, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
            g67 = v32;
            if (v32 != 0) {
                // 0x8f620538
                // branch -> 0x8f620540
                // 0x8f620540
                print_log(-1, (int32_t)"ERROR: Cannot validate Device Tree Table \n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                // branch -> 0x8f620544
                // 0x8f620544
                g59 = 0;
                // branch -> 0x8f620618
                // 0x8f620618
                g63 = v13;
                if (v13 != g57) {
                    // 0x8f620628
                    __stack_chk_fail();
                    result = g59;
                    // branch -> 0x8f62062c
                } else {
                    result = 0;
                }
                // 0x8f62062c
                g65 = v5;
                g69 = v9;
                return result;
            }
            // 0x8f62054c
            if (dev_tree_get_entry_info(g66, &v4) != 0) {
                // if_8f62055c_0_true
                // branch -> 0x8f620540
                // 0x8f620540
                print_log(-1, (int32_t)"ERROR: Getting device tree address failed\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                // branch -> 0x8f620544
                // 0x8f620544
                g59 = 0;
                // branch -> 0x8f620618
                // 0x8f620618
                g63 = v13;
                if (v13 != g57) {
                    // 0x8f620628
                    __stack_chk_fail();
                    result = g59;
                    // branch -> 0x8f62062c
                } else {
                    result = 0;
                }
                // 0x8f62062c
                g65 = v5;
                g69 = v9;
                return result;
            }
            // 0x8f620568
            v33 = g65;
            v36 = *(int32_t *)(v33 + 32);
            v37 = *(int32_t *)(v33 + 12);
            g64 = v37;
            if (v36 >= v37) {
                // 0x8f62057c
                v39 = v36 + v24;
                g63 = v39;
                if (v39 > v37) {
                    // 0x8f6205a0
                    // branch -> 0x8f620540
                    // 0x8f620540
                    print_log(4, (int32_t)"devtree too big!\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                    // branch -> 0x8f620544
                    // 0x8f620544
                    g59 = 0;
                    // branch -> 0x8f620618
                    // 0x8f620618
                    g63 = v13;
                    if (v13 != g57) {
                        // 0x8f620628
                        __stack_chk_fail();
                        result = g59;
                        // branch -> 0x8f62062c
                    } else {
                        result = 0;
                    }
                    // 0x8f62062c
                    g65 = v5;
                    g69 = v9;
                    return result;
                }
            }
            // 0x8f620588
            v38 = *(int32_t *)(v33 + 20);
            g64 = v38;
            if (v36 < v38) {
                // 0x8f620588
                v28 = g63;
                // branch -> 0x8f6205ac
            } else {
                // 0x8f620594
                v40 = v36 + v24;
                g63 = v40;
                if (v40 > v38) {
                    // 0x8f6205a0
                    // branch -> 0x8f620540
                    // 0x8f620540
                    print_log(4, (int32_t)"devtree too big!\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                    // branch -> 0x8f620544
                    // 0x8f620544
                    g59 = 0;
                    // branch -> 0x8f620618
                    // 0x8f620618
                    g63 = v13;
                    if (v13 != g57) {
                        // 0x8f620628
                        __stack_chk_fail();
                        result = g59;
                        // branch -> 0x8f62062c
                    } else {
                        result = 0;
                    }
                    // 0x8f62062c
                    g65 = v5;
                    g69 = v9;
                    return result;
                }
                v28 = v40;
            }
            // 0x8f6205ac
            if (check_mbm_addr_range_overlap(v36, v24, v28, v38) == 0) {
                // 0x8f6205e0
                v34 = v24;
                memcpy((char *)v36, (char *)(g66 + v25), v34);
                // branch -> 0x8f6205fc
                // 0x8f6205fc
                print_log(1, (int32_t)"Device tree found from QCOM Device Tree Table\n", v34, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                g59 = 1;
                v21 = 1;
                // branch -> 0x8f620618
            } else {
                // 0x8f6205c0
                print_log(-1, (int32_t)"%s:%s(%d): Address overlap with aboot address.\n", (int32_t)"app/mbm/linux_boot.c", (int32_t)"select_device_tree", g64 & -0x10000 | 850, 0, v2, v4, 0, 0, 0, 0, 0);
                // branch -> 0x8f620544
                // 0x8f620544
                g59 = 0;
                v21 = 0;
                // branch -> 0x8f620618
            }
            // 0x8f620618
            g63 = v13;
            if (v13 != g57) {
                // 0x8f620628
                __stack_chk_fail();
                result = g59;
                // branch -> 0x8f62062c
            } else {
                result = v21;
            }
            // 0x8f62062c
            g65 = v5;
            g69 = v9;
            return result;
        }
        // if_8f6204a0_0_true
        v30 = 1;
        // branch -> 0x8f62051c
        // 0x8f62051c
        print_log(v20, (int32_t)"QCOM DTB not compressed\n", g68, v27, v30, 0, v1, v3, 0, 0, 0, 0, 0);
        v29 = v30;
        // branch -> 0x8f620520
        // 0x8f620520
        v35 = *(int32_t *)(g65 + 36);
        v31 = &v2;
        g63 = v31;
        v32 = dev_tree_validate(g66, v35, v31, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
        g67 = v32;
        if (v32 == 0) {
            // 0x8f62054c
            if (dev_tree_get_entry_info(g66, &v4) != 0) {
                // if_8f62055c_0_true
                // branch -> 0x8f620540
                // 0x8f620540
                print_log(-1, (int32_t)"ERROR: Getting device tree address failed\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                // branch -> 0x8f620544
                // 0x8f620544
                g59 = 0;
                // branch -> 0x8f620618
                // 0x8f620618
                g63 = v13;
                if (v13 != g57) {
                    // 0x8f620628
                    __stack_chk_fail();
                    result = g59;
                    // branch -> 0x8f62062c
                } else {
                    result = 0;
                }
                // 0x8f62062c
                g65 = v5;
                g69 = v9;
                return result;
            }
            // 0x8f620568
            v33 = g65;
            v36 = *(int32_t *)(v33 + 32);
            v37 = *(int32_t *)(v33 + 12);
            g64 = v37;
            if (v36 >= v37) {
                // 0x8f62057c
                v39 = v36 + v24;
                g63 = v39;
                if (v39 > v37) {
                    // 0x8f6205a0
                    // branch -> 0x8f620540
                    // 0x8f620540
                    print_log(4, (int32_t)"devtree too big!\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                    // branch -> 0x8f620544
                    // 0x8f620544
                    g59 = 0;
                    // branch -> 0x8f620618
                    // 0x8f620618
                    g63 = v13;
                    if (v13 != g57) {
                        // 0x8f620628
                        __stack_chk_fail();
                        result = g59;
                        // branch -> 0x8f62062c
                    } else {
                        result = 0;
                    }
                    // 0x8f62062c
                    g65 = v5;
                    g69 = v9;
                    return result;
                }
            }
            // 0x8f620588
            v38 = *(int32_t *)(v33 + 20);
            g64 = v38;
            if (v36 < v38) {
                // 0x8f620588
                v28 = g63;
                // branch -> 0x8f6205ac
            } else {
                // 0x8f620594
                v40 = v36 + v24;
                g63 = v40;
                if (v40 > v38) {
                    // 0x8f6205a0
                    // branch -> 0x8f620540
                    // 0x8f620540
                    print_log(4, (int32_t)"devtree too big!\n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                    // branch -> 0x8f620544
                    // 0x8f620544
                    g59 = 0;
                    // branch -> 0x8f620618
                    // 0x8f620618
                    g63 = v13;
                    if (v13 != g57) {
                        // 0x8f620628
                        __stack_chk_fail();
                        result = g59;
                        // branch -> 0x8f62062c
                    } else {
                        result = 0;
                    }
                    // 0x8f62062c
                    g65 = v5;
                    g69 = v9;
                    return result;
                }
                v28 = v40;
            }
            // 0x8f6205ac
            if (check_mbm_addr_range_overlap(v36, v24, v28, v38) == 0) {
                // 0x8f6205e0
                v34 = v24;
                memcpy((char *)v36, (char *)(g66 + v25), v34);
                // branch -> 0x8f6205fc
                // 0x8f6205fc
                print_log(1, (int32_t)"Device tree found from QCOM Device Tree Table\n", v34, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
                g59 = 1;
                v21 = 1;
                // branch -> 0x8f620618
            } else {
                // 0x8f6205c0
                print_log(-1, (int32_t)"%s:%s(%d): Address overlap with aboot address.\n", (int32_t)"app/mbm/linux_boot.c", (int32_t)"select_device_tree", g64 & -0x10000 | 850, 0, v2, v4, 0, 0, 0, 0, 0);
                // branch -> 0x8f620544
                // 0x8f620544
                g59 = 0;
                v21 = 0;
                // branch -> 0x8f620618
            }
            // 0x8f620618
            g63 = v13;
            if (v13 != g57) {
                // 0x8f620628
                __stack_chk_fail();
                result = g59;
                // branch -> 0x8f62062c
            } else {
                result = v21;
            }
            // 0x8f62062c
            g65 = v5;
            g69 = v9;
            return result;
        }
        // 0x8f620538
        // branch -> 0x8f620540
        // 0x8f620540
        print_log(-1, (int32_t)"ERROR: Cannot validate Device Tree Table \n", g63, g64, v29, 0, v2, v4, 0, 0, 0, 0, 0);
        // branch -> 0x8f620544
        // 0x8f620544
        g59 = 0;
        v21 = 0;
        // branch -> 0x8f620618
    }
    // 0x8f620618
    g63 = v13;
    if (v13 != g57) {
        // 0x8f620628
        __stack_chk_fail();
        result = g59;
        // branch -> 0x8f62062c
    } else {
        result = v21;
    }
    // 0x8f62062c
    g65 = v5;
    g69 = v9;
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// struct tm * gmtime_r(const time_t * restrict timer, struct tm * restrict tp);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// size_t strnlen(const char * string, size_t maxlen);
// char * strrchr(char * s, int c);
// int vsprintf(char * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:51:25
