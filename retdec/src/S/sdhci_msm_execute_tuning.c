//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t clk_get(char * str2);
int32_t clk_get_set_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t dbval_provision_req(char a1, char * a2, int32_t a3);
int32_t dbval_provision_store(char * a1, int32_t * a2, char * a3);
int32_t event_signal(int32_t a1, int32_t a2, int32_t a3);
void event_unsignal(int32_t a1);
int32_t fdt_next_tag(int32_t a1, int32_t a2, int32_t * a3);
int32_t fdt_offset_ptr(int32_t a1, int32_t a2, int32_t a3);
int32_t generic_mmc_erase_sector(int64_t a1, int64_t a2);
int32_t generic_mmc_get_protect_group_size(int32_t a1, int32_t a2);
int32_t get_root_detect_disabled(void);
int32_t getvar_handler_root_detect(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_map_address(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_virtual_to_physical(int32_t a1, int32_t a2, int32_t a3);
int32_t load_partition(int32_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t load_partition_by_name(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mcs_clear_hash_ctx(char * a1, int32_t a2, int32_t a3);
int32_t mcs_initialize_montgomery_alg(int32_t * a1, int32_t a2);
int32_t mdss_dsi_auto_pll_config(int32_t * a1, int32_t a2);
int32_t mdss_dsi_host_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdss_dsi_phy_init(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_cmd_bta_sw_trigger(int32_t a1, int32_t a2, int32_t a3);
int32_t nexus_usbpidvid(int32_t a1, int32_t a2);
int32_t read_root_status(void);
char * sdhci_msm_execute_tuning(char * a1, int32_t a2, int32_t a3);
int32_t sdhci_msm_toggle_cdr(int32_t * a1, int32_t a2, int32_t a3);
int32_t sod_init(void);
int32_t sod_ramdump_run(void);
int32_t thread_init(int32_t a1, int32_t a2);
int32_t thread_set_name(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g26 = 0; // LR
int32_t g27 = 0; // R0
int32_t g28 = 0; // R1
int32_t g29 = 0; // R10
int32_t g30 = 0; // R11
int32_t g31 = 0; // R2
int32_t g32 = 0; // R3
int32_t g33 = 0; // R4
int32_t g34 = 0; // R5
int32_t g35 = 0; // R6
int32_t g36 = 0; // R7
int32_t g37 = 0; // R8
int32_t g38 = 0; // R9
int32_t g1 = -0x15ffffb3; // 0x8f6361f4
char * g2 = "\xff\xff"; // 0x8f67d950
int32_t g3 = 0xff0fff; // 0x8f67db7c
int32_t g4 = 0x6d0f0703; // 0x8f67f558
int32_t g5 = 0x1c9496e0; // 0x8f67f5a0
int32_t g6 = 0x65440030; // 0x8f69c66f
int32_t g7 = 0x746e6300; // 0x8f6a4e20
int32_t g8 = 1; // 0x8f6ac0f0
int32_t g9 = -1; // 0x8f6ac214
int32_t g10 = -0x70a00000; // 0x8f6ac224
char * g11 = "\xf1"; // 0x8f6affa8
int32_t g12 = 0; // 0x8f6b7988
int32_t g13 = 0; // 0x8f6b798c
int32_t g14 = 0; // 0x8f6b8ad0
int32_t g15 = 0; // 0x8f6b8ad4
char * g16; // 0x8f6c0628
char * g17; // 0x8f6c0649
int32_t (*g18)(int32_t, int32_t, int32_t) = NULL; // 0x8f6e0784
int32_t g19 = 0; // 0x8f6e0790
char * g20; // 0x8f6e0794
int16_t * g21 = NULL; // 0x8f70da9c
int32_t g22 = 0; // 0x8f70da9e
int32_t g23 = 0; // 0x8f7112f4
int32_t g24 = 0; // 0x8f7114ac
int32_t g25 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f608754 - 0x8f608e8f
char * sdhci_msm_execute_tuning(char * a1, int32_t a2, int32_t a3) {
    // 0x8f608754
    int32_t v1;
    char * v2 = (char *)v1;
    int32_t v3 = (int32_t)a1; // R4
    int32_t v4 = g23;
    int32_t v5 = 64; // R2
    int32_t v6 = g26; // R6
    int32_t v7;
    memset((char *)&v7, 0, 64);
    int32_t v8 = *(int32_t *)(v3 + 40); // R5
    *(char *)(v3 + 12) = 1;
    int32_t v9 = v8; // 0x8f608798
    int32_t v10; // R1
    int32_t v11; // R3
    int32_t v12;
    int32_t v13;
    int32_t v14;
    if (*(char *)(v9 + 8) != 0) {
        // 0x8f6087a4
        if (*(char *)(v9 + 9) == 0) {
            int32_t v15 = *(int32_t *)(v3 + 8); // 0x8f6087b0
            v11 = v15;
            if (v15 == 3) {
                // 0x8f6087bc
                v10 = 128;
                if (memalign(64, 128) == NULL) {
                    // 0x8f6087d0
                    v10 = (int32_t)"ASSERT FAILED at (%s:%d): %s\n";
                    v5 = (int32_t)"platform/msm_shared/sdhci_msm.c";
                    v11 = (int32_t)"tuning_data" & -0x10000 | 622;
                    _panic(v6, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/sdhci_msm.c", (int32_t)"tuning_data" & -0x10000 | 622, (int32_t)"tuning_data", v14, 0);
                    v2 = "tuning_data";
                    // branch -> 0x8f6087ec
                }
                int32_t v16 = (int32_t)v2;
                int32_t v17;
                int32_t v18;
                int32_t v19;
                if (sdhci_msm_init_dll((char *)v3, v10, v5, v11, v16, v14, 0, v19, v18, v17, v13) == 0) {
                    int32_t v20 = *(int32_t *)(v3 + 40); // 0x8f6087fc
                    int32_t v21 = (int32_t)*(char *)(v20 + 10); // 0x8f608804
                    int32_t v22 = sdhci_msm_config_dll_isra_4((char *)v3, v21, v5, v20, v16, v14, 0, v19, v18, v17, v13); // 0x8f608808
                    if (v22 == 0) {
                        int32_t * v23 = (int32_t *)(*(int32_t *)v3 + 256); // 0x8f608818_0
                        int32_t v24 = *v23 | 1; // 0x8f60881c
                        *v23 = v24;
                        char v25 = *(char *)(v3 + 16); // 0x8f608824
                        int32_t v26 = *(int32_t *)v3; // 0x8f608828
                        int32_t v27; // 0x8f6089c4
                        int32_t v28; // 0x8f608a2c
                        int32_t v29;
                        int32_t v30;
                        int32_t v31;
                        int32_t v32; // 0x8f608a44
                        if (v25 == 0) {
                            int32_t v33 = target_ddr_cfg_val((char *)v22, v21, v24, (int32_t)v25, v16, v14); // 0x8f608980
                            *(int32_t *)(v26 + 440) = v33;
                            v6 = 50;
                            int32_t * v34 = (int32_t *)(*(int32_t *)v3 + 436); // 0x8f608990_0
                            *v34 = *v34 | 1;
                            // branch -> 0x8f60899c
                            while (true) {
                                int32_t v35 = *(int32_t *)v3; // 0x8f60899c
                                v11 = v35;
                                int32_t v36 = *(int32_t *)(v35 + 264); // 0x8f6089a0
                                v5 = v36;
                                if ((v36 & 2048) == 0) {
                                    // 0x8f6089ac
                                    mdelay(1, v21, v36, v35);
                                    int32_t v37 = v6; // 0x8f6089b4
                                    v6 = v37 - 1;
                                    if (v37 == 1) {
                                        // break -> 0x8f6089bc
                                        break;
                                    }
                                    // continue -> 0x8f60899c
                                    continue;
                                } else {
                                    int32_t * v38 = (int32_t *)(v35 + 432); // 0x8f6089d0_0
                                    *v38 = *v38 | 8;
                                    // branch -> 0x8f6089e0
                                }
                                // 0x8f6089e0
                                v6 = 0;
                                memset((char *)&v12, 0, 64);
                                v12 = 21;
                                v28 = sdhci_send_command((char *)v3, (int32_t)&v12, 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30, 0, 0, 0, 0, v29);
                                if (v28 == 0) {
                                    // 0x8f608a38
                                    print_log(2, (int32_t)"Sending CMD21 after HS400 calibration\n", 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30);
                                    // branch -> 0x8f608a44
                                }
                                // 0x8f608a44
                                v32 = v6;
                                if (v32 == 0) {
                                    // after_if_8f608a4c_0
                                    *(char *)(v8 + 9) = 1;
                                    if (v32 != 0) {
                                        // 0x8f608df8
                                        v6 = 1;
                                        // branch -> 0x8f608dfc
                                    }
                                } else {
                                    // 0x8f608df8
                                    v6 = 1;
                                    // branch -> 0x8f608dfc
                                }
                                // 0x8f608dfc
                                *(char *)(v3 + 12) = 0;
                                *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                                if (v4 != g23) {
                                    // 0x8f608e28
                                    __stack_chk_fail();
                                    // branch -> 0x8f608e2c
                                }
                                // 0x8f608e2c
                                return (char *)v6;
                            }
                            // 0x8f6089bc
                            v27 = (int32_t)"Error: DLL lock for hs400 operation is not set\n";
                            // branch -> 0x8f6089c4
                        } else {
                            int32_t * v39 = (int32_t *)(v26 + 388); // 0x8f608834_0
                            *v39 = *v39 & -2;
                            v6 = 50;
                            int32_t * v40 = (int32_t *)(*(int32_t *)v3 + 388); // 0x8f608848_0
                            *v40 = *v40 & -65;
                            int32_t * v41 = (int32_t *)(*(int32_t *)v3 + 376); // 0x8f608858_0
                            *v41 = *v41 & -2;
                            int32_t * v42 = (int32_t *)(*(int32_t *)v3 + 376); // 0x8f608868_0
                            *v42 = *v42 | 2;
                            int32_t * v43 = (int32_t *)(*(int32_t *)v3 + 388); // 0x8f608878_0
                            *v43 = *v43 & -65;
                            *(int32_t *)(*(int32_t *)v3 + 304) = 0x11800ec;
                            *(int32_t *)(*(int32_t *)v3 + 308) = 0x3011111;
                            *(int32_t *)(*(int32_t *)v3 + 312) = 0x1201000;
                            *(int32_t *)(*(int32_t *)v3 + 316) = 4;
                            *(int32_t *)(*(int32_t *)v3 + 320) = -0x348cdfe0;
                            int32_t v44 = -0x348cf4e7; // 0x8f6088c0
                            *(int32_t *)(*(int32_t *)v3 + 324) = v44;
                            *(int32_t *)(*(int32_t *)v3 + 336) = v44 & -0x10000 | 1250;
                            *(int32_t *)(*(int32_t *)v3 + 332) = 0;
                            *(int32_t *)(*(int32_t *)v3 + 352) = 0x16334;
                            int32_t * v45 = (int32_t *)(*(int32_t *)v3 + 304); // 0x8f6088f0_0
                            *v45 = *v45 | 0x10000;
                            int32_t * v46 = (int32_t *)(*(int32_t *)v3 + 304); // 0x8f608900_0
                            *v46 = *v46 & -0x10001;
                            int32_t * v47 = (int32_t *)(*(int32_t *)v3 + 304); // 0x8f608910_0
                            *v47 = *v47 | 0x20000;
                            int32_t * v48 = (int32_t *)(*(int32_t *)v3 + 312); // 0x8f608920_0
                            int32_t v49 = *v48 | 0x10000; // 0x8f608924
                            v5 = v49;
                            *v48 = v49;
                            // branch -> 0x8f60892c
                            while (true) {
                                int32_t v50 = *(int32_t *)v3; // 0x8f60892c
                                v11 = v50;
                                int32_t * v51 = (int32_t *)(v50 + 356); // 0x8f608930_0
                                uint32_t v52 = *v51; // 0x8f608930
                                if (v52 % 2 != 0) {
                                    int32_t v53 = *v51 & 0x7000000; // 0x8f60895c
                                    int32_t v54;
                                    if (v53 == 0) {
                                        int32_t * v55 = (int32_t *)(v50 + 388); // 0x8f608960_1
                                        *v55 = *v55 | 64;
                                        v54 = 0;
                                        // branch -> 0x8f6089e0
                                    } else {
                                        // 0x8f608970
                                        print_log(-1, (int32_t)"CDC error set during calibration: %x\n", v53, v50, v16, v14, 0, v19, v18, v17, v13, v31, v30);
                                        // branch -> 0x8f6089c8
                                        // 0x8f6089c8
                                        v54 = 1;
                                        // branch -> 0x8f6089e0
                                    }
                                    // 0x8f6089e0
                                    v6 = v54;
                                    memset((char *)&v12, 0, 64);
                                    v12 = 21;
                                    v28 = sdhci_send_command((char *)v3, (int32_t)&v12, 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30, 0, 0, 0, 0, v29);
                                    if (v28 == 0) {
                                        // 0x8f608a38
                                        print_log(2, (int32_t)"Sending CMD21 after HS400 calibration\n", 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30);
                                        // branch -> 0x8f608a44
                                    }
                                    // 0x8f608a44
                                    v32 = v6;
                                    if (v32 == 0) {
                                        // after_if_8f608a4c_0
                                        *(char *)(v8 + 9) = 1;
                                        if (v32 != 0) {
                                            // 0x8f608df8
                                            v6 = 1;
                                            // branch -> 0x8f608dfc
                                        }
                                    } else {
                                        // 0x8f608df8
                                        v6 = 1;
                                        // branch -> 0x8f608dfc
                                    }
                                    // 0x8f608dfc
                                    *(char *)(v3 + 12) = 0;
                                    *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                                    if (v4 != g23) {
                                        // 0x8f608e28
                                        __stack_chk_fail();
                                        // branch -> 0x8f608e2c
                                    }
                                    // 0x8f608e2c
                                    return (char *)v6;
                                }
                                // 0x8f60893c
                                mdelay(1, v52, v5, v50);
                                int32_t v56 = v6; // 0x8f608944
                                v6 = v56 - 1;
                                if (v56 == 1) {
                                    // break -> 0x8f60894c
                                    break;
                                }
                                // continue -> 0x8f60892c
                            }
                            // 0x8f60894c
                            v27 = (int32_t)"Error: Calibration done in CDC status not set\n";
                            // branch -> 0x8f6089c4
                        }
                        // 0x8f6089c4
                        print_log(-1, v27, v5, v11, v16, v14, 0, v19, v18, v17, v13, v31, v30);
                        // branch -> 0x8f6089c8
                        // 0x8f6089c8
                        // branch -> 0x8f6089e0
                        // 0x8f6089e0
                        v6 = 1;
                        memset((char *)&v12, 0, 64);
                        v12 = 21;
                        v28 = sdhci_send_command((char *)v3, (int32_t)&v12, 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30, 0, 0, 0, 0, v29);
                        if (v28 == 0) {
                            // 0x8f608a38
                            print_log(2, (int32_t)"Sending CMD21 after HS400 calibration\n", 128, 1, v16, v14, 0, v19, v18, v17, v13, v31, v30);
                            // branch -> 0x8f608a44
                        }
                        // 0x8f608a44
                        v32 = v6;
                        if (v32 == 0) {
                            // after_if_8f608a4c_0
                            *(char *)(v8 + 9) = 1;
                            if (v32 == 0) {
                                // 0x8f608dfc
                                *(char *)(v3 + 12) = 0;
                                *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                                if (v4 != g23) {
                                    // 0x8f608e28
                                    __stack_chk_fail();
                                    // branch -> 0x8f608e2c
                                }
                                // 0x8f608e2c
                                return (char *)v6;
                            }
                        }
                    }
                }
                // 0x8f608df8
                // branch -> 0x8f608dfc
                // 0x8f608dfc
                *(char *)(v3 + 12) = 0;
                *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                if (v4 != g23) {
                    // 0x8f608e28
                    __stack_chk_fail();
                    // branch -> 0x8f608e2c
                }
                // 0x8f608e2c
                return (char *)1;
            }
        }
    }
    v11 = (int32_t)&g2;
    int32_t n = a3 == 2 ? 128 : 64;
    v5 = &g3;
    v10 = n;
    int32_t str2 = (int32_t)&g2; // 0x8f608a7c
    if (a3 != 2) {
        // if_8f608a78_0_true
        v11 = &g3;
        str2 = &g3;
        // branch -> after_if_8f608a78_0
    }
    char * str = memalign(64, n); // 0x8f608a80
    int32_t v57 = (int32_t)str; // 0x8f608a80_5
    if (str == NULL) {
        // 0x8f608a90
        v10 = (int32_t)"ASSERT FAILED at (%s:%d): %s\n";
        v5 = (int32_t)"platform/msm_shared/sdhci_msm.c";
        v11 = (int32_t)"tuning_data" & -0x10000 | 710;
        _panic(v6, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/sdhci_msm.c", (int32_t)"tuning_data" & -0x10000 | 710, (int32_t)"tuning_data", v14, 0);
        v2 = "tuning_data";
        // branch -> 0x8f608aac
    }
    int32_t v58 = (int32_t)v2;
    if (sdhci_msm_init_dll((char *)v3, v10, v5, v11, v58, v14, 0, n, v57, str2, v13) == 0) {
        int32_t v59 = 0; // R7
        v6 = 0;
        int32_t v60 = &v13; // 0x8f608ac4_0
        int32_t v61;
        int32_t v62 = &v61; // 0x8f608af8_0
        // branch -> 0x8f608ac4
        while (true) {
            // 0x8f608ac4
            v5 = 64;
            memset((char *)&v13, 0, 64);
            v8 = 0;
            int32_t v63 = 0; // R9
            int32_t v64 = 0; // 0x8f608ae8
            // branch -> 0x8f608ae4
            while (true) {
              lab_0x8f608ae4:
                // 0x8f608ae4
                if (sdhci_msm_config_dll_isra_4((char *)v3, v64, v5, v11, v58, v14, 0, n, v57, str2, v13) == 0) {
                    // 0x8f608af8
                    v5 = 1;
                    v11 = n;
                    int32_t v65 = 21; // 0x8f608b20_0
                    v13 = v65;
                    if (sdhci_send_command((char *)v3, v60, 1, n, v58, v14, 0, n, v57, str2, v65, 0, 1, 0, 0, 0, 0, 1) == 0) {
                        // 0x8f608b40
                        v5 = n;
                        if (memcmp(str, (char *)str2, n) == 0) {
                            int32_t v66 = v8; // 0x8f608b58
                            int32_t v67 = 4 * v66 + v62; // 0x8f608b58
                            v5 = v67;
                            v8 = v66 + 1;
                            *(int32_t *)(v67 - 1160) = v63;
                            // branch -> 0x8f608b64
                        }
                    }
                    int32_t v68 = v63 + 1; // 0x8f608b64
                    v63 = v68;
                    if (v68 == 16) {
                        // break -> 0x8f608b70
                        break;
                    }
                    v64 = v68;
                    // continue -> 0x8f608ae4
                    continue;
                }
            }
            int32_t v69 = v8; // 0x8f608b70
            int32_t v70 = v69; // 0x8f608bc048
            int32_t v71; // 0x8f608c18_0
            int32_t * v72; // 0x8f608c4c_0
            int32_t v73; // LR
            int32_t v74; // R0
            int32_t v75; // R11
            int32_t v76; // R12
            int32_t v77;
            int32_t v78;
            int32_t v79;
            int32_t v80;
            int32_t v81; // 0x8f608bc0
            uint32_t v82; // 0x8f608c5c
            int32_t v83; // 0x8f608c64
            int32_t v84; // 0x8f608c68
            int32_t v85; // 0x8f608d04
            int32_t v86; // 0x8f608c50
            int32_t v87; // 0x8f608ca8
            int32_t v88; // 0x8f608cac
            int32_t v89; // 0x8f608c30
            int32_t v90; // 0x8f608c40
            int32_t v91; // 0x8f608c78
            int32_t v92; // 0x8f608d08
            int32_t v93; // 0x8f608d2863
            int32_t v94; // 0x8f608c30
            int32_t v95; // 0x8f608c04
            int32_t v96; // 0x8f608c2c
            uint32_t v97; // 0x8f608cf8
            if (v69 == 16) {
                while (true) {
                    int32_t v98 = (v6 + 1) % 256; // 0x8f608b7c
                    v6 = v98;
                    if (v98 > 3) {
                        // 0x8f608ba4
                        v8 = 16;
                        // branch -> 0x8f608ba8
                        // 0x8f608ba8
                        v81 = 16;
                        if (v59 != 0) {
                            // 0x8f608bb0
                            v5 = 0;
                            mmc_set_drv_type((char *)v3, a2, 0, v11, v58, v14, 0);
                            v81 = v8;
                            // branch -> 0x8f608bc0
                        }
                        // 0x8f608bc0
                        if (v81 == 0) {
                            // 0x8f608d80
                            // branch -> 0x8f608d44
                        } else {
                            // 0x8f608bc8
                            v75 = &v78;
                            memset((char *)&v12, 0, 1024);
                            memset((char *)&v78, 0, 64);
                            v80 = 0;
                            if (v7 == 0) {
                                // 0x8f608bfc
                                v95 = *(int32_t *)(4 * v8 + v62 - 1164);
                                v80 = v95 == 15;
                                // branch -> 0x8f608c14
                            }
                            // 0x8f608c14
                            v74 = 0;
                            v71 = &v79;
                            v76 = v71;
                            v5 = 0;
                            int32_t v99 = 0; // 0x8f608c3c
                            v90 = v71;
                            int32_t v100 = 0; // 0x8f608c24
                            v89 = 0;
                            // branch -> 0x8f608c24
                            while (true) {
                                // 0x8f608c24
                                v11 = v62;
                                v96 = *(int32_t *)(v90 - 4);
                                v94 = 4 * v89;
                                v6 = v94;
                                v73 = v99 + 1;
                                *(int32_t *)(4 * (16 * v89 + v100) + v62 - 1032) = v96;
                                v72 = (int32_t *)(v94 + v62 - 1096);
                                v86 = *v72 + 1;
                                v10 = v86;
                                *v72 = v86;
                                if (v73 == v8) {
                                    // 0x8f608c5c
                                    v82 = v8;
                                    if (v82 > 14 && v82 != 15) {
                                        // if_8f608c60_0_true
                                        v83 = 0;
                                        // branch -> after_if_8f608c60_0
                                    } else {
                                        // 0x8f608c5c
                                        v83 = v80;
                                        // branch -> after_if_8f608c60_0
                                    }
                                    // after_if_8f608c60_0
                                    v84 = v83;
                                    if (v82 == 15 || v82 <= 14) {
                                        // if_8f608c64_0_true
                                        v84 = v83 % 2;
                                        // branch -> after_if_8f608c64_0
                                    }
                                    // after_if_8f608c64_0
                                    if (v84 != 0) {
                                        // 0x8f608c70
                                        v91 = v10;
                                        if (v91 < 16) {
                                            int32_t v101 = &v77; // 0x8f608ca8
                                            int32_t v102 = 0; // 0x8f608cac101
                                            while (true) {
                                                // 0x8f608ca8
                                                v87 = v101 + 4;
                                                v88 = v102 + 1;
                                                int32_t v103 = *(int32_t *)v87; // 0x8f608cb8
                                                *(int32_t *)(64 * v5 + 4 * v91 + v87) = v103;
                                                if (v88 < v78) {
                                                    // 0x8f608ca8
                                                    // branch -> 0x8f608cd0
                                                } else {
                                                  lab_0x8f608ca8:;
                                                    int32_t v104 = v88;
                                                    if (v10 + v104 < 16) {
                                                        // 0x8f608ca8
                                                        v101 = v87;
                                                        v102 = v104;
                                                        // branch -> 0x8f608ca8
                                                        continue;
                                                    } else {
                                                        // 0x8f608cd0
                                                        // branch -> 0x8f608cd0
                                                        // 0x8f608cd0
                                                        v11 = v62;
                                                        *(int32_t *)(v6 + v62 - 1096) = v78 + v10;
                                                        v78 = 0;
                                                        // branch -> 0x8f608cec
                                                        // 0x8f608cec
                                                        v93 = 0;
                                                        v92 = 0;
                                                        v85 = 0;
                                                        // branch -> 0x8f608cf8
                                                        while (true) {
                                                            // 0x8f608cf8
                                                            v97 = *(int32_t *)(4 * v85 + v75);
                                                            int32_t v105; // 0x8f608d18
                                                            int32_t v106; // 0x8f608d28
                                                            int32_t v107; // 0x8f608d0c
                                                            if (v97 > v92) {
                                                              lab_if_8f608d00_0_true_3:
                                                                // if_8f608d00_0_true
                                                                v106 = v85;
                                                                v105 = v97;
                                                                v107 = v85 + 1;
                                                                // branch -> after_if_8f608d08_0
                                                            } else {
                                                              lab_if_8f608d08_0_true_critedge_3:
                                                                // if_8f608d08_0_true.critedge
                                                                v106 = v93;
                                                                v105 = v92;
                                                                v107 = v85 + 1;
                                                                // branch -> after_if_8f608d08_0
                                                            }
                                                            // after_if_8f608d08_0
                                                            if (v107 > v5) {
                                                                uint32_t v108 = 3 * v105; // 0x8f608d18
                                                                int32_t v109 = v108 < 4 ? 0 : v108 / 4 - 1; // 0x8f608d24
                                                                int32_t v110 = *(int32_t *)(4 * (v109 + 16 * v106) + v62 - 1032); // 0x8f608d30
                                                                if (v110 > -1) {
                                                                    // 0x8f608d50
                                                                    if (sdhci_msm_config_dll_isra_4((char *)v3, v110, v62, v11, v58, v14, 0, n, v57, str2, v13) == 0) {
                                                                        int32_t v111 = *(int32_t *)(v3 + 40); // 0x8f608d6c
                                                                        *(char *)(v111 + 10) = (char)v110;
                                                                        if (v8 == 16) {
                                                                            // 0x8f608d8c
                                                                            v13 = 21;
                                                                            int32_t v112 = sdhci_send_command((char *)v3, v60, v57, 1, v58, v14, 0, n, v57, str2, 21, 0, 1, 0, 0, 0, 0, 1); // 0x8f608dd4
                                                                            if (v112 == 0) {
                                                                                // 0x8f608de0
                                                                                print_log(2, (int32_t)"Sending CMD21 after CDR enable with default phases fail\n", v57, 1, v58, v14, 0, n, v57, str2, v13, 0, 1);
                                                                                // branch -> 0x8f608dec
                                                                                // 0x8f608dec
                                                                                free(str);
                                                                                // branch -> 0x8f608dfc
                                                                                // 0x8f608dfc
                                                                                *(char *)(v3 + 12) = 0;
                                                                                *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                                                                                if (v4 != g23) {
                                                                                    // 0x8f608e28
                                                                                    __stack_chk_fail();
                                                                                    // branch -> 0x8f608e2c
                                                                                }
                                                                                // 0x8f608e2c
                                                                                return (char *)v112;
                                                                            }
                                                                        }
                                                                    }
                                                                    // 0x8f608d64
                                                                    v6 = 0;
                                                                    // branch -> 0x8f608dec
                                                                } else {
                                                                    // 0x8f608d3c
                                                                    // branch -> 0x8f608d44
                                                                    // 0x8f608d44
                                                                    print_log(-1, (int32_t)"Failed in selecting the tuning phase\n", v62, v11, v58, v14, 0, n, v57, str2, v13, 0, 1);
                                                                    // branch -> 0x8f608d48
                                                                    // 0x8f608d48
                                                                    v6 = 1;
                                                                    // branch -> 0x8f608dec
                                                                }
                                                                // 0x8f608dec
                                                                free(str);
                                                                // branch -> 0x8f608dfc
                                                                // 0x8f608dfc
                                                                *(char *)(v3 + 12) = 0;
                                                                *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                                                                if (v4 != g23) {
                                                                    // 0x8f608e28
                                                                    __stack_chk_fail();
                                                                    // branch -> 0x8f608e2c
                                                                }
                                                                // 0x8f608e2c
                                                                return (char *)v6;
                                                            }
                                                            // if_8f608d10_0_true
                                                            v93 = v106;
                                                            v92 = v105;
                                                            v85 = v107;
                                                            // branch -> 0x8f608cf8
                                                        }
                                                    }
                                                }
                                                // 0x8f608cd0
                                                v11 = v62;
                                                *(int32_t *)(v6 + v62 - 1096) = v78 + v10;
                                                v78 = 0;
                                                // branch -> 0x8f608cec
                                                // 0x8f608cec
                                                v93 = 0;
                                                v92 = 0;
                                                v85 = 0;
                                                // branch -> 0x8f608cf8
                                                while (true) {
                                                    // 0x8f608cf8
                                                    v97 = *(int32_t *)(4 * v85 + v75);
                                                    if (v97 > v92) {
                                                        goto lab_if_8f608d00_0_true_3;
                                                    }
                                                    goto lab_if_8f608d08_0_true_critedge_3;
                                                }
                                            }
                                        }
                                        // 0x8f608cd0
                                        v11 = v62;
                                        *(int32_t *)(v6 + v62 - 1096) = v78 + v91;
                                        v78 = 0;
                                        // branch -> 0x8f608cec
                                    }
                                    // 0x8f608cec
                                    v93 = 0;
                                    v92 = 0;
                                    v85 = 0;
                                    // branch -> 0x8f608cf8
                                    while (true) {
                                        // 0x8f608cf8
                                        v97 = *(int32_t *)(4 * v85 + v75);
                                        if (v97 > v92) {
                                            goto lab_if_8f608d00_0_true_3;
                                        }
                                        goto lab_if_8f608d08_0_true_critedge_3;
                                    }
                                } else {
                                  lab_0x8f608c88:;
                                    int32_t v113 = v76 + 4; // 0x8f608c90
                                    v76 = v113;
                                    int32_t v114;
                                    int32_t v115;
                                    if (v96 + 1 == *(int32_t *)v90) {
                                        // if_8f608c98_0_true
                                        v115 = v5;
                                        v114 = v74 + 1;
                                        // branch -> 0x8f608c24
                                    } else {
                                        int32_t v116 = v5 + 1; // 0x8f608c9c
                                        v5 = v116;
                                        v115 = v116;
                                        v114 = 0;
                                        // branch -> 0x8f608c24
                                    }
                                    // 0x8f608c24
                                    v74 = v114;
                                    v99 = v73;
                                    v90 = v113;
                                    v100 = v114;
                                    v89 = v115;
                                    // branch -> 0x8f608c24
                                    continue;
                                }
                            }
                        }
                        // 0x8f608d44
                        print_log(-1, (int32_t)"Failed to get tuned phase\n", v5, v11, v58, v14, 0, n, v57, str2, v13, 0, 1);
                        // branch -> 0x8f608d48
                    } else {
                        // 0x8f608b88
                        v5 = v98;
                        int32_t v117 = mmc_set_drv_type((char *)v3, a2, v98, v11, v58, v14, 0); // 0x8f608b94
                        v59 = v117;
                        if (v117 != 0) {
                            // break -> 0x8f608ac4
                            break;
                        }
                        // continue -> 0x8f608b78
                        continue;
                    }
                    // 0x8f608d48
                    // branch -> 0x8f608dec
                    // 0x8f608dec
                    free(str);
                    // branch -> 0x8f608dfc
                    // 0x8f608dfc
                    *(char *)(v3 + 12) = 0;
                    *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
                    if (v4 != g23) {
                        // 0x8f608e28
                        __stack_chk_fail();
                        // branch -> 0x8f608e2c
                    }
                    // 0x8f608e2c
                    return (char *)1;
                }
                while (true) {
                    // 0x8f608ac4
                    v5 = 64;
                    memset((char *)&v13, 0, 64);
                    v8 = 0;
                    v63 = 0;
                    v64 = 0;
                    // branch -> 0x8f608ae4
                    goto lab_0x8f608ae4;
                }
            }
            // 0x8f608ba8
            v81 = v70;
            if (v59 != 0) {
                // 0x8f608bb0
                v5 = 0;
                mmc_set_drv_type((char *)v3, a2, 0, v11, v58, v14, 0);
                v81 = v8;
                // branch -> 0x8f608bc0
            }
            // 0x8f608bc0
            if (v81 == 0) {
                // 0x8f608d80
                // branch -> 0x8f608d44
            } else {
                // 0x8f608bc8
                v75 = &v78;
                memset((char *)&v12, 0, 1024);
                memset((char *)&v78, 0, 64);
                v80 = 0;
                if (v7 == 0) {
                    // 0x8f608bfc
                    v95 = *(int32_t *)(4 * v8 + v62 - 1164);
                    v80 = v95 == 15;
                    // branch -> 0x8f608c14
                }
                // 0x8f608c14
                v74 = 0;
                v71 = &v79;
                v76 = v71;
                v5 = 0;
                v90 = v71;
                v89 = 0;
                // branch -> 0x8f608c24
                while (true) {
                    // 0x8f608c24
                    v11 = v62;
                    v96 = *(int32_t *)(v90 - 4);
                    v94 = 4 * v89;
                    v6 = v94;
                    v73 = 1;
                    *(int32_t *)(4 * 16 * v89 + v62 - 1032) = v96;
                    v72 = (int32_t *)(v94 + v62 - 1096);
                    v86 = *v72 + 1;
                    v10 = v86;
                    *v72 = v86;
                    if (v73 != v8) {
                        goto lab_0x8f608c88;
                    }
                    // 0x8f608c5c
                    v82 = v8;
                    if (v82 > 14 && v82 != 15) {
                        // if_8f608c60_0_true
                        v83 = 0;
                        // branch -> after_if_8f608c60_0
                    } else {
                        // 0x8f608c5c
                        v83 = v80;
                        // branch -> after_if_8f608c60_0
                    }
                    // after_if_8f608c60_0
                    v84 = v83;
                    if (v82 == 15 || v82 <= 14) {
                        // if_8f608c64_0_true
                        v84 = v83 % 2;
                        // branch -> after_if_8f608c64_0
                    }
                    // after_if_8f608c64_0
                    if (v84 != 0) {
                        int32_t v118 = v78; // 0x8f608c70
                        v91 = v10;
                        int32_t v119 = 64 * v5; // 0x8f608c7c
                        if (v91 < 16) {
                            while (true) {
                                // 0x8f608ca8
                                v87 = (int32_t)&v77 + 4;
                                v88 = 1;
                                *(int32_t *)(v119 + 4 * v91 + v87) = *(int32_t *)v87;
                                if (v88 >= v118) {
                                    goto lab_0x8f608ca8;
                                }
                                // 0x8f608ca8
                                // branch -> 0x8f608cd0
                            }
                        }
                        // 0x8f608cd0
                        v11 = v62;
                        *(int32_t *)(v6 + v62 - 1096) = v78 + v91;
                        v78 = 0;
                        // branch -> 0x8f608cec
                    }
                    // 0x8f608cec
                    v93 = 0;
                    v92 = 0;
                    v85 = 0;
                    // branch -> 0x8f608cf8
                    while (true) {
                        // 0x8f608cf8
                        v97 = *(int32_t *)(4 * v85 + v75);
                        if (v97 > v92) {
                            goto lab_if_8f608d00_0_true_3;
                        }
                        goto lab_if_8f608d08_0_true_critedge_3;
                    }
                }
            }
            // 0x8f608d44
            print_log(-1, (int32_t)"Failed to get tuned phase\n", v5, v11, v58, v14, 0, n, v57, str2, v13, 0, 1);
            // branch -> 0x8f608d48
        }
    }
    // 0x8f608d48
    // branch -> 0x8f608dec
    // 0x8f608dec
    free(str);
    // branch -> 0x8f608dfc
    // 0x8f608dfc
    *(char *)(v3 + 12) = 0;
    *(char *)(*(int32_t *)(v3 + 40) + 8) = 1;
    if (v4 != g23) {
        // 0x8f608e28
        __stack_chk_fail();
        // branch -> 0x8f608e2c
    }
    // 0x8f608e2c
    return (char *)1;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:10:24
