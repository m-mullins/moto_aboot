//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t _fdt_check_prop_offset(int32_t a1);
int32_t add_panel_to_manager(int32_t * a1, int32_t a2, int32_t a3);
int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t arm_mmu_init(int32_t a1);
int32_t board_machtype(int32_t a1, int32_t a2, int32_t a3);
int32_t display_draw_screen_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t display_draw_screen_line_alignment(int32_t a1);
int32_t factory_mode(int32_t a1, int32_t a2, int32_t a3);
void function_8f67b680(void);
int32_t is_factory_mode(void);
int32_t is_validation_enabled(char * a1, int32_t a2);
int32_t load_and_validate_logo(void);
int32_t load_and_validate_oem_image(void);
int32_t mipi_mot_panel_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_panel_on(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_enable_enhanced_erase(void);
int32_t mmc_sdhci_enable_enhanced_erase(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_sdhci_get_wp_group_size(void);
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data(char * a1, char * a2);
int32_t mot_sst_oem_unlock_handler(void);
int32_t panel_manager_init(int32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_config_s3_source(uint32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_resin_status(int32_t a1, int32_t a2);
int32_t target_serialno(char * a1, int32_t a2);
int32_t validate_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t wait_queue_block(int32_t a1, int32_t a2);
int32_t wait_queue_init(int32_t * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R10
int32_t g23 = 0; // R11
int32_t g24 = 0; // R2
int32_t g25 = 0; // R3
int32_t g26 = 0; // R4
int32_t g27 = 0; // R5
int32_t g28 = 0; // R6
int32_t g29 = 0; // R7
int32_t g30 = 0; // R8
int32_t g31 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f61bf74
char * g2 = "\xff\xff\xff\xff\x6c\x6f\x61\x64\x5f\x61\x6e\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x65\x5f\x6b\x65\x72\x6e\x65\x6c\x5f\x69\x6d\x61\x67\x65"; // 0x8f6826be
char * g3 = "\n"; // 0x8f6ac1b0
int32_t g4 = 4; // 0x8f6acacc
int32_t g5 = 4; // 0x8f6acb18
int32_t g6 = 4; // 0x8f6acb30
int32_t g7 = -1; // 0x8f6affb0
int32_t g8 = 102; // 0x8f6affdc
int32_t g9 = 1; // 0x8f6b0044
char * g10; // 0x8f6b0070
int32_t g11 = 0; // 0x8f6bc000
char * g12; // 0x8f6e06ae
int32_t g13 = 0; // 0x8f6e06b4
int32_t g14 = 0; // 0x8f6e0c38
int32_t g15 = 0; // 0x8f7112f4
int32_t g16 = 0; // 0x8f7114ac
int32_t g17 = 0; // 0x8f711550
int32_t g18 = 0; // 0x8f711554

// ------------------------ Functions -------------------------

// Address range: 0x8f67234c - 0x8f672807
int32_t mot_sst_get_unlock_data(char * a1, char * a2) {
    int32_t str = (int32_t)a1;
    int32_t v1 = (int32_t)a2;
    int32_t v2 = &g15; // R3
    int32_t v3 = g26; // 0x8f672350
    int32_t v4 = g31; // 0x8f672350
    int32_t v5 = g15;
    int32_t v6 = 16; // bp-61
    if (a2 == NULL) {
        // 0x8f6727c0
        // branch -> 0x8f6727c4
        // 0x8f6727c4
        if (v5 != g15) {
            // 0x8f6727dc
            __stack_chk_fail();
            // branch -> 0x8f6727e0
        }
        // 0x8f6727e0
        g26 = v3;
        g31 = v4;
        return 255;
    }
    char * mem = malloc(str & -0x10000 | 2630); // 0x8f672378
    int32_t v7 = (int32_t)mem; // 0x8f672378_3
    int32_t v8 = v7; // R0
    g26 = v7;
    if (mem == NULL) {
        // if_8f672380_0_true
        *(char *)v1 = 1;
        // branch -> 0x8f6727c0
    } else {
        // 0x8f67238c
        if (str == 0) {
            // if_8f672390_0_true
            *(char *)v1 = 1;
            // branch -> 0x8f6724ac
        } else {
            // 0x8f67239c
            int32_t v9;
            mot_sst_pal_get_processor_uid((int32_t)&v9, v1, 16, v2);
            int32_t v10;
            int32_t v11;
            int32_t v12;
            int32_t v13;
            int32_t v14;
            int32_t v15;
            int32_t v16;
            int32_t v17;
            int32_t v18;
            if (dbval_read_partition(g26, v1 & -0x10000 || 2630, 16, v2, v18, v17, v16, v15, v14, v13, v12) == 0) {
                // 0x8f6723b8
                print_log(1, (int32_t)"read datablock error: %x\n", 255, v2, v18, v17, v16, v15, v14, v13, v12, v11, v10);
                // branch -> 0x8f672438
            } else {
                char v19 = *(char *)(g26 + 2); // 0x8f6723cc
                int32_t v20 = v19; // 0x8f6723cc
                v2 = v20;
                if (v19 == 0) {
                    char v21 = *(char *)(g26 + 3); // 0x8f6723d8
                    int32_t v22 = v21; // 0x8f6723d8
                    if (v21 == 1) {
                        // 0x8f6723e4
                        print_log(v22, (int32_t)"cid_get_cid_data: Version 1 datablock\n", 16, v20, v18, v17, v16, v15, v14, v13, v12, v11, v10);
                        int32_t v23 = g26 + 226; // R8
                        int32_t v24;
                        int32_t v25 = dbval_db_validate_gen_hdr(g26, 240, (int32_t)&v6, v2, v18, v17, v16, v15, v14, v13, v12, v11, v10, v24); // 0x8f672404
                        if (v25 != 15) {
                            // 0x8f672410
                            print_log(v22, (int32_t)"validate header error: %x\n", 255, v2, v18, v17, v16, v15, v14, v13, v12, v11, v10);
                            v2 = 4;
                            *(char *)v1 = 4;
                            // branch -> 0x8f672440
                        }
                        // 0x8f672440
                        int32_t v26;
                        int32_t v27;
                        int32_t v28;
                        if (dbval_validate_cert_chain(v23, 0, 0, v2, v18, v17, v16, v15, v14, v13, v12, v11, v10, v24, v28, v27, v26) != 15) {
                            // 0x8f672458
                            print_log(1, (int32_t)"validate cert chain error: %x\n", 255, v2, v18, v17, v16, v15, v14, v13, v12, v11, v10);
                            // branch -> 0x8f6724a4
                            // 0x8f6724a4
                            *(char *)v1 = 5;
                            // branch -> 0x8f6724ac
                            // 0x8f6724ac
                            free((char *)g26);
                            // branch -> 0x8f6727c0
                            // 0x8f6727c0
                            // branch -> 0x8f6727c4
                            // 0x8f6727c4
                            if (v5 != g15) {
                                // 0x8f6727dc
                                __stack_chk_fail();
                                // branch -> 0x8f6727e0
                            }
                            // 0x8f6727e0
                            g26 = v3;
                            g31 = v4;
                            return 255;
                        }
                        int32_t v29 = v23; // 0x8f672474
                        int32_t v30;
                        int32_t v31;
                        int32_t v32;
                        int32_t v33;
                        int32_t v34;
                        int32_t result; // 0x8f6727c8
                        if (dbval_validate_signature(g26, 98, g26 + 98, 128, v29, v17, v16, v15, v14, v13, v12, v11, v10, v24, v28, v27, v26, v34, v33, v32, v31, v30) == 15) {
                            int32_t v35 = (int32_t)*(char *)(g26 + 78); // R11
                            int32_t v36 = (int32_t)*(char *)(g26 + 79); // R10
                            g31 = (int32_t)*(char *)(g26 + 80);
                            v23 = (int32_t)*(char *)(g26 + 81);
                            char v37 = *(char *)(g26 + 82); // 0x8f6724c8
                            int32_t v38 = (int32_t)*(char *)(g26 + 83); // R12
                            v8 = (int32_t)*(char *)(g26 + 84);
                            int32_t v39 = (int32_t)*(char *)(g26 + 85); // R1
                            int32_t v40 = (int32_t)*(char *)(g26 + 86); // R2
                            char v41 = *(char *)(g26 + 47); // 0x8f6725b8
                            int32_t v42 = (int32_t)*(char *)(g26 + 46); // 0x8f6725bc
                            char v43 = *(char *)(g26 + 48); // 0x8f6725c4
                            char v44 = *(char *)(g26 + 49); // 0x8f6725cc
                            char v45 = *(char *)(g26 + 50); // 0x8f6725d4
                            char v46 = *(char *)(g26 + 51); // 0x8f6725dc
                            char v47 = *(char *)(g26 + 52); // 0x8f6725e4
                            char v48 = *(char *)(g26 + 53); // 0x8f6725ec
                            char v49 = *(char *)(g26 + 56); // 0x8f6725f4
                            char v50 = *(char *)(g26 + 57); // 0x8f6725fc
                            char v51 = *(char *)(g26 + 58); // 0x8f672604
                            char v52 = *(char *)(g26 + 59); // 0x8f67260c
                            char v53 = *(char *)(g26 + 60); // 0x8f672614
                            char v54 = *(char *)(g26 + 61); // 0x8f67261c
                            char v55 = *(char *)(g26 + 62); // 0x8f672624
                            char v56 = *(char *)(g26 + 63); // 0x8f67262c
                            char v57 = *(char *)(g26 + 64); // 0x8f672634
                            char v58 = *(char *)(g26 + 65); // 0x8f67263c
                            char v59 = *(char *)(g26 + 66); // 0x8f672644
                            char v60 = *(char *)(g26 + 67); // 0x8f67264c
                            char v61 = *(char *)(g26 + 68); // 0x8f672654
                            char v62 = *(char *)(g26 + 69); // 0x8f67265c
                            char v63 = *(char *)(g26 + 70); // 0x8f672664
                            char v64 = *(char *)(g26 + 71); // 0x8f67266c
                            char v65 = *(char *)(g26 + 72); // 0x8f672674
                            char v66 = *(char *)(g26 + 73); // 0x8f67267c
                            char v67 = *(char *)(g26 + 74); // 0x8f672684
                            char v68 = *(char *)(g26 + 75); // 0x8f67268c
                            char v69 = *(char *)(g26 + 87); // 0x8f6726c4
                            char v70 = *(char *)(g26 + 88); // 0x8f6726cc
                            char v71 = *(char *)(g26 + 89); // 0x8f6726d4
                            char v72 = *(char *)(g26 + 90); // 0x8f6726dc
                            char v73 = *(char *)(g26 + 91); // 0x8f6726e4
                            char v74 = *(char *)(g26 + 92); // 0x8f6726ec
                            char v75 = *(char *)(g26 + 93); // 0x8f6726f4
                            char v76 = *(char *)(g26 + 94); // 0x8f6726fc
                            char v77 = *(char *)(g26 + 95); // 0x8f672704
                            char v78 = *(char *)(g26 + 96); // 0x8f67270c
                            char v79 = *(char *)(g26 + 97); // 0x8f672714
                            char v80 = *(char *)(g26 + 8); // 0x8f67271c
                            char v81 = *(char *)(g26 + 9); // 0x8f672724
                            char v82 = *(char *)(g26 + 10); // 0x8f67272c
                            char v83 = *(char *)(g26 + 11); // 0x8f672734
                            char v84 = *(char *)(g26 + 12); // 0x8f67273c
                            char v85 = *(char *)(g26 + 13); // 0x8f672744
                            char v86 = *(char *)(g26 + 14); // 0x8f67274c
                            char v87 = *(char *)(g26 + 15); // 0x8f672754
                            char v88 = *(char *)(g26 + 16); // 0x8f67275c
                            char v89 = *(char *)(g26 + 17); // 0x8f672764
                            char v90 = *(char *)(g26 + 18); // 0x8f67276c
                            char v91 = *(char *)(g26 + 19); // 0x8f672774
                            char v92 = *(char *)(g26 + 20); // 0x8f67277c
                            char v93 = *(char *)(g26 + 21); // 0x8f672784
                            char v94 = *(char *)(g26 + 22); // 0x8f67278c
                            char v95 = *(char *)(g26 + 23); // 0x8f672794
                            snprintf((char *)str, 132, "%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X", v42, (int32_t)v41, (int32_t)v43, (int32_t)v44, (int32_t)v45, (int32_t)v46, (int32_t)v47, (int32_t)v48, (int32_t)v49, (int32_t)v50, (int32_t)v51, (int32_t)v52, (int32_t)v53, (int32_t)v54, (int32_t)v55, (int32_t)v56, (int32_t)v57, (int32_t)v58, (int32_t)v59, (int32_t)v60, (int32_t)v61, (int32_t)v62, (int32_t)v63, (int32_t)v64, (int32_t)v65, (int32_t)v66, (int32_t)v67, (int32_t)v68, v35, v36, g31, v23, (int32_t)v37, v38, v8, v39, v40, (int32_t)v69, (int32_t)v70, (int32_t)v71, (int32_t)v72, (int32_t)v73, (int32_t)v74, (int32_t)v75, (int32_t)v76, (int32_t)v77, (int32_t)v78, (int32_t)v79, (int32_t)v80, (int32_t)v81, (int32_t)v82, (int32_t)v83, (int32_t)v84, (int32_t)v85, (int32_t)v86, (int32_t)v87, (int32_t)v88, (int32_t)v89, (int32_t)v90, (int32_t)v91, (int32_t)v92, (int32_t)v93, (int32_t)v94, (int32_t)v95);
                            dbval_memset(g26, 0, (int32_t)"%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X#%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X" & -0x10000 | 2630, v42);
                            free((char *)g26);
                            result = 0;
                            // branch -> 0x8f6727c4
                        } else {
                            // 0x8f672490
                            print_log(1, (int32_t)"validate signature error: %x\n", 255, 128, v29, v17, v16, v15, v14, v13, v12, v11, v10);
                            // branch -> 0x8f6724a4
                            // 0x8f6724a4
                            *(char *)v1 = 6;
                            // branch -> 0x8f6724ac
                            // 0x8f6724ac
                            free((char *)g26);
                            // branch -> 0x8f6727c0
                            // 0x8f6727c0
                            result = 255;
                            // branch -> 0x8f6727c4
                        }
                        // 0x8f6727c4
                        if (v5 != g15) {
                            // 0x8f6727dc
                            __stack_chk_fail();
                            // branch -> 0x8f6727e0
                        }
                        // 0x8f6727e0
                        g26 = v3;
                        g31 = v4;
                        return result;
                    }
                }
                // 0x8f67242c
                print_log(1, (int32_t)"cid_get_cid_data: Version 0 datablock\n", 16, v20, v18, v17, v16, v15, v14, v13, v12, v11, v10);
                // branch -> 0x8f672438
            }
            // 0x8f672438
            // branch -> 0x8f6724a4
            // 0x8f6724a4
            v8 = g26;
            *(char *)v1 = 3;
            // branch -> 0x8f6724ac
        }
        // 0x8f6724ac
        free((char *)v8);
        // branch -> 0x8f6727c0
    }
    // 0x8f6727c0
    // branch -> 0x8f6727c4
    // 0x8f6727c4
    if (v5 != g15) {
        // 0x8f6727dc
        __stack_chk_fail();
        // branch -> 0x8f6727e0
    }
    // 0x8f6727e0
    g26 = v3;
    g31 = v4;
    return 255;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:56:15
