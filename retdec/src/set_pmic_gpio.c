//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t alloc_scm_command(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_pll_clock(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t panel_power_off(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t panel_power_on(int32_t a1, int32_t a2, int32_t a3);
int32_t parse_setting_list(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_arm_support_available(int32_t a1, int32_t a2, int32_t a3);
int32_t scm_call2(int32_t * a1, int32_t a2, int32_t a3);
char * scm_call2_atomic(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_a32(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t scm_call_atomic(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_atomic2(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_dload_mode(int32_t a1);
int32_t scm_init(int32_t a1);
char * scm_io_write(int32_t a1, int32_t a2, int32_t a3);
int32_t set_gpio(int32_t * a1, int32_t a2);
int32_t set_ldo(int32_t * a1, int32_t a2);
int32_t set_lvs(char * a1, int32_t a2);
int32_t set_pmic_gpio(char * a1, int32_t a2);
int32_t smc(int32_t a1, int32_t a2);
int32_t turn_off_backlight(int32_t a1, int32_t a2, int32_t a3);
int32_t turn_on_backlight(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g9 = 0; // LR
int32_t g10 = 0; // R0
int32_t g11 = 0; // R1
int32_t g12 = 0; // R11
int32_t g13 = 0; // R2
int32_t g14 = 0; // R3
int32_t g15 = 0; // R4
int32_t g16 = 0; // R5
int32_t g17 = 0; // R6
int32_t g18 = 0; // R7
int32_t g19 = 0; // R8
int32_t g1 = -1; // 0x8f6ac0d0
int32_t g2 = -1; // 0x8f6ac0d8
int32_t g3 = 0; // 0x8f6b8c84
int32_t (*g4)() = NULL; // 0x8f6b8c8c
int32_t (*g5)() = NULL; // 0x8f6b8c90
int32_t g6 = 0; // 0x8f7112f4
int32_t g7 = 0; // 0x8f7112fc
int32_t g8 = 0; // 0x8f711374

// ------------------------ Functions -------------------------

// Address range: 0x8f617c60 - 0x8f617d97
int32_t set_pmic_gpio(char * a1, int32_t a2) {
    // 0x8f617c60
    int32_t v1;
    int32_t v2 = v1; // bp-56
    int32_t v3 = &v2; // 0x8f617c6c_0
    int32_t v4 = g6;
    int32_t v5 = (int32_t)a1; // R4
    int32_t v6 = a2 == 0 ? (int32_t)"set" : (int32_t)"clear";
    int32_t v7 = *(int32_t *)a1; // 0x8f617c98
    int32_t v8;
    int32_t v9;
    int32_t v10;
    int32_t v11;
    int32_t v12;
    print_log(2, (int32_t)"%s pmic gpio: %d\n", v6, v7, v1, v12, v11, v10, v9, v8, 0, 0, 0);
    memset((char *)&v2, 0, 36);
    uint32_t v13 = *(int32_t *)(v5 + 28); // 0x8f617cb0
    v2 = 1;
    uint32_t v14 = v13 - 1; // 0x8f617cc4
    int32_t result2; // 0x8f617d58
    int32_t v15; // 0x8f617d68
    int32_t v16; // R0
    int32_t v17; // R3
    int32_t result; // 0x8f617d84_2
    int32_t v18; // 0x8f617d84_26
    int32_t v19;
    uint32_t v20; // 0x8f617d4c
    int32_t v21; // 0x8f617ce4
    int32_t v22; // 0x8f617ce4
    int32_t v23; // 0x8f617cf0
    int32_t v24; // 0x8f617cf8
    int32_t v25; // 0x8f617d08
    uint32_t v26; // 0x8f617d10
    int32_t v27; // 0x8f617d34
    int32_t v28; // 0x8f617d00
    char v29; // 0x8f617d3c
    int32_t v30; // 0x8f617d48
    int32_t v31; // 0x8f617d28
    int32_t v32; // 0x8f617d40
    if (v14 > 8) {
        // 0x8f617cd8
        if (v13 >= 10) {
            // 0x8f617ce0
            thread_sleep(v13, 0, 36, v14, 1, v12, v11, v10);
            // branch -> 0x8f617ce4
        }
        // 0x8f617ce4
        v21 = v5;
        v22 = *(int32_t *)(v21 + 4);
        v2 = v22;
        v23 = *(int32_t *)(v21 + 8);
        v24 = *(int32_t *)(v21 + 12);
        v25 = *(int32_t *)(v21 + 16);
        v26 = *(int32_t *)(v21 + 24);
        v19 = v26;
        if (a2 != 0) {
            // 0x8f617d18
            v19 = v26 > 1 ? 0 : 1 - v26;
            // branch -> 0x8f617d20
        }
        // 0x8f617d20
        v17 = v19;
        v31 = (int32_t)*(char *)v21;
        v27 = v19;
        if (v19 == 0) {
            // if_8f617d30_0_true
            v17 = 1;
            v27 = 1;
            // branch -> after_if_8f617d30_0
        }
        // after_if_8f617d30_0
        v28 = v19 == 0 ? v27 : *(int32_t *)(v21 + 20);
        pm8x41_gpio_config(v31, v3, 36, v27, v22, v25, v19, v23, v24, v28);
        v29 = *(char *)v5;
        v32 = 0x1000000 * v19 / 0x1000000;
        pm8x41_gpio_set((int32_t)v29, v32, 36, v17, v2, v25, v19, v23);
        v30 = *(int32_t *)(v5 + 32);
        v16 = v30;
        v20 = v30 - 1;
        if (v20 > 8) {
            // 0x8f617d60
            if (v30 >= 10) {
                // 0x8f617d68
                v15 = thread_sleep(v30, v32, 36, v20, v2, v25, v19, v23);
                v16 = v15;
                v18 = v15;
                // branch -> 0x8f617d6c
            } else {
                v18 = v30;
            }
        } else {
            // 0x8f617d58
            result2 = mdelay(v30, v32, 36, v20);
            v16 = result2;
            v18 = result2;
            // branch -> 0x8f617d6c
        }
        // 0x8f617d6c
        if (v4 != g6) {
            // 0x8f617d7c
            __stack_chk_fail();
            result = v16;
            // branch -> 0x8f617d80
        } else {
            result = v18;
        }
        // 0x8f617d80
        return result;
    }
    // 0x8f617cd0
    mdelay(v13, 0, 36, v14);
    // branch -> 0x8f617ce4
    // 0x8f617ce4
    v21 = v5;
    v22 = *(int32_t *)(v21 + 4);
    v2 = v22;
    v23 = *(int32_t *)(v21 + 8);
    v24 = *(int32_t *)(v21 + 12);
    v25 = *(int32_t *)(v21 + 16);
    v26 = *(int32_t *)(v21 + 24);
    v19 = v26;
    if (a2 != 0) {
        // 0x8f617d18
        v19 = v26 > 1 ? 0 : 1 - v26;
        // branch -> 0x8f617d20
    }
    // 0x8f617d20
    v17 = v19;
    v31 = (int32_t)*(char *)v21;
    v27 = v19;
    if (v19 == 0) {
        // if_8f617d30_0_true
        v17 = 1;
        v27 = 1;
        // branch -> after_if_8f617d30_0
    }
    // after_if_8f617d30_0
    v28 = v19 == 0 ? v27 : *(int32_t *)(v21 + 20);
    pm8x41_gpio_config(v31, v3, 36, v27, v22, v25, v19, v23, v24, v28);
    v29 = *(char *)v5;
    v32 = 0x1000000 * v19 / 0x1000000;
    pm8x41_gpio_set((int32_t)v29, v32, 36, v17, v2, v25, v19, v23);
    v30 = *(int32_t *)(v5 + 32);
    v16 = v30;
    v20 = v30 - 1;
    if (v20 <= 8) {
        // 0x8f617d58
        result2 = mdelay(v30, v32, 36, v20);
        // branch -> 0x8f617d6c
        // 0x8f617d6c
        if (v4 != g6) {
            // 0x8f617d7c
            __stack_chk_fail();
            // branch -> 0x8f617d80
        }
        // 0x8f617d80
        return result2;
    }
    // 0x8f617d60
    if (v30 >= 10) {
        // 0x8f617d68
        v15 = thread_sleep(v30, v32, 36, v20, v2, v25, v19, v23);
        v16 = v15;
        v18 = v15;
        // branch -> 0x8f617d6c
    } else {
        v18 = v30;
    }
    // 0x8f617d6c
    if (v4 != g6) {
        // 0x8f617d7c
        __stack_chk_fail();
        result = v16;
        // branch -> 0x8f617d80
    } else {
        result = v18;
    }
    // 0x8f617d80
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 21
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:34:22
