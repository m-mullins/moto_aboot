//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t board_machtype(int32_t a1, int32_t a2, int32_t a3);
int32_t disable_gpio_107_irq(int32_t a1);
int32_t disable_usbin_valid_irq(int32_t a1);
int32_t enable_charger_gone_irq(int32_t a1, int32_t a2);
int32_t enable_gpio_107_irq(void);
int32_t fdt_node_check_compatible(int32_t a1, int32_t a2, char * a3);
int32_t fdt_num_mem_rsv(int32_t a1);
int32_t fdt_path_offset(char * a1, char * str, int32_t a3);
int32_t fdt_subnode_offset_namelen(int32_t a1, int32_t a2, char * a3, int32_t n);
void function_8f64a450(void);
void function_8f64a49c(char * a1, int32_t a2, char * a3, int16_t * a4);
int32_t get_platform_name(void);
int32_t hab_hash_decision(char * a1, int32_t a2);
int32_t hab_mcs_hashSHA256(int32_t a1, int32_t * a2, int32_t * a3);
int32_t hab_write_to_register(int32_t a1, char * a2, int16_t * a3);
int32_t is_emu_charger_present(int32_t a1, int32_t a2, int32_t a3);
int32_t is_hv_charger_present(int32_t a1, int32_t a2);
int32_t mbm_fdt_find_node(int32_t a1, int32_t a2);
int32_t mdelay(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_disable(int32_t a1);
int32_t mdp_dma_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mmc_init(char * a1);
char * mmc_sd_set_hs(char * a1);
int32_t sdhci_set_bus_width(int32_t * a1, int32_t a2);
int32_t sdhci_set_uhs_mode(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t shutdown_device(void);
int32_t udelay(int32_t a1, int32_t a2, int32_t a3);
int32_t unit_modular_inverse(int64_t a1);

// --------------------- Global Variables ---------------------

int32_t g17 = 0; // LR
int32_t g18 = 0; // R0
int32_t g19 = 0; // R1
int32_t g20 = 0; // R2
int32_t g21 = 0; // R3
int32_t g22 = 0; // R4
int32_t g23 = 0; // R5
int32_t g24 = 0; // R6
int32_t g25 = 0; // R7
int32_t g26 = 0; // R8
int32_t g27 = 0; // R9
// Detected cryptographic pattern: SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t SHA256_Hash_constant_words_K__0x428a2f98__at_8f6a6c68[64] = {0x428a2f98, 0x71374491, -0x4a3f0431, -0x164a245b, 0x3956c25b, 0x59f111f1, -0x6dc07d5c, -0x54e3a12b, -0x27f85568, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, -0x7f214e02, -0x6423f959, -0x3e640e8c, -0x1b64963f, -0x1041b87a, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, -0x67c1aeae, -0x57ce3993, -0x4ffcd838, -0x40a68039, -0x391ff40d, -0x2a586eb9, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, -0x7e3d36d2, -0x6d8dd37b, -0x5d40175f, -0x57e599b5, -0x3db47490, -0x3893ae5d, -0x2e6d17e7, -0x2966f9dc, -0xbf1ca7b, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, -0x7b3787ec, -0x7338fdf8, -0x6f410006, -0x5baf9315, -0x41065c09, -0x398e870e}; // 0x8f6a6c68
int32_t g1 = -0x16d2bf8d; // 0x8f602e98
int32_t g2 = -0x16d2bfc9; // 0x8f64587c
int32_t g3 = 0; // 0x8f67dbd4
int32_t g4 = 1; // 0x8f67dc14
int32_t g5 = 100; // 0x8f67ea70
int32_t g6 = 0; // 0x8f67eaa8
int32_t g7 = 0x65440030; // 0x8f69c66f
char * g8 = "\n"; // 0x8f6afe00
int32_t g9 = 0; // 0x8f6b5040
char * g10; // 0x8f6b7c80
int32_t g11 = 0; // 0x8f6b7cc0
char * g12; // 0x8f6b7d00
int32_t g13 = 0; // 0x8f6b8ab4
int32_t g14 = 0; // 0x8f6b8ab8
int32_t g15 = 0; // 0x8f6e06a0
int32_t g16 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f671010 - 0x8f67120f
// Used cryptographic patterns:
//  - SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t hab_mcs_hashSHA256(int32_t a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = (int32_t)a2; // R3
    int32_t v3 = g22; // 0x8f671018
    int32_t v4 = g25; // 0x8f671018
    int32_t v5;
    int32_t v6 = &v5; // 0x8f671024_0
    g22 = v6;
    int32_t v7 = 0; // R1
    int32_t v8 = v6; // 0x8f671054
    int32_t v9 = a1; // 0x8f671038
    int32_t v10 = 0; // 0x8f671054
    // branch -> 0x8f671034
    while (true) {
        char v11 = *(char *)(v10 + a1); // 0x8f671034
        char v12 = *(char *)(v9 + 3); // 0x8f67103c
        char v13 = *(char *)(v9 + 1); // 0x8f671044
        char v14 = *(char *)(v9 + 2); // 0x8f67104c
        *(int32_t *)(v10 + v8) = 256 * (int32_t)v14 | 0x10000 * (int32_t)v13 | (int32_t)v12 | 0x1000000 * (int32_t)v11;
        int32_t v15 = v7 + 4; // 0x8f671058
        v7 = v15;
        if (v15 == 64) {
            int32_t v16 = 0; // 0x8f671078
            int32_t v17 = v6; // 0x8f67106c
            // branch -> 0x8f67106c
            while (true) {
                int32_t v18 = v17 + 4; // 0x8f67106c
                uint32_t v19 = *(int32_t *)v18; // 0x8f67106c
                int32_t v20 = *(int32_t *)(v17 + 36); // 0x8f671074
                int32_t v21 = *(int32_t *)(g22 + v16); // 0x8f671078
                int32_t v22 = v16 + 4; // 0x8f67107c
                uint32_t v23 = *(int32_t *)(v17 + 56); // 0x8f671080
                *(int32_t *)(v17 + 64) = ((0x8000 * v23 | v23 / 0x20000) ^ (0x2000 * v23 | v23 / 0x80000) ^ v23 / 1024) + v21 + v20 + ((0x2000000 * v19 | v19 / 128) ^ (0x4000 * v19 | v19 / 0x40000) ^ v19 / 8);
                if (v22 == 192) {
                    int32_t v24 = *(int32_t *)v2; // 0x8f6710b8
                    int32_t v25 = *(int32_t *)(v2 + 4); // 0x8f6710bc
                    g25 = v25;
                    int32_t v26 = *(int32_t *)(v2 + 8); // 0x8f6710c4
                    g22 = v26;
                    int32_t v27 = v24; // LR
                    int32_t v28 = *(int32_t *)(v2 + 16); // 0x8f6710cc
                    int32_t v29 = *(int32_t *)(v2 + 20); // 0x8f6710d0
                    int32_t v30 = *(int32_t *)(v2 + 24); // 0x8f6710d4
                    int32_t v31 = *(int32_t *)(v2 + 28); // 0x8f671144
                    int32_t v32 = 0; // 0x8f671118
                    int32_t v33 = *(int32_t *)(v2 + 12); // 0x8f6711601
                    int32_t v34 = v24; // 0x8f671170
                    // branch -> 0x8f6710e4
                    while (true) {
                        int32_t v35 = *(int32_t *)(v32 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_8f6a6c68); // 0x8f671104
                        int32_t v36 = *(int32_t *)(v32 + v6); // 0x8f671118
                        int32_t v37 = v32 + 4; // 0x8f67111c
                        v7 = v37;
                        int32_t v38 = (v28 & v29 ^ v30 & -1 - v28) + v31 + v35 + ((0x4000000 * v28 | v28 / 64) ^ (0x200000 * v28 | v28 / 2048) ^ (128 * v28 | v28 / 0x2000000)) + v36; // 0x8f671144
                        int32_t v39 = v38 + v33; // 0x8f67114c
                        int32_t v40 = v39; // R11
                        int32_t v41 = v38 + ((0x40000000 * v34 | v34 / 4) ^ (0x80000 * v34 | v34 / 0x2000) ^ (1024 * v34 | v34 / 0x400000)) + ((v26 ^ v34) & v25 ^ v26 & v34); // 0x8f671154
                        if (v37 == 256) {
                            // 0x8f671180
                            *a3 = v41 + v24;
                            int32_t v42 = *(int32_t *)(v2 + 4); // 0x8f67118c
                            *(int32_t *)(v1 + 4) = v27 + v42;
                            int32_t v43 = g25 + *(int32_t *)(v2 + 8); // 0x8f67119c
                            g25 = v43;
                            *(int32_t *)(v1 + 8) = v43;
                            int32_t v44 = g22 + *(int32_t *)(v2 + 12); // 0x8f6711a8
                            g22 = v44;
                            *(int32_t *)(v1 + 12) = v44;
                            int32_t v45 = *(int32_t *)(v2 + 16); // 0x8f6711b0
                            *(int32_t *)(v1 + 16) = v40 + v45;
                            *(int32_t *)(v1 + 20) = v28 + *(int32_t *)(v2 + 20);
                            *(int32_t *)(v1 + 24) = v29 + *(int32_t *)(v2 + 24);
                            *(int32_t *)(v1 + 28) = v30 + *(int32_t *)(v2 + 28);
                            bzero((char *)&v5, v7);
                            // 0x8f671200
                            g22 = v3;
                            g25 = v4;
                            return 0;
                        }
                        // 0x8f67115c
                        g22 = v25;
                        g25 = v34;
                        v27 = v41;
                        v31 = v29;
                        v30 = v28;
                        v29 = v39;
                        v28 = v39;
                        v32 = v37;
                        v33 = v26;
                        v26 = v25;
                        v25 = v34;
                        v34 = v41;
                        // branch -> 0x8f6710e4
                    }
                } else {
                    // 0x8f67106c
                    v16 = v22;
                    v17 = v18;
                    // branch -> 0x8f67106c
                    continue;
                }
            }
        } else {
            // 0x8f671034
            v8 = g22;
            v9 += 4;
            v10 = v15;
            // branch -> 0x8f671034
            continue;
        }
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void bzero(void * s, size_t n);
// void * malloc(size_t size);
// void * memchr(void * s, int c, size_t n);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// char * strchr(char * s, int c);
// size_t strlen(const char * s);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 28
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:26:23
