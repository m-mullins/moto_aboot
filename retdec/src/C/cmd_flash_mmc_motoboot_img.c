//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t cid_get_cid_data(char * a1);
int32_t cid_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t cmd_flash_mmc_motoboot_img(int32_t * a1);
int32_t cmd_flash_mmc_sparse_img(int32_t a1, int32_t a2);
int32_t display_get_image_location(void);
int32_t display_get_logo_size(int32_t a1, int32_t a2);
int32_t event_init(int32_t * a1, char a2, int32_t a3);
int32_t event_wait_timeout(int32_t a1, int32_t a2);
int32_t get_current_secure_state(int32_t a1, int32_t a2);
int32_t get_entry_name(int32_t a1, int32_t a2);
int32_t get_panel_info(int32_t * a1, int32_t a2, uint32_t a3);
int32_t hab_install_super_root_key(char * a1, int32_t a2);
int32_t hab_mcs_ctx_init_hash(void);
int32_t is_warranty_void(int32_t a1);
int32_t mdelay(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_clock_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_clock_enable(void);
int32_t mipi_dsi_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_on(int32_t a1, int32_t a2);
int32_t mot_sst_pal_delete_user_partition(int32_t a1, int32_t a2);
int32_t mot_sst_pal_set_sbd_en_otp_bit(int32_t a1, int32_t a2);
int32_t panel_common_init(void);
int32_t partition_get_name(int32_t a1, int32_t a2);
void platform_fiq(void);
int32_t platform_irq(int32_t a1, int32_t a2);
int32_t qtimer_uninit(void);
int32_t target_cpu(void);
int32_t target_uninit(int32_t a1, int32_t a2, int32_t a3);
int32_t thread_create(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t thread_exit(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g40 = 0; // LR
int32_t g41 = 0; // R0
int32_t g42 = 0; // R1
int32_t g43 = 0; // R10
int32_t g44 = 0; // R11
int32_t g45 = 0; // R2
int32_t g46 = 0; // R3
int32_t g47 = 0; // R4
int32_t g48 = 0; // R5
int32_t g49 = 0; // R6
int32_t g50 = 0; // R7
int32_t g51 = 0; // R8
int32_t g52 = 0; // R9
int32_t g1 = -0x1a60df68; // 0x8f61b3e8
int32_t g2 = 0x65440030; // 0x8f69c66f
int32_t g3 = 0x1010000; // 0x8f6a6b09
int32_t g4 = 0x40402014; // 0x8f6a6c1c
int32_t g5 = 0x6a6ba040; // 0x8f6a6c1f
int32_t g6 = 1; // 0x8f6ac0f0
int32_t g7 = 4; // 0x8f6acabc
int32_t g9 = 0xffff; // 0x8f6acae4
int32_t g10 = 0xffff; // 0x8f6acaec
int32_t g11 = 0xffff; // 0x8f6acb2c
int32_t g12 = -0x7fc8ffff; // 0x8f6acb50
int32_t g13 = 0xffff; // 0x8f6acb6c
int16_t * g14 = (int16_t *)0xffff; // 0x8f6affa4
char * g15; // 0x8f6b5000
int32_t g16 = 0; // 0x8f6b503f
int32_t g17 = 0; // 0x8f6b8ab4
int32_t g18 = 0; // 0x8f6c0164
int32_t g19 = 0; // 0x8f6c0168
char * g20; // 0x8f6c03bc
int32_t g21 = 0; // 0x8f6e0c38
int32_t g22 = 0; // 0x8f6e1310
int32_t g23 = 0; // 0x8f6e9400
char * g24; // 0x8f70da97
int32_t g25 = 0; // 0x8f70da98
char * g26; // 0x8f70da99
int32_t g27 = 0; // 0x8f70da9a
char * g28; // 0x8f70da9b
char * g29; // 0x8f710a25
int32_t g30 = 0; // 0x8f7112dc
int32_t g31 = 0; // 0x8f7112f4
int32_t g32 = 0; // 0x8f7114ac
int32_t g33 = 0; // 0x8f7125ec
char * g34; // 0x8f712e1c
char * g35; // 0x8f712e20
int16_t g36 = 0; // 0x8f712e24
int16_t g37 = 0; // 0x8f712e26
int32_t g38 = 0; // 0x8f712e28
char * g39; // 0x8f712e2c
int32_t * g8 = &g12; // 0x8f6acac0

// ------------------------ Functions -------------------------

// Address range: 0x8f6228c8 - 0x8f622e0b
int32_t cmd_flash_mmc_motoboot_img(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    g41 = v1;
    int32_t v2 = g47; // 0x8f6228cc
    int32_t v3 = g48; // 0x8f6228cc
    int32_t v4 = g31;
    g51 = v1;
    target_cpu();
    int32_t v5;
    int32_t v6;
    int32_t v7;
    int32_t v8;
    int32_t v9;
    int32_t v10;
    int32_t v11;
    print_log(2, (int32_t)"start flashing motoboot image\n", g45, v4, v8, v7, v6, 0, 0, v5, v11, v10, v9);
    g42 = (int32_t)"MBOOTV1";
    int32_t v12 = 0; // 0x8f62292c
    if (strcmp((char *)(g51 + 644), "MBOOTV1") != 0) {
        // 0x8f622908
        g42 = (int32_t)"Legacy motoboot detected";
        print_log(1, (int32_t)"Legacy motoboot detected", g45, v4, v8, v7, v6, 0, 0, v5, v11, v10, v9);
        v12 = 1;
        // branch -> 0x8f622918
    }
    // 0x8f622918
    g44 = &g33;
    g48 = 0;
    g52 = (int32_t)&g20;
    int32_t v13 = g51; // 0x8f622924
    g50 = 0;
    if (*(int32_t *)v13 == 0) {
        int32_t v14 = v13 + 1024; // 0x8f622940
        int32_t v15 = 0; // 0x8f622940
        int32_t v16 = 0; // 0x8f622978
        char * v17 = (char *)v5;
        int32_t v18;
        char * v19 = (char *)v18;
        int32_t v20;
        char * v21 = (char *)v20;
        // branch -> 0x8f62293c
        while (true) {
            int32_t v22 = 32 * v16 + v13; // 0x8f62293c
            g49 = v15 + v14;
            g47 = v22 + 4;
            int32_t v23 = *(int32_t *)(v22 + 32); // 0x8f62294c
            g48 = v23;
            int32_t v24 = v23 + 1 - *(int32_t *)(v22 + 28); // 0x8f62295c
            g48 = v24;
            int32_t v25 = *(int32_t *)(g33 + 8); // 0x8f622964
            g48 = v25 * v24;
            int32_t v26; // 0x8f622d2411
            int32_t v27; // 0x8f622d2413
            int32_t v28; // 0x8f622d2415
            int32_t v29; // 0x8f622d74183
            int32_t v30; // 0x8f622d2417
            int32_t v31; // 0x8f622d2419
            int32_t v32; // 0x8f622d4025
            int32_t v33; // 0x8f622d403
            int32_t v34; // 0x8f622d406
            int32_t str2; // R10
            int32_t v35;
            int32_t v36;
            int32_t v37;
            int32_t v38;
            char * v39;
            char * v40;
            int32_t v41;
            char * v42;
            int32_t v43; // 0x8f622930
            int32_t v44; // 0x8f622d4c9
            int32_t v45; // 0x8f622d6c
            if (v12 == 0) {
                int32_t str = v13 + 656 + 12 * v16; // 0x8f62297c
                str2 = str;
                if (strcmp((char *)str, "HABSIG") != 0) {
                    // 0x8f622990
                    if (strstr((char *)&g15, (char *)str2) == NULL) {
                        // 0x8f6229a4
                        g42 = (int32_t)"Image/MSM ID mismatch - Skip flashing";
                        v29 = print_log(1, (int32_t)"Image/MSM ID mismatch - Skip flashing", g45, v25, v8, v7, v6, 0, 0, (int32_t)v17, v11, v10, v9);
                        v32 = v8;
                        v44 = v11;
                        v31 = v35;
                        v30 = v36;
                        v39 = v21;
                        v28 = v37;
                        v40 = v19;
                        v27 = v38;
                        v26 = v9;
                        v41 = v10;
                        v42 = v17;
                        v34 = v6;
                        v33 = v7;
                        // branch -> 0x8f622d68
                      lab_0x8f622d68_2:
                        // 0x8f622d68
                        v45 = (g50 + 1) % 256;
                        g50 = v45;
                        v43 = g51;
                        if (v45 < *(int32_t *)v43) {
                            // 0x8f622d74
                            clear_flash_fail(v29, g42, g45);
                            // branch -> 0x8f622d7c
                            // 0x8f622d7c
                            if (v4 != g31) {
                                // 0x8f622d90
                                __stack_chk_fail();
                                // branch -> 0x8f622d94
                            }
                            // 0x8f622d94
                            g47 = v2;
                            g48 = v3;
                            return 1;
                        }
                      lab_0x8f622d68_3:
                        // 0x8f622d68
                        v14 = g49;
                        v15 = g48;
                        v13 = v43;
                        v16 = v45;
                        v7 = v33;
                        v6 = v34;
                        v17 = v42;
                        v11 = v44;
                        v10 = v41;
                        v9 = v26;
                        v38 = v27;
                        v19 = v40;
                        v37 = v28;
                        v21 = v39;
                        v36 = v30;
                        v35 = v31;
                        v8 = v32;
                        // branch -> 0x8f62293c
                        continue;
                    }
                }
            }
            int32_t v46 = (int32_t)v17;
            print_log(2, (int32_t)"Handling motoboot image: %s...\n", g47, v25, v8, v7, v6, 0, 0, v46, v11, v10, v9);
            int32_t len = strlen("partition"); // 0x8f6229c8
            str2 = len;
            int32_t v47; // 0x8f6229e8
            if (memcmp((char *)g47, "partition", len) == 0) {
                int32_t v48 = g47; // 0x8f6229e8
                int32_t v49 = str2 + v48; // 0x8f6229e8
                char v50 = *(char *)v49; // 0x8f6229e8
                v47 = v50;
                int32_t v51; // 0x8f622a7c
                int32_t v52; // 0x8f622a78
                if (v50 == 0) {
                    // 0x8f622a34
                    g45 = v48;
                    fboot_info((int32_t)"INFO", (int32_t)"flashing %s ...", v48, v47, v8, v7, v6, 0, 0, v46, v11);
                    fboot_info((int32_t)"INFO", (int32_t)"This may take a few seconds if a", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                    fboot_info((int32_t)"INFO", (int32_t)"different partition table is being", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                    fboot_info((int32_t)"INFO", (int32_t)"flashed since we need to backup", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                    fboot_info((int32_t)"INFO", (int32_t)"and restore a few partitions", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                    v52 = g49;
                    g42 = v52;
                    v51 = write_gpt(g48, v52, g45, v47, v8, v7, v6, 0, 0, v46, v11, v10, v9, v38, 0, (int32_t)v19, v37, (int32_t)v21, v12, (int32_t)&g15, v36, v35, 0, v4, 0);
                    if (v51 == 0) {
                        goto lab_0x8f622a88;
                    }
                    // 0x8f622ad0
                    // branch -> 0x8f622d3c
                    // 0x8f622d3c
                    fboot_info((int32_t)"INFO", (int32_t)"Failed to flash %s", g47, v47, v8, v7, v6, 0, 0, (int32_t)v17, v11);
                    // branch -> 0x8f622d7c
                    // 0x8f622d7c
                    if (v4 != g31) {
                        // 0x8f622d90
                        __stack_chk_fail();
                        // branch -> 0x8f622d94
                    }
                    // 0x8f622d94
                    g47 = v2;
                    g48 = v3;
                    return 3;
                }
                int32_t str_as_i = atoi((char *)(v49 + 1)); // 0x8f6229fc
                int32_t v53 = *(int32_t *)(g33 + 40); // 0x8f622a08
                v47 = v53;
                if (str_as_i != v53) {
                    // 0x8f622a14
                    print_log(1, (int32_t)"Found incorrect gpt for hardware, ignoring...\n", (int32_t)&g33, v53, v8, v7, v6, 0, 0, v46, v11, v10, v9);
                    g42 = (int32_t)"skipping %s (eMMC size mismatch)";
                    int32_t v54 = g47; // 0x8f622a28
                    g45 = v54;
                    v29 = fboot_info((int32_t)"INFO", (int32_t)"skipping %s (eMMC size mismatch)", v54, v47, v8, v7, v6, 0, 0, v46, v11);
                    v32 = v8;
                    v44 = v11;
                    v31 = v35;
                    v30 = v36;
                    v39 = v21;
                    v28 = v37;
                    v40 = v19;
                    v27 = v38;
                    v26 = v9;
                    v41 = v10;
                    v42 = v17;
                    v34 = v6;
                    v33 = v7;
                    // branch -> 0x8f622d68
                    goto lab_0x8f622d68_2;
                  lab_0x8f622d68_5:
                    // 0x8f622d68
                    v45 = (g50 + 1) % 256;
                    g50 = v45;
                    v43 = g51;
                    if (v45 >= *(int32_t *)v43) {
                        goto lab_0x8f622d68_3;
                    }
                    // 0x8f622d74
                    clear_flash_fail(v29, g42, g45);
                    // branch -> 0x8f622d7c
                    // 0x8f622d7c
                    if (v4 != g31) {
                        // 0x8f622d90
                        __stack_chk_fail();
                        // branch -> 0x8f622d94
                    }
                    // 0x8f622d94
                    g47 = v2;
                    g48 = v3;
                    return 1;
                }
                // 0x8f6229f8
                v48 = g47;
                // branch -> 0x8f622a34
                // 0x8f622a34
                g45 = v48;
                fboot_info((int32_t)"INFO", (int32_t)"flashing %s ...", v48, str_as_i, v8, v7, v6, 0, 0, v46, v11);
                fboot_info((int32_t)"INFO", (int32_t)"This may take a few seconds if a", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                fboot_info((int32_t)"INFO", (int32_t)"different partition table is being", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                fboot_info((int32_t)"INFO", (int32_t)"flashed since we need to backup", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                fboot_info((int32_t)"INFO", (int32_t)"and restore a few partitions", g45, v47, v8, v7, v6, 0, 0, v46, v11);
                v52 = g49;
                g42 = v52;
                v51 = write_gpt(g48, v52, g45, v47, v8, v7, v6, 0, 0, v46, v11, v10, v9, v38, 0, (int32_t)v19, v37, (int32_t)v21, v12, (int32_t)&g15, v36, v35, 0, v4, 0);
                if (v51 == 0) {
                  lab_0x8f622a88:;
                    int32_t v55 = __utags_invalidate(0, g42, g45, v47, v8, v7, v6, 0, 0, v46); // 0x8f622a88
                    v29 = sod_init(v55, g42, g45, v47, v8, v7, v6, 0, 0, v46, v11, v10, v9, v38, 0);
                    v32 = v8;
                    v44 = v11;
                    v31 = v35;
                    v30 = v36;
                    v39 = v21;
                    v28 = v37;
                    v40 = v19;
                    v27 = v38;
                    v26 = v9;
                    v41 = v10;
                    v42 = v17;
                    v34 = v6;
                    v33 = v7;
                    // branch -> 0x8f622d68
                    goto lab_0x8f622d68_2;
                } else {
                    // 0x8f622ad0
                    // branch -> 0x8f622d3c
                    // 0x8f622d3c
                    fboot_info((int32_t)"INFO", (int32_t)"Failed to flash %s", g47, v47, v8, v7, v6, 0, 0, (int32_t)v17, v11);
                    // branch -> 0x8f622d7c
                }
                // 0x8f622d7c
                if (v4 != g31) {
                    // 0x8f622d90
                    __stack_chk_fail();
                    // branch -> 0x8f622d94
                }
                // 0x8f622d94
                g47 = v2;
                g48 = v3;
                return 3;
            }
            int32_t v56 = g47; // 0x8f622a98
            g45 = v56;
            fboot_info((int32_t)"INFO", (int32_t)"flashing %s ...", v56, v25, v8, v7, v6, 0, 0, v46, v11);
            int32_t v57 = g47; // 0x8f622ab0
            if (is_sparse_image(g49, (int32_t)"flashing %s ...", v56, v25) == 0) {
                int32_t v58 = g49; // 0x8f622ab8
                g42 = v58;
                int32_t v59 = g48; // 0x8f622abc
                g45 = v59;
                int32_t v60 = flash_partition(v57, v58, v59, 0, v8, v7, v6, 0, 0, v46, v11, v10, v9, v38, 0, (int32_t)v19); // 0x8f622ac4
                if (v60 != -1) {
                    v29 = v60;
                    v32 = v8;
                    v44 = v11;
                    v31 = v35;
                    v30 = v36;
                    v39 = v21;
                    v28 = v37;
                    v40 = v19;
                    v27 = v38;
                    v26 = v9;
                    v41 = v10;
                    v42 = v17;
                    v34 = v6;
                    v33 = v7;
                    goto lab_0x8f622d68_5;
                }
                // 0x8f622ad0
                // branch -> 0x8f622d3c
                // 0x8f622d3c
                fboot_info((int32_t)"INFO", (int32_t)"Failed to flash %s", g47, 0, v8, v7, v6, 0, 0, (int32_t)v17, v11);
                // branch -> 0x8f622d7c
                // 0x8f622d7c
                if (v4 != g31) {
                    // 0x8f622d90
                    __stack_chk_fail();
                    // branch -> 0x8f622d94
                }
                // 0x8f622d94
                g47 = v2;
                g48 = v3;
                return 3;
            }
            // 0x8f622adc
            g43 = (int32_t)get_partition_by_name(v57, (int32_t)"flashing %s ...", v56, v25, v8, v7, v6, 0, 0, v46, v11);
            int32_t v61 = partition_get_offset(partition_get_index(g47, (int32_t)"flashing %s ...", v56, v25, v8, v7), (int32_t)"flashing %s ...", v56); // 0x8f622aec
            int32_t v62 = v61 | (int32_t)"flashing %s ..."; // 0x8f622af0
            v47 = v62;
            if (v61 == (int32_t)"flashing %s ...") {
                // 0x8f622afc
                print_log(0, (int32_t)"Unable to find partition \"%s\"\n", g47, v62, v8, v7, v6, 0, 0, v46, v11, v10, v9);
                // branch -> 0x8f622d3c
                // 0x8f622d3c
                fboot_info((int32_t)"INFO", (int32_t)"Unable to find partition \"%s\"\n", g47, v47, v8, v7, v6, 0, 0, (int32_t)v17, v11);
                // branch -> 0x8f622d7c
                // 0x8f622d7c
                if (v4 != g31) {
                    // 0x8f622d90
                    __stack_chk_fail();
                    // branch -> 0x8f622d94
                }
                // 0x8f622d94
                g47 = v2;
                g48 = v3;
                return 3;
            }
            int32_t v63 = g48; // 0x8f622b1c
            g42 = v63;
            int32_t v64 = parse_sparse_image(g49, v63, v56, v62, v8, v7, v6, 0, 0, v46, v11, v10, v9, v38, 0, (int32_t)v19, v61, (int32_t)"flashing %s ..."); // 0x8f622b20
            g41 = v64;
            *(int32_t *)g52 = v64;
            if (v64 == 0) {
                // 0x8f622b30
                print_log(5, (int32_t)"Invalid sparse image %s", g47, v47, v8, v7, v6, 0, 0, v46, v11, v10, v9);
                // branch -> 0x8f622d3c
                // 0x8f622d3c
                fboot_info((int32_t)"INFO", (int32_t)"Invalid sparse image %s", g47, v47, v8, v7, v6, 0, 0, (int32_t)v17, v11);
                // branch -> 0x8f622d7c
                // 0x8f622d7c
                if (v4 != g31) {
                    // 0x8f622d90
                    __stack_chk_fail();
                    // branch -> 0x8f622d94
                }
                // 0x8f622d94
                g47 = v2;
                g48 = v3;
                return 3;
            }
            int32_t v65 = *(int32_t *)(v64 + 8); // 0x8f622b4c
            g46 = v65;
            g40 = -0x709dd4ac;
            ((int32_t (*)(int32_t))v65)(v65);
            char * v66 = (char *)v64;
            int32_t v67 = (int32_t)g20;
            g41 = v67;
            int32_t v68 = *(int32_t *)(v67 + 4); // 0x8f622b80
            g46 = v68;
            g40 = -0x709dd478;
            ((int32_t (*)(int32_t, int32_t))v68)(v67, v68);
            int32_t v69 = g41; // 0x8f622b88
            g46 = v69;
            char * v70 = g20;
            int32_t v71 = (int32_t)v70;
            g41 = v71;
            int32_t v72 = *(int32_t *)v70; // 0x8f622b90
            g45 = v72;
            g40 = -0x709dd464;
            ((int32_t (*)(int32_t, int32_t, int32_t))v72)(v71, v72, v69);
            int32_t v73 = g43; // 0x8f622ba0
            char v74 = *(char *)(v73 + 40); // 0x8f622ba0
            int32_t v75 = g41 * v69; // 0x8f622ba4
            char v76 = *(char *)(v73 + 41); // 0x8f622bb0
            char v77 = *(char *)(v73 + 42); // 0x8f622bbc
            char v78 = *(char *)(v73 + 43); // 0x8f622bc4
            int32_t v79 = 0x1000000 * (int32_t)v78 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | (int32_t)v74; // 0x8f622bc8
            char v80 = *(char *)(v73 + 45); // 0x8f622bcc
            char v81 = *(char *)(v73 + 44); // 0x8f622bd0
            uint32_t v82 = v79 + 1; // 0x8f622bd4
            char v83 = *(char *)(v73 + 46); // 0x8f622bdc
            char v84 = *(char *)(v73 + 47); // 0x8f622be4
            char v85 = *(char *)(v73 + 33); // 0x8f622bec
            char v86 = *(char *)(v73 + 32); // 0x8f622bf0
            char v87 = *(char *)(v73 + 34); // 0x8f622bfc
            char v88 = *(char *)(v73 + 35); // 0x8f622c04
            int32_t v89 = 0x1000000 * (int32_t)v88 | 0x10000 * (int32_t)v87 | (int32_t)v86 | 256 * (int32_t)v85; // 0x8f622c08
            char v90 = *(char *)(v73 + 37); // 0x8f622c10
            char v91 = *(char *)(v73 + 36); // 0x8f622c14
            char v92 = *(char *)(v73 + 38); // 0x8f622c1c
            int32_t v93 = 0x10000 * (int32_t)v92 | (int32_t)v91 | 256 * (int32_t)v90; // 0x8f622c20
            int32_t v94 = 0x1000000 * (int32_t)*(char *)(v73 + 39) | v93; // 0x8f622c28
            uint32_t v95 = v82 - v89; // 0x8f622c34
            int32_t v96 = 512 * ((int32_t)(v82 < v89) + (0x1000000 * (int32_t)v84 | 0x10000 * (int32_t)v83 | (int32_t)v81 | 256 * (int32_t)v80) + (int32_t)(v79 == -1) - v93) | v95 / 0x800000; // 0x8f622c40
            int32_t v97 = 512 * v95; // 0x8f622c44
            if (v75 > v97 && v96 == 0) {
                // 0x8f622c64
                print_log(5, (int32_t)"Image is too large %s", g47, 0, v8, v7, v6, 0, 0, v69, v89, v94, v97);
                // branch -> 0x8f622d3c
                // 0x8f622d3c
                fboot_info((int32_t)"INFO", (int32_t)"Image is too large %s", g47, 0, v8, v7, v6, 0, 0, (int32_t)(char *)v69, v89);
                // branch -> 0x8f622d7c
            } else {
                char v98 = *v66; // 0x8f622c88
                int32_t v99 = v98; // 0x8f622c88
                if (v98 == 2) {
                    int32_t v100 = g47; // 0x8f622cc8
                    g45 = v100;
                    print_log(1, (int32_t)"skip erase partition %s\n", v100, v99, v8, v7, v6, 0, 0, v69, v89, v94, v97);
                    // branch -> 0x8f622d4c
                } else {
                    int32_t v101 = g47; // 0x8f622c98
                    g45 = v101;
                    print_log(1, (int32_t)"first sparse flash cmd, erase partition %s\n", v101, v99, v8, v7, v6, 0, 0, v69, v89, v94, v97);
                    if (erase_partition(g47, (int32_t)"first sparse flash cmd, erase partition %s\n", v101, v99, v8, v7, v6) == -1) {
                        // 0x8f622cb0
                        print_log(0, (int32_t)"Failed to erase partition %s\n", g47, v99, v8, v7, v6, 0, 0, v69, v89, v94, v97);
                        // branch -> 0x8f622d7c
                        // 0x8f622d7c
                        if (v4 != g31) {
                            // 0x8f622d90
                            __stack_chk_fail();
                            // branch -> 0x8f622d94
                        }
                        // 0x8f622d94
                        g47 = v2;
                        g48 = v3;
                        return 3;
                    }
                }
                int32_t v102 = g48; // 0x8f622d4c
                g42 = 0;
                // branch -> 0x8f622ce0
                int32_t v103; // 0x8f622d0c
                char * v104;
                while (true) {
                    int32_t v105 = (int32_t)g20;
                    g41 = v105;
                    int32_t v106 = *(int32_t *)(v105 + 12); // 0x8f622ce4
                    g46 = v106;
                    g40 = -0x709dd314;
                    ((int32_t (*)(int32_t, int32_t))v106)(v105, v106);
                    int32_t v107 = g41; // 0x8f622cec
                    v104 = (char *)v107;
                    char * v108 = g20;
                    int32_t v109 = (int32_t)v108;
                    g41 = v109;
                    int32_t v110 = *(int32_t *)v108; // 0x8f622cf4
                    g46 = v110;
                    g40 = -0x709dd300;
                    ((int32_t (*)(int32_t, int32_t))v110)(v109, v110);
                    v103 = v104 > (char *)1 ? 0 : 1 - v107;
                    g45 = v61;
                    int32_t v111 = g41; // 0x8f622d1c
                    g42 = v111;
                    int32_t v112 = (int32_t)v66;
                    int32_t v113 = flash_sparse_data(v112, v111, v61, (int32_t)"flashing %s ...", v102, 0, v103, 0, 0, v107, v102, 0, v97, v96, 0, v112, v61, (int32_t)"flashing %s ...", v12, (int32_t)&g15, v75, 0, 0, v4, 0); // 0x8f622d24
                    if (v113 == 0) {
                        // 0x8f622cd4
                        if (v107 == 0) {
                            // break -> 0x8f622d5c
                            break;
                        }
                        v66 = v104;
                        // continue -> 0x8f622ce0
                        continue;
                    } else {
                        // 0x8f622d34
                        // branch -> 0x8f622d3c
                        // 0x8f622d3c
                        fboot_info((int32_t)"INFO", (int32_t)"Failed to flash sparse image %s", g47, (int32_t)"flashing %s ...", v102, 0, v103, 0, 0, (int32_t)v104, v102);
                        // branch -> 0x8f622d7c
                    }
                    // 0x8f622d7c
                    if (v4 != g31) {
                        // 0x8f622d90
                        __stack_chk_fail();
                        // branch -> 0x8f622d94
                    }
                    // 0x8f622d94
                    g47 = v2;
                    g48 = v3;
                    return 3;
                }
                // 0x8f622d5c
                int32_t v114;
                int32_t v115 = free_sparse_image((int32_t)g20, g42, g45, (int32_t)&g20, v114, 0, 0); // 0x8f622d64
                v29 = v115;
                v32 = v102;
                v44 = v102;
                v31 = 0;
                v30 = v75;
                v39 = "flashing %s ...";
                v28 = v61;
                v40 = v66;
                v27 = v96;
                v26 = v97;
                v41 = 0;
                v42 = v104;
                v34 = v103;
                v33 = 0;
                // branch -> 0x8f622d68
                goto lab_0x8f622d68_5;
            }
            // 0x8f622d7c
            if (v4 != g31) {
                // 0x8f622d90
                __stack_chk_fail();
                // branch -> 0x8f622d94
            }
            // 0x8f622d94
            g47 = v2;
            g48 = v3;
            return 3;
        }
    }
    // 0x8f622d74
    clear_flash_fail(v12, g42, g45);
    // branch -> 0x8f622d7c
    // 0x8f622d7c
    if (v4 != g31) {
        // 0x8f622d90
        __stack_chk_fail();
        // branch -> 0x8f622d94
    }
    // 0x8f622d94
    g47 = v2;
    g48 = v3;
    return 1;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// char * strstr(char * haystack, const char * needle);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:12:11
