//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t add(int32_t * a1, int32_t a2);
int32_t clogo_load_handler(int32_t a1);
int32_t dbr_timeout_handler(int32_t a1, int32_t a2, int32_t a3);
int32_t display_logo(int32_t a1, int32_t a2);
int32_t fastboot_flush_all_logs(int32_t a1, int32_t a2);
int32_t handle_sod_event(int32_t a1, int32_t * a2);
int32_t init(int32_t a1, int32_t a2, int32_t a3);
int32_t is_screen(char * str);
int32_t need_check(char * a1, int32_t a2, int32_t a3);
int32_t ondraw(int32_t a1, int32_t a2, int32_t a3);
int32_t onkey(int32_t result, int32_t a2, int32_t a3);
int32_t onkey_17(int32_t a1, int32_t a2);
int32_t ramdump_view_init(int32_t a1, int32_t a2);
int32_t reboot_timer_func(int32_t a1, int32_t a2, char * a3);
int32_t reset_display_timer_func(int32_t a1, int32_t a2);
int32_t set_content_to_show(int32_t a1, int32_t a2);
int32_t show_battery_status(char * a1, int32_t a2);
int32_t start(void);
int32_t stop_16(int32_t a1, int32_t a2);
int32_t try_load_clogo(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);

// --------------------- Global Variables ---------------------

bool g52 = false; // LR
int32_t g53 = 0; // R1
int32_t g54 = 0; // R10
int32_t g55 = 0; // R11
int32_t g56 = 0; // R2
int32_t g57 = 0; // R4
int32_t g58 = 0; // R5
int32_t g59 = 0; // R6
int32_t g60 = 0; // R7
int32_t g61 = 0; // R8
int32_t g62 = 0; // R9
int32_t g1 = -0x16d2bfc9; // 0x8f638578
int32_t g2 = -0x16d2bc09; // 0x8f638ab0
int32_t g3 = -0x16d2bfed; // 0x8f639090
int32_t g4 = -0x1a60cfcc; // 0x8f6390e4
int32_t g5 = -0x16d2b010; // 0x8f639250
int32_t g6 = -0x1a60cfb4; // 0x8f639e10
int32_t g7 = -0x16d2bf10; // 0x8f639e6c
char * g8; // 0x8f63a37c
int32_t g9 = 1; // 0x8f69c7cc
int32_t g10 = 0x746e6300; // 0x8f6a4e20
char g11 = 0; // 0x8f6ac3c0
int32_t g13 = -1; // 0x8f6ac3e0
int32_t g14 = -1; // 0x8f6ac3e4
int32_t g15 = 0; // 0x8f6b166c
char * g16; // 0x8f6e0849
int32_t g17 = 0; // 0x8f6e084c
int32_t g18 = 0; // 0x8f6e0854
int32_t g19 = 0; // 0x8f6e08b0
int32_t g20 = 0; // 0x8f6e08b8
char * g21; // 0x8f6e08d4
int32_t g22 = 0; // 0x8f6e08d8
int32_t g23 = 0; // 0x8f6e08f4
char * g24; // 0x8f6e08f8
char * g25; // 0x8f6e08f9
int32_t g26 = 0; // 0x8f6e08fc
int32_t g27 = 0; // 0x8f6e0918
int32_t g28 = 0; // 0x8f6e091c
char * g29; // 0x8f6e0938
int32_t g30 = 0; // 0x8f6e093c
int32_t g31 = 0; // 0x8f6e0940
char * g32; // 0x8f6e095c
int32_t g33 = 0; // 0x8f6e0960
int32_t g34 = 0; // 0x8f6e097c
int32_t g35 = 0; // 0x8f7112f4
char * g36; // 0x8f711580
int16_t g37 = 0; // 0x8f711582
int16_t g38 = 0; // 0x8f711584
char * g39; // 0x8f711588
char * g40; // 0x8f711589
int16_t g41 = 0; // 0x8f71158a
int16_t g42 = 0; // 0x8f71158c
int16_t g43 = 0; // 0x8f711592
int16_t g44 = 0; // 0x8f711594
int16_t g45 = 0; // 0x8f711596
int16_t g46 = 0; // 0x8f711598
int16_t g47 = 0; // 0x8f71159c
int32_t g48 = 0; // 0x8f712580
int32_t g49 = 0; // 0x8f7125b8
int32_t g50 = 0; // 0x8f7125bc
int32_t g51 = 0; // 0x8f7125ec
int32_t * g12 = &g10; // 0x8f6ac3dc

// ------------------------ Functions -------------------------

// Address range: 0x8f639250 - 0x8f63950b
int32_t clogo_load_handler(int32_t a1) {
    int32_t v1 = g52 ? -0x709c73b8 : 0; // 0x8f639250
    int32_t v2 = g35;
    int32_t v3 = v2; // R3
    int32_t v4 = display_get_image_location(a1); // R10
    int32_t v5;
    int32_t v6;
    int32_t v7 = partition_get_index((int32_t)"clogo", g53, g56, v3, v6, v5); // 0x8f639270
    char * v8 = (char *)v6;
    int32_t v9;
    if (v7 != -1) {
        int32_t v10 = partition_get_offset(v7, g53, g56); // 0x8f63927c
        g56 = 0x1000;
        v3 = 0;
        int32_t v11;
        int32_t v12 = generic_mmc_read_logical(v10, g53, 0x1000, 0, (int32_t)&g36, v5, 0, v9, 0, v2, 0, g57, g58, g59, g60, g61, g62, g54, g55, v1, v11, 0, 0); // 0x8f639298
        if (v12 == 0) {
            int32_t len = strlen("BM"); // 0x8f6392a8
            g56 = len;
            if (strncmp((char *)(int32_t)&g36, "BM", len) == 0) {
                int32_t v13 = v4; // R11
                int16_t v14 = g45; // 0x8f6392e4
                int32_t v15 = ((int32_t)g43 | 0x10000 * (int32_t)g44) * (int32_t)g47 / 8 + 3 & -4; // 0x8f6392f0
                int32_t v16; // 0x8f6394c41
                int32_t v17; // 0x8f6394c43
                if (v14 < 0) {
                    uint32_t v18 = -(((int32_t)v14 | 0x10000 * (int32_t)g46)); // 0x8f63943c
                    g45 = v18;
                    g46 = v18 / 0x10000;
                    int32_t v19 = v15 * v18; // 0x8f639450
                    uint32_t v20 = v4 + 63 + v19; // 0x8f639458
                    int32_t v21 = (int32_t)g41 | 0x10000 * (int32_t)g42; // 0x8f639484
                    int32_t v22 = v21 + v19; // 0x8f63948c
                    g56 = v22;
                    int32_t v23 = v20 - v20 % 64 - v15 - v21; // 0x8f639490
                    int32_t v24 = 1;
                    if (generic_mmc_read_logical(v10, g53, v22, 0, v23, v5, 0, v9, 0, v2, 0, g57, g58, g59, g60, g61, g62, g54, g55, v1, v11, 0, 0) == -1) {
                        // 0x8f6394ac
                        print_log(-1, (int32_t)"Reading 'top-down' clogo FAILED !!\n", g56, 0, v23, v5, 0, v9, 0, v2, 0, g57, g58);
                        v24 = 0;
                        // branch -> 0x8f6394b8
                    }
                    // 0x8f6394b8
                    v3 = v24;
                    *(char *)(int32_t)&g24 = (char)v24;
                    v8 = (char *)v23;
                    v17 = v9;
                    v16 = v5;
                    // branch -> 0x8f6394bc
                } else {
                    // 0x8f6392f8
                    g56 = 0;
                    int32_t v25 = (int32_t)g37 | 0x10000 * (int32_t)g38; // 0x8f63931c
                    v3 = 0;
                    if (load_partition_by_name((int32_t)"clogo", v4 - ((int32_t)g41 || 0x10000 * (int32_t)g42), 0, 0, v25, 0, 0, v9, 0, v2, 0, g57, g58, g59, g60, g61, g62, g54, g55, v1, v11) == 0) {
                        int32_t v26 = (int32_t)g45 | 0x10000 * (int32_t)g46; // 0x8f63933c
                        int32_t v27 = v26 * v15; // 0x8f639340
                        int32_t v28 = (v4 + 63 + v27 & -64) + v27 - v15; // 0x8f639354
                        int32_t v29 = v9;
                        if (v26 == 0) {
                            int32_t v30 = 1; // 0x8f63935c55
                            memcpy((char *)v28, (char *)v13, v15);
                            int32_t v31 = v28 - v15; // 0x8f63938c
                            int32_t v32 = v13 + v15; // 0x8f639390
                            // branch -> 0x8f639374
                            while (v30 >= (0x10000 * (int32_t)g46 || (int32_t)g45)) {
                                // 0x8f639374
                                v30++;
                                v28 = v31;
                                memcpy((char *)v28, (char *)v32, v15);
                                v31 = v28 - v15;
                                v32 += v15;
                                // continue -> 0x8f639374
                            }
                            // 0x8f639358
                            v29 = v30;
                            v28 = v31;
                            // branch -> 0x8f63939c
                        }
                        int32_t v33 = (int32_t)&g24; // R8
                        int32_t v34 = (int32_t)g41 | 0x10000 * (int32_t)g42; // 0x8f6393a8
                        int32_t v35 = v28 - v34; // 0x8f6393ac
                        v28 = v35;
                        memcpy((char *)v35, (char *)(v4 - v34), v34);
                        int32_t v36 = -(((int32_t)g45 | 0x10000 * (int32_t)g46)); // 0x8f6393cc
                        v3 = v36;
                        *(char *)(v28 + 22) = (char)v36;
                        *(char *)(v28 + 23) = (char)(v3 / 256);
                        uint32_t v37 = v3; // 0x8f6393dc
                        *(char *)(v28 + 24) = (char)(v37 / 0x10000);
                        *(char *)(v28 + 25) = (char)(v37 / 0x1000000);
                        *(char *)v33 = 1;
                        char * v38 = (char *)v28;
                        int32_t v39 = v15 * ((int32_t)g45 | 0x10000 * (int32_t)g46) + ((int32_t)g41 | 0x10000 * (int32_t)g42); // 0x8f639414
                        g56 = v39;
                        v3 = 0;
                        if (generic_mmc_write_logical(v10, g53, v39, 0, v28, 0, 0, v29, 0, v2, 0, g57, g58, g59, g60, g61, g62, g54, g55, v1, v11, 0, 0, 0, 0, 0, 0, 0) == -1) {
                            // 0x8f639428
                            print_log(-1, (int32_t)"Flashing 'top-down' clogo FAILED !!\n", g56, v3, v28, 0, 0, v29, 0, v2, 0, g57, g58);
                            v3 = 0;
                            *(char *)v33 = 0;
                            v8 = v38;
                            v17 = v29;
                            v16 = 0;
                            // branch -> 0x8f6394bc
                        } else {
                            v8 = v38;
                            v17 = v29;
                            v16 = 0;
                        }
                    } else {
                        v8 = (char *)v25;
                        v17 = v9;
                        v16 = 0;
                    }
                }
                // 0x8f6394bc
                event_signal((int32_t)&g20, 0, g56, v3, (int32_t)v8, v16, 0, v17);
                if (v2 != g35) {
                    // 0x8f6394e0
                    __stack_chk_fail();
                    // branch -> 0x8f6394e4
                }
                // 0x8f6394e4
                return 0;
            }
            v8 = (char *)&g36;
        } else {
            v8 = (char *)&g36;
        }
    }
    // 0x8f6394bc
    event_signal((int32_t)&g20, 0, g56, v3, (int32_t)v8, v5, 0, v9);
    if (v2 != g35) {
        // 0x8f6394e0
        __stack_chk_fail();
        // branch -> 0x8f6394e4
    }
    // 0x8f6394e4
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int sprintf(char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 20
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:42:53
