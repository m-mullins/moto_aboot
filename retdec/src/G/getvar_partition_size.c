//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t getvar_channelid(char * a1, int32_t a2, int32_t a3);
int32_t getvar_cid(char * str, int32_t a2, int32_t a3);
int32_t getvar_confess_all(void);
int32_t getvar_cpu(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_hwrev(char * str, int32_t a2, int32_t a3);
int32_t getvar_iswarrantyvoid(int32_t a1, int32_t a2, int32_t a3);
char * getvar_partition_size(char * str, int32_t a2, int32_t a3, int32_t a4);
char * getvar_partition_type(char * str, int32_t a2, int32_t a3, int32_t a4);
int32_t getvar_product(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_radio(char * str, int32_t a2, int32_t a3);
int32_t getvar_secure_state(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_serialno(int32_t a1);
char * getvar_uid(int32_t a1);
int32_t getvar_unlocked(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_version_bootloader(int32_t a1);
int32_t type_atoi_10(char * str, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

bool g7 = false; // LR
int32_t g8 = 0; // R1
int32_t g9 = 0; // R2
int32_t g10 = 0; // R4
int32_t g11 = 0; // R5
int32_t g12 = 0; // R6
int32_t g13 = 0; // R7
int32_t g14 = 0; // R8
int32_t g1 = -0x16d2bfed; // 0x8f62bdfc
int32_t g2 = 0x6e61000a; // 0x8f6826e7
char * g3[8] = {
    "raw",
    "ext2",
    "ext3",
    "ext4",
    "vfat",
    "yaffs2",
    "jfss2",
    "iso"
}; // 0x8f6889a8
char * g5; // 0x8f6a4e20
int32_t g6 = 0; // 0x8f7112f4
char * g4[2] = {
    "version",
    (char *)&g1
}; // 0x8f688c8c

// ------------------------ Functions -------------------------

// Address range: 0x8f62c7ec - 0x8f62c91b
char * getvar_partition_size(char * str, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = g10; // 0x8f62c7ec
    int32_t v3 = g11; // 0x8f62c7ec
    int32_t v4 = g12; // 0x8f62c7ec
    int32_t v5 = g14; // 0x8f62c7ec
    g14 = v1;
    int32_t v6 = g6;
    char * found_char_pos = strchr(str, 58); // 0x8f62c804
    if (found_char_pos == NULL) {
        // 0x8f62c818
        // branch -> 0x8f62c824
        // 0x8f62c824
        print_log(0, (int32_t)"Malformatted command: %s\n", g14, v6, v1, a2, a3, v6, v2, v3, v4, g13, v5);
        // branch -> 0x8f62c8f0
        // 0x8f62c8f0
        if (v6 != g6) {
            // 0x8f62c900
            __stack_chk_fail();
            // branch -> 0x8f62c904
        }
        // 0x8f62c904
        g10 = v2;
        g11 = v3;
        g12 = v4;
        g14 = v5;
        return (char *)0;
    }
    int32_t v7 = (int32_t)found_char_pos + 1; // 0x8f62c810
    g10 = v7;
    if (v7 == 0) {
        // 0x8f62c818
        // branch -> 0x8f62c824
        // 0x8f62c824
        print_log(0, (int32_t)"Malformatted command: %s\n", g14, v6, v1, a2, a3, v6, v2, v3, v4, g13, v5);
        // branch -> 0x8f62c8f0
        // 0x8f62c8f0
        if (v6 != g6) {
            // 0x8f62c900
            __stack_chk_fail();
            // branch -> 0x8f62c904
        }
        // 0x8f62c904
        g10 = v2;
        g11 = v3;
        g12 = v4;
        g14 = v5;
        return (char *)0;
    }
    char * v8 = get_partition_by_name(v7, 58, a3, v6, v1, a2, a3, v6, v2, v3, v4); // 0x8f62c834
    int32_t v9 = (int32_t)v8; // 0x8f62c834_12
    int32_t v10;
    if (v8 == NULL) {
        // if_8f62c83c_0_true
        // branch -> 0x8f62c824
        // 0x8f62c824
        print_log(v9, (int32_t)"Invalid Partition: %s\n", g10, v6, v1, a2, a3, v6, v2, v3, v4, g13, v5);
        v10 = 0;
        // branch -> 0x8f62c8f0
    } else {
        char v11 = *(char *)(v9 + 41); // 0x8f62c848
        char v12 = *(char *)(v9 + 40); // 0x8f62c850
        char v13 = *(char *)(v9 + 42); // 0x8f62c85c
        char v14 = *(char *)(v9 + 43); // 0x8f62c864
        int32_t v15 = 0x1000000 * (int32_t)v14 | 0x10000 * (int32_t)v13 | (int32_t)v12 | 256 * (int32_t)v11; // 0x8f62c868
        g10 = v15;
        char v16 = *(char *)(v9 + 45); // 0x8f62c86c
        char v17 = *(char *)(v9 + 44); // 0x8f62c870
        int32_t v18 = v15 + 1; // 0x8f62c874
        g10 = v18;
        char v19 = *(char *)(v9 + 46); // 0x8f62c87c
        char v20 = *(char *)(v9 + 47); // 0x8f62c884
        int32_t v21 = 0x1000000 * (int32_t)v20 | 0x10000 * (int32_t)v19 | (int32_t)v17 | 256 * (int32_t)v16; // 0x8f62c888
        g11 = v21;
        char v22 = *(char *)(v9 + 33); // 0x8f62c88c
        char v23 = *(char *)(v9 + 32); // 0x8f62c890
        int32_t v24 = v21 + (int32_t)(v15 == -1); // 0x8f62c894
        g11 = v24;
        char v25 = *(char *)(v9 + 34); // 0x8f62c89c
        char v26 = *(char *)(v9 + 35); // 0x8f62c8a4
        int32_t v27 = 0x1000000 * (int32_t)v26 | 0x10000 * (int32_t)v25 | (int32_t)v23 | 256 * (int32_t)v22; // 0x8f62c8a8
        g12 = v27;
        char v28 = *(char *)(v9 + 37); // 0x8f62c8ac
        char v29 = *(char *)(v9 + 36); // 0x8f62c8b0
        char v30 = *(char *)(v9 + 38); // 0x8f62c8b8
        char v31 = *(char *)(v9 + 39); // 0x8f62c8c0
        uint32_t v32 = v18 - v27; // 0x8f62c8cc
        int32_t v33 = v24 - (0x1000000 * (int32_t)v31 | 0x10000 * (int32_t)v30 | (int32_t)v29 | 256 * (int32_t)v28) + (int32_t)(v18 < v27); // 0x8f62c8d0
        g11 = v33;
        g10 = 512 * v32;
        snprintf((char *)g14, 64, "0x%016llx", (int64_t)(512 * v33 | v32 / 0x800000));
        v10 = 1;
        // branch -> 0x8f62c8f0
    }
    // 0x8f62c8f0
    if (v6 != g6) {
        // 0x8f62c900
        __stack_chk_fail();
        // branch -> 0x8f62c904
    }
    // 0x8f62c904
    g10 = v2;
    g11 = v3;
    g12 = v4;
    g14 = v5;
    return (char *)v10;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 16
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:40:49
