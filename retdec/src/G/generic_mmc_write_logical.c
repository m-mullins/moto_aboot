//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t bd65060_read_reg(int32_t a1, int32_t a2);
int32_t bd65060_write_reg(int32_t a1, int32_t a2);
int32_t clk_init(int32_t a1, int32_t a2, int32_t a3);
int32_t clk_set_rate(int32_t a1);
int32_t generic_mmc_erase_legacy(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t generic_mmc_write_logical(int64_t a1, uint32_t a2, uint32_t a3, int32_t a4);
int32_t get_boot_seq(int32_t a1, int32_t a2, int32_t a3);
int32_t get_piv_image_size(int32_t a1, int32_t a2, int32_t a3);
int32_t LZ4_decompress_safe(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mdp_dsi_video_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_dsi_video_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdss_bus_clocks_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_bus_clocks_enable(void);
char * mmc_put_card_to_sleep(char * a1);
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3);
int32_t piv_validate(int32_t a1, int32_t a2, int32_t a3);
int32_t platform_get_smem_base_addr(void);
int32_t qtmr_irq(int32_t a1, int32_t a2);
int32_t smb1359_get_usbin_power_source_type(int32_t a1);
int32_t smb1359_read_reg(int32_t a1, int32_t a2);
int32_t sod_ramdump_enabled(char * a1, int32_t a2);
int32_t sod_ramdump_flag_pulled(int32_t a1, int32_t a2);
int32_t strings_count(int32_t a1, int32_t a2);
int32_t strings_from(char * a1, int32_t a2, int32_t a3);
int32_t target_fact_cbl_detect(int32_t a1, int32_t a2);
int32_t target_fact_cbl_setup(char * a1, int32_t a2);
int32_t target_mmc_erase_content(int32_t a1, int32_t a2);
int32_t target_mmc_init(int32_t * a1, int32_t a2);
int32_t target_platform_id(char * a1, int32_t a2, int32_t a3);
int32_t target_product_id(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g33 = 0; // LR
int32_t g34 = 0; // R0
int32_t g35 = 0; // R10
int32_t g36 = 0; // R11
int32_t g37 = 0; // R2
int32_t g38 = 0; // R3
int32_t g39 = 0; // R4
int32_t g40 = 0; // R5
int32_t g41 = 0; // R6
int32_t g42 = 0; // R7
int32_t g43 = 0; // R8
int32_t g44 = 0; // R9
bool g1 = false; // flagc
int32_t g2 = -0x1a60cfd8; // 0x8f606470
int32_t g3 = -0x1a60cfd8; // 0x8f6064a4
int32_t g4 = -0x16d2bfc9; // 0x8f6064d8
int32_t g5 = -0x16d2bfc9; // 0x8f606530
int32_t g6 = -0x16d2bfc9; // 0x8f60658c
char * g7; // 0x8f657e58
int32_t g8 = 0x65440030; // 0x8f69c66f
int32_t g9 = 0; // 0x8f6a3f38
int32_t g10 = 0; // 0x8f6a3f44
char * g11; // 0x8f6b7977
int32_t g12 = 0; // 0x8f6b8ad0
int32_t g13 = 0; // 0x8f6e0a94
int32_t g14 = 0; // 0x8f6e0bd4
int32_t g15 = 0; // 0x8f6e0c68
int32_t g16 = 0; // 0x8f6e0c6c
char * g17; // 0x8f6e0c80
int32_t g18 = 0; // 0x8f6ed830
int32_t g19 = 0; // 0x8f70da40
int32_t g20 = 0; // 0x8f70da44
int32_t g21 = 0; // 0x8f70da48
int32_t g22 = 0; // 0x8f70da4c
char * g23; // 0x8f70da50
int32_t g24 = 0; // 0x8f70da54
int32_t g25 = 0; // 0x8f70da58
int32_t g26 = 0; // 0x8f70da60
int32_t g27 = 0; // 0x8f70da64
int32_t g28 = 0; // 0x8f70da68
char * g29; // 0x8f70da6c
char * g30; // 0x8f70da8c
int32_t g31 = 0; // 0x8f7112f4
int32_t g32 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f650ad0 - 0x8f650e7f
int32_t generic_mmc_write_logical(int64_t a1, uint32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = a1;
    g34 = v1;
    int32_t v2 = g39; // 0x8f650ad0
    int32_t v3 = g40; // 0x8f650ad0
    int32_t v4 = g41; // 0x8f650ad0
    int32_t v5 = g42; // 0x8f650ad0
    int32_t v6 = g43; // 0x8f650ad0
    int32_t v7 = g44; // 0x8f650ad0
    int32_t v8 = g35; // 0x8f650ad0
    int32_t v9 = g36; // 0x8f650ad0
    int32_t v10;
    g43 = v10;
    int32_t v11 = g31;
    g38 = v11;
    int32_t v12;
    if (a3 == a4) {
        // 0x8f650e2c
        g34 = 0;
        // branch -> 0x8f650e38
    } else {
        // 0x8f650b00
        g44 = &g32;
        int32_t v13 = g32;
        int32_t v14 = v1 + a3; // 0x8f650b0c
        uint32_t v15 = a4 + a2 + (int32_t)(v14 < a3); // 0x8f650b10
        uint32_t v16 = *(int32_t *)(v13 + 32); // 0x8f650b18
        uint32_t v17 = *(int32_t *)(v13 + 36); // 0x8f650b18
        g38 = v17;
        bool v18 = false; // 0x8f650b24
        bool v19 = v15 >= v17; // 0x8f650b24
        if (v15 == v17) {
            // if_8f650b20_0_true
            v18 = v14 == v16;
            v19 = v14 >= v16;
            // branch -> after_if_8f650b20_0
        }
        // after_if_8f650b20_0
        if (v18 || v19 ^ true) {
            int32_t v20 = *(int32_t *)(v13 + 8); // 0x8f650b48
            g40 = 0;
            g38 = 0;
            g35 = v1 / 512 | 0x800000 * a2;
            g36 = a2 / 512;
            __aeabi_uldivmod(a1, (int64_t)v20);
            g34 = v14;
            uint32_t v21 = v15 - ((int32_t)(v14 != 0) ^ 1); // 0x8f650b78
            g41 = 0x800000 * v21 | (v14 - 1) / 512;
            g42 = v21 / 512;
            int32_t v22 = g40; // 0x8f650b8c
            g38 = v22;
            __aeabi_uldivmod((int64_t)v14, (int64_t)v20);
            int32_t v23 = g35; // 0x8f650b98
            int32_t v24 = g36; // 0x8f650b98
            int32_t v25 = g41; // 0x8f650b9c
            int32_t v26 = g42; // 0x8f650b9c
            g34 = 2;
            int32_t v27 = g43; // 0x8f650ba8
            g34 = print_log(2, (int32_t)"%s: start_sector=0x%llx, leading_size=%lld, ending_sector=0x%llx, trailing_size=%lld, buf=%p\n", (int32_t)"generic_mmc_write_logical", v22, v23, v24, v20, 0, v25, v26, v20, v22, v27);
            g38 = v20;
            int32_t v28; // 0x8f650d48
            int32_t v29; // 0x8f650d50
            int32_t v30; // 0x8f650dc8
            int32_t v31; // 0x8f650d80
            int32_t v32;
            int32_t v33;
            int32_t v34;
            int32_t v35;
            int32_t v36; // 0x8f650d00
            int32_t v37; // 0x8f650d60
            int32_t v38; // 0x8f650da4
            int32_t v39; // 0x8f650dd4
            int32_t v40; // 0x8f650d28
            int32_t v41; // 0x8f650da4
            int32_t v42; // 0x8f650cf8
            int32_t v43; // 0x8f650d04
            int32_t v44; // 0x8f650d30
            int32_t v45; // 0x8f650dac
            uint32_t v46; // 0x8f650d08
            uint32_t v47; // 0x8f650d0c
            uint32_t v48; // 0x8f650d18
            int32_t v49; // 0x8f650d1c
            int32_t v50; // 0x8f650e00
            int64_t v51; // 0x8f650d48
            int32_t v52; // 0x8f650d0c
            uint32_t v53; // 0x8f650d3c
            int32_t v54; // 0x8f650d44
            uint64_t v55; // 0x8f650d48
            uint64_t v56; // 0x8f650d50
            int32_t v57; // 0x8f650d54
            int32_t v58; // 0x8f650d58
            int32_t v59; // 0x8f650d90
            uint32_t v60; // 0x8f650dbc
            int32_t v61; // 0x8f650dc4
            uint64_t v62; // 0x8f650dc8
            int32_t v63; // 0x8f650dcc
            uint32_t v64; // 0x8f650e10
            int32_t v65; // 0x8f650d20
            int32_t v66; // 0x8f650d24
            if (v20 == 0) {
                // 0x8f650cf0
                // branch -> 0x8f650cf4
                // 0x8f650cf4
                g34 = v20;
                v42 = v22 | v20;
                if (v20 == v22) {
                    // 0x8f650cf4
                    v49 = g42;
                    // branch -> 0x8f650d08
                } else {
                    // 0x8f650d00
                    v36 = g41;
                    g41 = v36 - 1;
                    v43 = g42 - ((int32_t)(v36 != 0) ^ 1);
                    g42 = v43;
                    v49 = v43;
                    // branch -> 0x8f650d08
                }
                // 0x8f650d08
                v46 = g36;
                v47 = g35;
                if (v49 == v46) {
                    // if_8f650d0c_0_true
                    v52 = g41;
                    if (v52 >= v47) {
                        v48 = v52;
                        // 0x8f650d14
                        g44 = &g32;
                        v65 = v48 - v47;
                        v66 = (int32_t)(v48 < v47) + v49 - v46;
                        g38 = v66;
                        v40 = v65 + 1;
                        g1 = v65 == -1;
                        g34 = v40;
                        v32 = g32;
                        v44 = v66 + (int32_t)(v65 == -1);
                        v53 = *(int32_t *)(v32 + 8);
                        g39 = v53;
                        v54 = *(int32_t *)(v32 + 60);
                        v51 = v53;
                        v55 = v51 * (int64_t)v40;
                        v28 = v55;
                        g37 = v28;
                        v56 = v51 * (int64_t)v47;
                        v29 = v56;
                        g34 = v29;
                        v57 = (int32_t)(v55 / 0x100000000) + v44 * v53;
                        g38 = v57;
                        v58 = (int32_t)(v56 / 0x100000000) + v53 * v46;
                        g33 = -0x709af2a0;
                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v54)(v29, v58, v28, v57, g43);
                        v37 = g34;
                        if (v37 > -1) {
                            // 0x8f650d88
                            v33 = g32;
                            g38 = v33;
                            g34 = v40;
                            v59 = *(int32_t *)(v33 + 8);
                            g38 = v59;
                            g43 += v59 * v40;
                            // branch -> 0x8f650d98
                            // 0x8f650d98
                            g38 = v42;
                            if (v20 != v22) {
                                // 0x8f650da4
                                v38 = g41;
                                v41 = v38 + 1;
                                g1 = v38 == -1;
                                g39 = v41;
                                g41 = (int32_t)&g17;
                                v45 = (int32_t)(v38 == -1) + g42;
                                g40 = v45;
                                g42 = &g32;
                                g38 = 0;
                                v34 = g32;
                                v60 = *(int32_t *)(v34 + 8);
                                g37 = v60;
                                v61 = *(int32_t *)(v34 + 56);
                                v62 = (int64_t)v60 * (int64_t)v41;
                                v30 = v62;
                                g34 = v30;
                                v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                                g33 = -0x709af22c;
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                                v39 = g34;
                                g1 = true;
                                g44 = v39;
                                if (v39 > -1) {
                                    // 0x8f650df8
                                    v50 = g41;
                                    g34 = v50;
                                    g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                                    v35 = g32;
                                    g38 = 0;
                                    v64 = *(int32_t *)(v35 + 8);
                                    g37 = v64;
                                    g34 = (int64_t)g39 * (int64_t)v64;
                                    // branch -> 0x8f650e20
                                    // 0x8f650e20
                                    g33 = -0x709af1d8;
                                    ((int32_t (*)())*(int32_t *)(v35 + 60))();
                                    // branch -> 0x8f650e38
                                } else {
                                    // 0x8f650ddc
                                    g34 = 0;
                                    print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                                    g34 = g44;
                                    // branch -> 0x8f650e38
                                }
                                // 0x8f650e38
                                v12 = g31;
                                g38 = v12;
                                if (v11 != v12) {
                                    // 0x8f650e4c
                                    __stack_chk_fail();
                                    // branch -> 0x8f650e50
                                }
                                // 0x8f650e50
                                g39 = v2;
                                g40 = v3;
                                g41 = v4;
                                g42 = v5;
                                g43 = v6;
                                g44 = v7;
                                g35 = v8;
                                g36 = v9;
                                return g34;
                            }
                        } else {
                            // 0x8f650d68
                            g34 = 0;
                            v31 = print_log(0, (int32_t)"%s: Failed to read %lld sectors from sector 0x%llx\n", (int32_t)"generic_mmc_write_logical", v57, v40, v44, g35, g36, v25, v26, v20, v22, v27);
                            g34 = v31;
                            // branch -> 0x8f650e34
                        }
                        // 0x8f650e34
                        g34 = v37;
                        // branch -> 0x8f650e38
                        // 0x8f650e38
                        v12 = g31;
                        g38 = v12;
                        if (v11 != v12) {
                            // 0x8f650e4c
                            __stack_chk_fail();
                            // branch -> 0x8f650e50
                        }
                        // 0x8f650e50
                        g39 = v2;
                        g40 = v3;
                        g41 = v4;
                        g42 = v5;
                        g43 = v6;
                        g44 = v7;
                        g35 = v8;
                        g36 = v9;
                        return g34;
                    }
                } else {
                    // after_if_8f650d0c_0
                    if (v49 >= v46) {
                        // after_if_8f650d0c_0.dec_label_pc_8f650d14_crit_edge
                        v48 = g41;
                        // branch -> 0x8f650d14
                        // 0x8f650d14
                        g44 = &g32;
                        v65 = v48 - v47;
                        v66 = (int32_t)(v48 < v47) + v49 - v46;
                        g38 = v66;
                        v40 = v65 + 1;
                        g1 = v65 == -1;
                        g34 = v40;
                        v32 = g32;
                        v44 = v66 + (int32_t)(v65 == -1);
                        v53 = *(int32_t *)(v32 + 8);
                        g39 = v53;
                        v54 = *(int32_t *)(v32 + 60);
                        v51 = v53;
                        v55 = v51 * (int64_t)v40;
                        v28 = v55;
                        g37 = v28;
                        v56 = v51 * (int64_t)v47;
                        v29 = v56;
                        g34 = v29;
                        v57 = (int32_t)(v55 / 0x100000000) + v44 * v53;
                        g38 = v57;
                        v58 = (int32_t)(v56 / 0x100000000) + v53 * v46;
                        g33 = -0x709af2a0;
                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v54)(v29, v58, v28, v57, g43);
                        v37 = g34;
                        if (v37 > -1) {
                            // 0x8f650d88
                            v33 = g32;
                            g38 = v33;
                            g34 = v40;
                            v59 = *(int32_t *)(v33 + 8);
                            g38 = v59;
                            g43 += v59 * v40;
                            // branch -> 0x8f650d98
                            // 0x8f650d98
                            g38 = v42;
                            if (v20 != v22) {
                                // 0x8f650da4
                                v38 = g41;
                                v41 = v38 + 1;
                                g1 = v38 == -1;
                                g39 = v41;
                                g41 = (int32_t)&g17;
                                v45 = (int32_t)(v38 == -1) + g42;
                                g40 = v45;
                                g42 = &g32;
                                g38 = 0;
                                v34 = g32;
                                v60 = *(int32_t *)(v34 + 8);
                                g37 = v60;
                                v61 = *(int32_t *)(v34 + 56);
                                v62 = (int64_t)v60 * (int64_t)v41;
                                v30 = v62;
                                g34 = v30;
                                v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                                g33 = -0x709af22c;
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                                v39 = g34;
                                g1 = true;
                                g44 = v39;
                                if (v39 > -1) {
                                    // 0x8f650df8
                                    v50 = g41;
                                    g34 = v50;
                                    g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                                    v35 = g32;
                                    g38 = 0;
                                    v64 = *(int32_t *)(v35 + 8);
                                    g37 = v64;
                                    g34 = (int64_t)g39 * (int64_t)v64;
                                    // branch -> 0x8f650e20
                                    // 0x8f650e20
                                    g33 = -0x709af1d8;
                                    ((int32_t (*)())*(int32_t *)(v35 + 60))();
                                    // branch -> 0x8f650e38
                                } else {
                                    // 0x8f650ddc
                                    g34 = 0;
                                    print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                                    g34 = g44;
                                    // branch -> 0x8f650e38
                                }
                                // 0x8f650e38
                                v12 = g31;
                                g38 = v12;
                                if (v11 != v12) {
                                    // 0x8f650e4c
                                    __stack_chk_fail();
                                    // branch -> 0x8f650e50
                                }
                                // 0x8f650e50
                                g39 = v2;
                                g40 = v3;
                                g41 = v4;
                                g42 = v5;
                                g43 = v6;
                                g44 = v7;
                                g35 = v8;
                                g36 = v9;
                                return g34;
                            }
                        } else {
                            // 0x8f650d68
                            g34 = 0;
                            v31 = print_log(0, (int32_t)"%s: Failed to read %lld sectors from sector 0x%llx\n", (int32_t)"generic_mmc_write_logical", v57, v40, v44, g35, g36, v25, v26, v20, v22, v27);
                            g34 = v31;
                            // branch -> 0x8f650e34
                        }
                        // 0x8f650e34
                        g34 = v37;
                        // branch -> 0x8f650e38
                        // 0x8f650e38
                        v12 = g31;
                        g38 = v12;
                        if (v11 != v12) {
                            // 0x8f650e4c
                            __stack_chk_fail();
                            // branch -> 0x8f650e50
                        }
                        // 0x8f650e50
                        g39 = v2;
                        g40 = v3;
                        g41 = v4;
                        g42 = v5;
                        g43 = v6;
                        g44 = v7;
                        g35 = v8;
                        g36 = v9;
                        return g34;
                    }
                }
                // 0x8f650d98
                g38 = v42;
                if (v20 == v22) {
                    // 0x8f650e34
                    g34 = -1;
                    // branch -> 0x8f650e38
                    // 0x8f650e38
                    v12 = g31;
                    g38 = v12;
                    if (v11 != v12) {
                        // 0x8f650e4c
                        __stack_chk_fail();
                        // branch -> 0x8f650e50
                    }
                    // 0x8f650e50
                    g39 = v2;
                    g40 = v3;
                    g41 = v4;
                    g42 = v5;
                    g43 = v6;
                    g44 = v7;
                    g35 = v8;
                    g36 = v9;
                    return g34;
                }
                // 0x8f650da4
                v38 = g41;
                v41 = v38 + 1;
                g1 = v38 == -1;
                g39 = v41;
                g41 = (int32_t)&g17;
                v45 = (int32_t)(v38 == -1) + g42;
                g40 = v45;
                g42 = &g32;
                g38 = 0;
                v34 = g32;
                v60 = *(int32_t *)(v34 + 8);
                g37 = v60;
                v61 = *(int32_t *)(v34 + 56);
                v62 = (int64_t)v60 * (int64_t)v41;
                v30 = v62;
                g34 = v30;
                v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                g33 = -0x709af22c;
                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                v39 = g34;
                g1 = true;
                g44 = v39;
                if (v39 > -1) {
                    // 0x8f650df8
                    v50 = g41;
                    g34 = v50;
                    g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                    v35 = g32;
                    g38 = 0;
                    v64 = *(int32_t *)(v35 + 8);
                    g37 = v64;
                    g34 = (int64_t)g39 * (int64_t)v64;
                    // branch -> 0x8f650e20
                    // 0x8f650e20
                    g33 = -0x709af1d8;
                    ((int32_t (*)())*(int32_t *)(v35 + 60))();
                    // branch -> 0x8f650e38
                } else {
                    // 0x8f650ddc
                    g34 = 0;
                    print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                    g34 = g44;
                    // branch -> 0x8f650e38
                }
                // 0x8f650e38
                v12 = g31;
                g38 = v12;
                if (v11 != v12) {
                    // 0x8f650e4c
                    __stack_chk_fail();
                    // branch -> 0x8f650e50
                }
                // 0x8f650e50
                g39 = v2;
                g40 = v3;
                g41 = v4;
                g42 = v5;
                g43 = v6;
                g44 = v7;
                g35 = v8;
                g36 = v9;
                return g34;
            }
            uint32_t v67 = g43; // 0x8f650bd8
            int32_t v68 = v67 - v20; // 0x8f650bd8
            g1 = v67 >= v20;
            g34 = v68;
            g38 = 0;
            if (v68 % 4 != 0) {
                // 0x8f650bf0
                g34 = 0;
                print_log(0, (int32_t)"%s: buffer address not well aligned\n", (int32_t)"generic_mmc_write_logical", 0, v23, v24, v20, 0, v25, v26, v20, v22, v27);
                // branch -> 0x8f650c00
                // 0x8f650c00
                g34 = -1;
                // branch -> 0x8f650e38
                // 0x8f650e38
                v12 = g31;
                g38 = v12;
                if (v11 != v12) {
                    // 0x8f650e4c
                    __stack_chk_fail();
                    // branch -> 0x8f650e50
                }
                // 0x8f650e50
                g39 = v2;
                g40 = v3;
                g41 = v4;
                g42 = v5;
                g43 = v6;
                g44 = v7;
                g35 = v8;
                g36 = v9;
                return g34;
            }
            int32_t v69 = g32;
            g38 = 0;
            g39 = (int32_t)&g17;
            uint32_t v70 = *(int32_t *)(v69 + 8); // 0x8f650c14
            g37 = v70;
            int32_t v71 = *(int32_t *)(v69 + 56); // 0x8f650c1c
            uint64_t v72 = (int64_t)g35 * (int64_t)v70; // 0x8f650c20
            int32_t v73 = v72; // 0x8f650c20
            g34 = v73;
            int32_t v74 = (int32_t)(v72 / 0x100000000) + g36 * v70; // 0x8f650c24
            g33 = -0x709af3d4;
            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v71)(v73, v74, v70, 0, (int32_t)&g17);
            int32_t v75 = g34; // 0x8f650c2c
            g40 = v75;
            if (v75 > -1) {
                uint32_t v76 = g42; // 0x8f650c54
                uint32_t v77 = g36; // 0x8f650c54
                g1 = v77 >= v76;
                uint32_t v78 = g41; // 0x8f650c58
                char * v79;
                if (v77 == v76) {
                    uint32_t v80 = g35; // 0x8f650c58
                    g1 = v80 >= v78;
                    int32_t v81 = g39 + v20; // 0x8f650c5c
                    v79 = (char *)v81;
                    g34 = v81;
                    if (v80 == v78) {
                        // 0x8f650c64
                        g34 = (int32_t)memcpy(v79, (char *)g43, a3);
                        int32_t v82 = g32;
                        g38 = 0;
                        uint32_t v83 = *(int32_t *)(v82 + 8); // 0x8f650c78
                        g37 = v83;
                        g34 = (int64_t)g35 * (int64_t)v83;
                        // branch -> 0x8f650e20
                        // 0x8f650e20
                        g33 = -0x709af1d8;
                        ((int32_t (*)())*(int32_t *)(v82 + 60))();
                        // branch -> 0x8f650e38
                        // 0x8f650e38
                        v12 = g31;
                        g38 = v12;
                        if (v11 != v12) {
                            // 0x8f650e4c
                            __stack_chk_fail();
                            // branch -> 0x8f650e50
                        }
                        // 0x8f650e50
                        g39 = v2;
                        g40 = v3;
                        g41 = v4;
                        g42 = v5;
                        g43 = v6;
                        g44 = v7;
                        g35 = v8;
                        g36 = v9;
                        return g34;
                    }
                } else {
                    int32_t v84 = g39 + v20; // 0x8f650c5c3
                    g34 = v84;
                    v79 = (char *)v84;
                    // branch -> 0x8f650c8c
                }
                int32_t v85 = 512 - v20; // 0x8f650c94
                g40 = v85;
                g34 = (int32_t)memcpy(v79, (char *)g43, v85);
                int32_t v86 = g32;
                g38 = 0;
                uint32_t v87 = *(int32_t *)(v86 + 8); // 0x8f650ca8
                g37 = v87;
                uint64_t v88 = (int64_t)g35 * (int64_t)v87; // 0x8f650cb4
                int32_t v89 = v88; // 0x8f650cb4
                g34 = v89;
                int32_t v90 = (int32_t)(v88 / 0x100000000) + g36 * v87; // 0x8f650cb8
                g33 = -0x709af340;
                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))*(int32_t *)(v86 + 60))(v89, v90, v87, 0, g39);
                int32_t v91 = g34; // 0x8f650cc0
                int32_t v92 = g35; // 0x8f650ce0
                if (v91 == 0) {
                    // 0x8f650ce0
                    g35 = v92 + 1;
                    g43 += g40;
                    g36 += (int32_t)(v92 == -1);
                    // branch -> 0x8f650cf4
                    // 0x8f650cf4
                    g34 = v20;
                    v42 = v22 | v20;
                    if (v20 == v22) {
                        // 0x8f650cf4
                        v49 = g42;
                        // branch -> 0x8f650d08
                    } else {
                        // 0x8f650d00
                        v36 = g41;
                        g41 = v36 - 1;
                        v43 = g42 - ((int32_t)(v36 != 0) ^ 1);
                        g42 = v43;
                        v49 = v43;
                        // branch -> 0x8f650d08
                    }
                    // 0x8f650d08
                    v46 = g36;
                    v47 = g35;
                    if (v49 == v46) {
                        // if_8f650d0c_0_true
                        v52 = g41;
                        if (v52 >= v47) {
                            v48 = v52;
                            // 0x8f650d14
                            g44 = &g32;
                            v65 = v48 - v47;
                            v66 = (int32_t)(v48 < v47) + v49 - v46;
                            g38 = v66;
                            v40 = v65 + 1;
                            g1 = v65 == -1;
                            g34 = v40;
                            v32 = g32;
                            v44 = v66 + (int32_t)(v65 == -1);
                            v53 = *(int32_t *)(v32 + 8);
                            g39 = v53;
                            v54 = *(int32_t *)(v32 + 60);
                            v51 = v53;
                            v55 = v51 * (int64_t)v40;
                            v28 = v55;
                            g37 = v28;
                            v56 = v51 * (int64_t)v47;
                            v29 = v56;
                            g34 = v29;
                            v57 = (int32_t)(v55 / 0x100000000) + v44 * v53;
                            g38 = v57;
                            v58 = (int32_t)(v56 / 0x100000000) + v53 * v46;
                            g33 = -0x709af2a0;
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v54)(v29, v58, v28, v57, g43);
                            v37 = g34;
                            if (v37 > -1) {
                                // 0x8f650d88
                                v33 = g32;
                                g38 = v33;
                                g34 = v40;
                                v59 = *(int32_t *)(v33 + 8);
                                g38 = v59;
                                g43 += v59 * v40;
                                // branch -> 0x8f650d98
                                // 0x8f650d98
                                g38 = v42;
                                if (v20 != v22) {
                                    // 0x8f650da4
                                    v38 = g41;
                                    v41 = v38 + 1;
                                    g1 = v38 == -1;
                                    g39 = v41;
                                    g41 = (int32_t)&g17;
                                    v45 = (int32_t)(v38 == -1) + g42;
                                    g40 = v45;
                                    g42 = &g32;
                                    g38 = 0;
                                    v34 = g32;
                                    v60 = *(int32_t *)(v34 + 8);
                                    g37 = v60;
                                    v61 = *(int32_t *)(v34 + 56);
                                    v62 = (int64_t)v60 * (int64_t)v41;
                                    v30 = v62;
                                    g34 = v30;
                                    v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                                    g33 = -0x709af22c;
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                                    v39 = g34;
                                    g1 = true;
                                    g44 = v39;
                                    if (v39 > -1) {
                                        // 0x8f650df8
                                        v50 = g41;
                                        g34 = v50;
                                        g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                                        v35 = g32;
                                        g38 = 0;
                                        v64 = *(int32_t *)(v35 + 8);
                                        g37 = v64;
                                        g34 = (int64_t)g39 * (int64_t)v64;
                                        // branch -> 0x8f650e20
                                        // 0x8f650e20
                                        g33 = -0x709af1d8;
                                        ((int32_t (*)())*(int32_t *)(v35 + 60))();
                                        // branch -> 0x8f650e38
                                    } else {
                                        // 0x8f650ddc
                                        g34 = 0;
                                        print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                                        g34 = g44;
                                        // branch -> 0x8f650e38
                                    }
                                    // 0x8f650e38
                                    v12 = g31;
                                    g38 = v12;
                                    if (v11 != v12) {
                                        // 0x8f650e4c
                                        __stack_chk_fail();
                                        // branch -> 0x8f650e50
                                    }
                                    // 0x8f650e50
                                    g39 = v2;
                                    g40 = v3;
                                    g41 = v4;
                                    g42 = v5;
                                    g43 = v6;
                                    g44 = v7;
                                    g35 = v8;
                                    g36 = v9;
                                    return g34;
                                }
                            } else {
                                // 0x8f650d68
                                g34 = 0;
                                v31 = print_log(0, (int32_t)"%s: Failed to read %lld sectors from sector 0x%llx\n", (int32_t)"generic_mmc_write_logical", v57, v40, v44, g35, g36, v25, v26, v20, v22, v27);
                                g34 = v31;
                                // branch -> 0x8f650e34
                            }
                            // 0x8f650e34
                            g34 = v37;
                            // branch -> 0x8f650e38
                            // 0x8f650e38
                            v12 = g31;
                            g38 = v12;
                            if (v11 != v12) {
                                // 0x8f650e4c
                                __stack_chk_fail();
                                // branch -> 0x8f650e50
                            }
                            // 0x8f650e50
                            g39 = v2;
                            g40 = v3;
                            g41 = v4;
                            g42 = v5;
                            g43 = v6;
                            g44 = v7;
                            g35 = v8;
                            g36 = v9;
                            return g34;
                        }
                    } else {
                        // after_if_8f650d0c_0
                        if (v49 >= v46) {
                            // after_if_8f650d0c_0.dec_label_pc_8f650d14_crit_edge
                            v48 = g41;
                            // branch -> 0x8f650d14
                            // 0x8f650d14
                            g44 = &g32;
                            v65 = v48 - v47;
                            v66 = (int32_t)(v48 < v47) + v49 - v46;
                            g38 = v66;
                            v40 = v65 + 1;
                            g1 = v65 == -1;
                            g34 = v40;
                            v32 = g32;
                            v44 = v66 + (int32_t)(v65 == -1);
                            v53 = *(int32_t *)(v32 + 8);
                            g39 = v53;
                            v54 = *(int32_t *)(v32 + 60);
                            v51 = v53;
                            v55 = v51 * (int64_t)v40;
                            v28 = v55;
                            g37 = v28;
                            v56 = v51 * (int64_t)v47;
                            v29 = v56;
                            g34 = v29;
                            v57 = (int32_t)(v55 / 0x100000000) + v44 * v53;
                            g38 = v57;
                            v58 = (int32_t)(v56 / 0x100000000) + v53 * v46;
                            g33 = -0x709af2a0;
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v54)(v29, v58, v28, v57, g43);
                            v37 = g34;
                            if (v37 > -1) {
                                // 0x8f650d88
                                v33 = g32;
                                g38 = v33;
                                g34 = v40;
                                v59 = *(int32_t *)(v33 + 8);
                                g38 = v59;
                                g43 += v59 * v40;
                                // branch -> 0x8f650d98
                                // 0x8f650d98
                                g38 = v42;
                                if (v20 != v22) {
                                    // 0x8f650da4
                                    v38 = g41;
                                    v41 = v38 + 1;
                                    g1 = v38 == -1;
                                    g39 = v41;
                                    g41 = (int32_t)&g17;
                                    v45 = (int32_t)(v38 == -1) + g42;
                                    g40 = v45;
                                    g42 = &g32;
                                    g38 = 0;
                                    v34 = g32;
                                    v60 = *(int32_t *)(v34 + 8);
                                    g37 = v60;
                                    v61 = *(int32_t *)(v34 + 56);
                                    v62 = (int64_t)v60 * (int64_t)v41;
                                    v30 = v62;
                                    g34 = v30;
                                    v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                                    g33 = -0x709af22c;
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                                    v39 = g34;
                                    g1 = true;
                                    g44 = v39;
                                    if (v39 > -1) {
                                        // 0x8f650df8
                                        v50 = g41;
                                        g34 = v50;
                                        g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                                        v35 = g32;
                                        g38 = 0;
                                        v64 = *(int32_t *)(v35 + 8);
                                        g37 = v64;
                                        g34 = (int64_t)g39 * (int64_t)v64;
                                        // branch -> 0x8f650e20
                                        // 0x8f650e20
                                        g33 = -0x709af1d8;
                                        ((int32_t (*)())*(int32_t *)(v35 + 60))();
                                        // branch -> 0x8f650e38
                                    } else {
                                        // 0x8f650ddc
                                        g34 = 0;
                                        print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                                        g34 = g44;
                                        // branch -> 0x8f650e38
                                    }
                                    // 0x8f650e38
                                    v12 = g31;
                                    g38 = v12;
                                    if (v11 != v12) {
                                        // 0x8f650e4c
                                        __stack_chk_fail();
                                        // branch -> 0x8f650e50
                                    }
                                    // 0x8f650e50
                                    g39 = v2;
                                    g40 = v3;
                                    g41 = v4;
                                    g42 = v5;
                                    g43 = v6;
                                    g44 = v7;
                                    g35 = v8;
                                    g36 = v9;
                                    return g34;
                                }
                            } else {
                                // 0x8f650d68
                                g34 = 0;
                                v31 = print_log(0, (int32_t)"%s: Failed to read %lld sectors from sector 0x%llx\n", (int32_t)"generic_mmc_write_logical", v57, v40, v44, g35, g36, v25, v26, v20, v22, v27);
                                g34 = v31;
                                // branch -> 0x8f650e34
                            }
                            // 0x8f650e34
                            g34 = v37;
                            // branch -> 0x8f650e38
                            // 0x8f650e38
                            v12 = g31;
                            g38 = v12;
                            if (v11 != v12) {
                                // 0x8f650e4c
                                __stack_chk_fail();
                                // branch -> 0x8f650e50
                            }
                            // 0x8f650e50
                            g39 = v2;
                            g40 = v3;
                            g41 = v4;
                            g42 = v5;
                            g43 = v6;
                            g44 = v7;
                            g35 = v8;
                            g36 = v9;
                            return g34;
                        }
                    }
                    // 0x8f650d98
                    g38 = v42;
                    if (v20 != v22) {
                        // 0x8f650da4
                        v38 = g41;
                        v41 = v38 + 1;
                        g1 = v38 == -1;
                        g39 = v41;
                        g41 = (int32_t)&g17;
                        v45 = (int32_t)(v38 == -1) + g42;
                        g40 = v45;
                        g42 = &g32;
                        g38 = 0;
                        v34 = g32;
                        v60 = *(int32_t *)(v34 + 8);
                        g37 = v60;
                        v61 = *(int32_t *)(v34 + 56);
                        v62 = (int64_t)v60 * (int64_t)v41;
                        v30 = v62;
                        g34 = v30;
                        v63 = (int32_t)(v62 / 0x100000000) + v45 * v60;
                        g33 = -0x709af22c;
                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))v61)(v30, v63, v60, 0, (int32_t)&g17);
                        v39 = g34;
                        g1 = true;
                        g44 = v39;
                        if (v39 > -1) {
                            // 0x8f650df8
                            v50 = g41;
                            g34 = v50;
                            g34 = (int32_t)memcpy((char *)v50, (char *)g43, v20);
                            v35 = g32;
                            g38 = 0;
                            v64 = *(int32_t *)(v35 + 8);
                            g37 = v64;
                            g34 = (int64_t)g39 * (int64_t)v64;
                            // branch -> 0x8f650e20
                            // 0x8f650e20
                            g33 = -0x709af1d8;
                            ((int32_t (*)())*(int32_t *)(v35 + 60))();
                            // branch -> 0x8f650e38
                        } else {
                            // 0x8f650ddc
                            g34 = 0;
                            print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g39, g40, v20, 0, v25, v26, v20, v22, v27);
                            g34 = g44;
                            // branch -> 0x8f650e38
                        }
                        // 0x8f650e38
                        v12 = g31;
                        g38 = v12;
                        if (v11 != v12) {
                            // 0x8f650e4c
                            __stack_chk_fail();
                            // branch -> 0x8f650e50
                        }
                        // 0x8f650e50
                        g39 = v2;
                        g40 = v3;
                        g41 = v4;
                        g42 = v5;
                        g43 = v6;
                        g44 = v7;
                        g35 = v8;
                        g36 = v9;
                        return g34;
                    }
                } else {
                    // 0x8f650cc8
                    g34 = 0;
                    g34 = print_log(0, (int32_t)"%s: Failed to write to emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, v92, g36, v20, 0, v25, v26, v20, v22, v27);
                    // branch -> 0x8f650e34
                }
                // 0x8f650e34
                g34 = v91;
                // branch -> 0x8f650e38
            } else {
                // 0x8f650c34
                g34 = 0;
                print_log(0, (int32_t)"%s: Failed to read emmc 1 sector from 0x%llx\n", (int32_t)"generic_mmc_write_logical", 0, g35, g36, v20, 0, v25, v26, v20, v22, v27);
                g34 = g40;
                // branch -> 0x8f650e38
            }
            // 0x8f650e38
            v12 = g31;
            g38 = v12;
            if (v11 != v12) {
                // 0x8f650e4c
                __stack_chk_fail();
                // branch -> 0x8f650e50
            }
            // 0x8f650e50
            g39 = v2;
            g40 = v3;
            g41 = v4;
            g42 = v5;
            g43 = v6;
            g44 = v7;
            g35 = v8;
            g36 = v9;
            return g34;
        }
        // 0x8f650b28
        g34 = 0;
        g38 = a2;
        int32_t v93;
        int32_t v94;
        int32_t v95;
        int32_t v96;
        int32_t v97;
        print_log(0, (int32_t)"Invalid logical range: start=%llu, end=%llu, total=%llu\n", v1, a2, v14, v15, v16, v17, v97, v96, v95, v94, v93);
        // branch -> 0x8f650c00
        // 0x8f650c00
        g34 = -1;
        // branch -> 0x8f650e38
    }
    // 0x8f650e38
    v12 = g31;
    g38 = v12;
    if (v11 != v12) {
        // 0x8f650e4c
        __stack_chk_fail();
        // branch -> 0x8f650e50
    }
    // 0x8f650e50
    g39 = v2;
    g40 = v3;
    g41 = v4;
    g42 = v5;
    g43 = v6;
    g44 = v7;
    g35 = v8;
    g36 = v9;
    return g34;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:56:14
