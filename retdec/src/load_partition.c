//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t clk_get(char * str2);
int32_t clk_get_set_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t dbval_provision_req(char a1, char * a2, int32_t a3);
int32_t dbval_provision_store(char * a1, int32_t * a2, char * a3);
int32_t event_signal(int32_t a1, int32_t a2, int32_t a3);
void event_unsignal(int32_t a1);
int32_t fdt_next_tag(int32_t a1, int32_t a2, int32_t * a3);
int32_t fdt_offset_ptr(int32_t a1, int32_t a2, int32_t a3);
int32_t generic_mmc_erase_sector(int64_t a1, int64_t a2);
int32_t generic_mmc_get_protect_group_size(int32_t a1, int32_t a2);
int32_t get_root_detect_disabled(void);
int32_t getvar_handler_root_detect(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_map_address(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_virtual_to_physical(int32_t a1, int32_t a2, int32_t a3);
int32_t load_partition(int32_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t load_partition_by_name(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mcs_clear_hash_ctx(char * a1, int32_t a2, int32_t a3);
int32_t mcs_initialize_montgomery_alg(int32_t * a1, int32_t a2);
int32_t mdss_dsi_auto_pll_config(int32_t * a1, int32_t a2);
int32_t mdss_dsi_host_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdss_dsi_phy_init(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_cmd_bta_sw_trigger(int32_t a1, int32_t a2, int32_t a3);
int32_t nexus_usbpidvid(int32_t a1, int32_t a2);
int32_t read_root_status(void);
char * sdhci_msm_execute_tuning(char * a1, int32_t a2, int32_t a3);
int32_t sdhci_msm_toggle_cdr(int32_t * a1, int32_t a2, int32_t a3);
int32_t sod_init(void);
int32_t sod_ramdump_run(void);
int32_t thread_init(int32_t a1, int32_t a2);
int32_t thread_set_name(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g26 = 0; // LR
int32_t g27 = 0; // R0
int32_t g28 = 0; // R1
int32_t g29 = 0; // R10
int32_t g30 = 0; // R11
int32_t g31 = 0; // R2
int32_t g32 = 0; // R3
int32_t g33 = 0; // R4
int32_t g34 = 0; // R5
int32_t g35 = 0; // R6
int32_t g36 = 0; // R7
int32_t g37 = 0; // R8
int32_t g38 = 0; // R9
int32_t g1 = -0x15ffffb3; // 0x8f6361f4
char * g2 = "\xff\xff"; // 0x8f67d950
int32_t g3 = 0xff0fff; // 0x8f67db7c
int32_t g4 = 0x6d0f0703; // 0x8f67f558
int32_t g5 = 0x1c9496e0; // 0x8f67f5a0
int32_t g6 = 0x65440030; // 0x8f69c66f
int32_t g7 = 0x746e6300; // 0x8f6a4e20
int32_t g8 = 1; // 0x8f6ac0f0
int32_t g9 = -1; // 0x8f6ac214
int32_t g10 = -0x70a00000; // 0x8f6ac224
char * g11 = "\xf1"; // 0x8f6affa8
int32_t g12 = 0; // 0x8f6b7988
int32_t g13 = 0; // 0x8f6b798c
int32_t g14 = 0; // 0x8f6b8ad0
int32_t g15 = 0; // 0x8f6b8ad4
char * g16; // 0x8f6c0628
char * g17; // 0x8f6c0649
int32_t (*g18)(int32_t, int32_t, int32_t) = NULL; // 0x8f6e0784
int32_t g19 = 0; // 0x8f6e0790
char * g20; // 0x8f6e0794
int16_t * g21 = NULL; // 0x8f70da9c
int32_t g22 = 0; // 0x8f70da9e
int32_t g23 = 0; // 0x8f7112f4
int32_t g24 = 0; // 0x8f7114ac
int32_t g25 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f67ae2c - 0x8f67b017
int32_t load_partition(int32_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = a3; // R6
    int32_t v2 = g23;
    int32_t v3;
    int32_t v4;
    int32_t v5;
    int32_t v6;
    if (a2 == 0) {
        // if_8f67ae50_0_true
        // branch -> 0x8f67ae6c
        // 0x8f67ae6c
        print_log(0, (int32_t)"%s: data is NULL\n", (int32_t)"load_partition", v2, v6, v5, 0, 0, 0, 0, v4, v3, 0);
        if (v2 != g23) {
            // 0x8f67aff0
            __stack_chk_fail();
            // branch -> 0x8f67aff4
        }
        // 0x8f67aff4
        return -1;
    }
    // 0x8f67ae60
    if (a1 == 0) {
        // 0x8f67ae6c
        print_log(0, (int32_t)"%s: partition entry is NULL\n", (int32_t)"load_partition", v2, v6, v5, 0, 0, 0, 0, v4, v3, 0);
        if (v2 != g23) {
            // 0x8f67aff0
            __stack_chk_fail();
            // branch -> 0x8f67aff4
        }
        // 0x8f67aff4
        return -1;
    }
    int32_t v7 = *(int32_t *)(g25 + 8); // 0x8f67ae88
    __aeabi_uldivmod(a3, (int64_t)v7);
    if (v7 != 0) {
        // 0x8f67ae9c
        return print_log(0, (int32_t)"%s: offset must be sector aligned: 0x%llx\n", (int32_t)"load_partition", 0, v1, a4, 0, 0, 0, 0, v4, v3, 0);
    }
    char v8 = *(char *)(a1 + 33); // 0x8f67aeb4
    char v9 = *(char *)(a1 + 32); // 0x8f67aeb8
    char v10 = *(char *)(a1 + 34); // 0x8f67aec0
    int32_t v11 = 0x10000 * (int32_t)v10 | (int32_t)v9 | 256 * (int32_t)v8; // 0x8f67aec4
    uint32_t v12 = 0x1000000 * (int32_t)*(char *)(a1 + 35) | v11; // 0x8f67aecc
    char v13 = *(char *)(a1 + 37); // 0x8f67aed0
    char v14 = *(char *)(a1 + 36); // 0x8f67aed4
    int32_t result = 512 * v11; // R0
    char v15 = *(char *)(a1 + 38); // 0x8f67aee0
    int32_t v16 = 0x10000 * (int32_t)v15 | (int32_t)v14 | 256 * (int32_t)v13; // 0x8f67aee4
    char v17 = *(char *)(a1 + 41); // 0x8f67aef0
    char v18 = *(char *)(a1 + 40); // 0x8f67aef4
    char v19 = *(char *)(a1 + 42); // 0x8f67af00
    int32_t v20 = 512 * v16 | v12 / 0x800000; // 0x8f67af04
    char v21 = *(char *)(a1 + 43); // 0x8f67af0c
    int32_t v22 = 0x1000000 * (int32_t)v21 | 0x10000 * (int32_t)v19 | (int32_t)v18 | 256 * (int32_t)v17; // 0x8f67af10
    char v23 = *(char *)(a1 + 45); // 0x8f67af18
    char v24 = *(char *)(a1 + 44); // 0x8f67af1c
    char v25 = *(char *)(a1 + 46); // 0x8f67af24
    uint32_t v26 = v22 + 1; // 0x8f67af3c
    uint32_t v27 = v26 - v12; // 0x8f67af44
    int32_t v28 = 512 * v27; // 0x8f67af50
    int32_t v29 = 512 * ((int32_t)(v22 == -1) - v16 + (0x10000 * (int32_t)v25 | (int32_t)v24 | 256 * (int32_t)v23) + (int32_t)(v26 < v12)) | v27 / 0x800000; // 0x8f67af54
    uint32_t v30 = v1 + a5; // 0x8f67af58
    uint32_t v31 = a4 + a6 + (int32_t)(v30 < v1); // 0x8f67af5c
    bool v32 = false;
    bool v33 = v31 >= v29; // 0x8f67af68
    if (v31 == v29) {
        // if_8f67af64_0_true
        v32 = v30 == v28;
        v33 = v30 >= v28;
        // branch -> after_if_8f67af64_0
    }
    // after_if_8f67af64_0
    if (!v32 && !((v33 ^ true))) {
        // 0x8f67af6c
        return get_entry_name(a1, v20, v30, v31, v6, v5, 0, 0);
    }
    if (a5 != a6) {
        // if_8f67afa4_0_true
        v29 = a6;
        v28 = a5;
        // branch -> after_if_8f67afa8_0
    }
    // after_if_8f67afa8_0
    if (v2 != g23) {
        // 0x8f67aff0
        __stack_chk_fail();
        // branch -> 0x8f67aff4
        // 0x8f67aff4
        return result;
    }
    uint32_t v34 = result + v1; // 0x8f67afb8
    int32_t v35;
    return generic_mmc_read_logical(v34, a4 + v20 + (int32_t)(v34 < result), v28, v29, g33, g34, g35, g36, g37, g38, g29, g30, g26, a2, a6, a7, a8, a9, v35, 0, 0, 0, 0);
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:10:24
