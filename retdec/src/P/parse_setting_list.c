//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t alloc_scm_command(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_pll_clock(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t panel_power_off(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t panel_power_on(int32_t a1, int32_t a2, int32_t a3);
int32_t parse_setting_list(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_arm_support_available(int32_t a1, int32_t a2, int32_t a3);
int32_t scm_call2(int32_t * a1, int32_t a2, int32_t a3);
char * scm_call2_atomic(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_a32(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t scm_call_atomic(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_atomic2(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_dload_mode(int32_t a1);
int32_t scm_init(int32_t a1);
char * scm_io_write(int32_t a1, int32_t a2, int32_t a3);
int32_t set_gpio(int32_t * a1, int32_t a2);
int32_t set_ldo(int32_t * a1, int32_t a2);
int32_t set_lvs(char * a1, int32_t a2);
int32_t set_pmic_gpio(char * a1, int32_t a2);
int32_t smc(int32_t a1, int32_t a2);
int32_t turn_off_backlight(int32_t a1, int32_t a2, int32_t a3);
int32_t turn_on_backlight(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g9 = 0; // LR
int32_t g10 = 0; // R0
int32_t g11 = 0; // R1
int32_t g12 = 0; // R11
int32_t g13 = 0; // R2
int32_t g14 = 0; // R3
int32_t g15 = 0; // R4
int32_t g16 = 0; // R5
int32_t g17 = 0; // R6
int32_t g18 = 0; // R7
int32_t g19 = 0; // R8
int32_t g1 = -1; // 0x8f6ac0d0
int32_t g2 = -1; // 0x8f6ac0d8
int32_t g3 = 0; // 0x8f6b8c84
int32_t (*g4)() = NULL; // 0x8f6b8c8c
int32_t (*g5)() = NULL; // 0x8f6b8c90
int32_t g6 = 0; // 0x8f7112f4
int32_t g7 = 0; // 0x8f7112fc
int32_t g8 = 0; // 0x8f711374

// ------------------------ Functions -------------------------

// Address range: 0x8f618030 - 0x8f61846f
int32_t parse_setting_list(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8f618030
    int32_t v1;
    int32_t v2 = v1; // bp-80
    int32_t v3;
    int32_t str = v3; // bp-76
    int32_t v4 = g6;
    int32_t v5;
    int32_t v6 = get_int_prop((int32_t)"power_supply_count", a1, (int32_t)&v2, v4, v5, a1, v1); // 0x8f618060
    int32_t v7; // R0
    int32_t result; // 0x8f6183fc_2
    int32_t v8; // bp+268
    if (v6 == 0) {
        int32_t v9 = v2; // 0x8f61806c
        if (v9 >= 0) {
            // 0x8f618080
            if (v9 > a3) {
                // 0x8f618090
                // branch -> 0x8f618098
                // 0x8f618098
                print_log(-1, (int32_t)"Too much power_supply setting for %s: %d\n", a4, v9, v5, a1, v9, v3, 0, 0, 0, 0, 0);
                v7 = -1;
                v8 = -1;
                // branch -> 0x8f6183e0
            } else {
                int32_t v10 = 0; // R5
                int32_t v11 = 0; // 0x8f6183c4
                if (v9 > 0) {
                    int32_t v12 = &str; // 0x8f6180b0_0
                    int32_t v13 = 0; // 0x8f6183d84152
                    // branch -> 0x8f6180a8
                    while (true) {
                        // 0x8f6180a8
                        memset((char *)&str, 0, 32);
                        int32_t v14 = (int32_t)"power_supply@%d"; // R2
                        int32_t v15 = v13; // R3
                        snprintf((char *)&str, 32, "power_supply@%d", v13);
                        int32_t v16; // 0x8f6180f061
                        int32_t v17; // 0x8f6180f063
                        if (get_subnode_offset(v12, a1, v14, v15) > -1) {
                            int32_t str2 = get_string_prop((int32_t)"type", v12, v14, v15, v13, a1, v2, str); // 0x8f61811c
                            int32_t str3 = str2; // R7
                            if (str2 == 0) {
                                // if_8f618124_0_true
                                v17 = v13;
                                v16 = (int32_t)"Invalid power supply @%d for %s\n";
                                // branch -> 0x8f6180ec
                              lab_0x8f6180ec_2:;
                                // 0x8f6180ec
                                // branch -> 0x8f6180f0
                            } else {
                                int32_t v18 = 8 * v10; // R10
                                int32_t strcmp_rc = strcmp((char *)str2, "gpio"); // 0x8f61813c
                                int32_t v19 = a2 + v18; // R8
                                int32_t v20 = strcmp_rc; // R11
                                int32_t v21; // 0x8f61837c
                                int32_t v22; // 0x8f61834c
                                if (strcmp_rc == 0) {
                                    // 0x8f61814c
                                    v15 = 1;
                                    *(char *)(8 * v10 + a2) = 1;
                                    print_log(2, (int32_t)"%s is called...\n", (int32_t)"parse_gpio_settings", v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                    char * mem = malloc(36); // 0x8f618168
                                    v18 = (int32_t)mem;
                                    if (mem == NULL) {
                                        // if_8f618170_0_true
                                        v22 = (int32_t)"gpio";
                                        // branch -> 0x8f61834c
                                      lab_0x8f61834c_4:
                                        // 0x8f61834c
                                        print_log(-1, (int32_t)"Out of memory for power supply@%s\n", v22, v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                        // branch -> 0x8f61838c
                                    } else {
                                        // 0x8f618180
                                        v14 = 36;
                                        memset(mem, v20, 36);
                                        if (get_gpio_setting(v12, v18, v14, v15, v13, a1, v2, str, 0, 0, 0) < 0) {
                                            // after_if_8f6181a0_0
                                            v21 = (int32_t)"Invalid gpio setting\n";
                                            // branch -> 0x8f61837c
                                          lab_0x8f61837c_4:
                                            // 0x8f61837c
                                            print_log(-1, v21, v14, v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                            free((char *)v18);
                                            v18 = 0;
                                            // branch -> 0x8f61838c
                                        }
                                    }
                                  lab_0x8f61838c:
                                    // 0x8f61838c
                                    *(int32_t *)(v19 + 4) = v18;
                                    if (*(int32_t *)(v19 + 4) == 0) {
                                      lab_0x8f6183a0_4:
                                        // 0x8f6183a0
                                        // branch -> 0x8f6180f0
                                        // 0x8f6180f0
                                        print_log(1, (int32_t)"Failed to parse %s %s\n", str3, v12, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                        // branch -> 0x8f6180f4
                                    } else {
                                      lab_if_8f618398_0_true_4:
                                        // if_8f618398_0_true
                                        v10++;
                                        // branch -> 0x8f6180f4
                                    }
                                  lab_0x8f6180f4_2:;
                                    int32_t v23 = v13 + 1; // 0x8f6180f8
                                    if (v23 >= v2) {
                                        // break -> 0x8f618100
                                        break;
                                    }
                                    v13 = v23;
                                    // continue -> 0x8f6180a8
                                    continue;
                                } else {
                                    int32_t strcmp_rc2 = strcmp((char *)str3, "pmic_gpio"); // 0x8f6181b4
                                    v20 = strcmp_rc2;
                                    if (strcmp_rc2 == 0) {
                                        // 0x8f6181c0
                                        *(char *)(v18 + a2) = 2;
                                        print_log(2, (int32_t)"%s is called...\n", (int32_t)"parse_pmic_gpio_settings", v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                        char * mem2 = malloc(36); // 0x8f6181d8
                                        v18 = (int32_t)mem2;
                                        if (mem2 == NULL) {
                                            // if_8f6181e0_0_true
                                            v22 = (int32_t)"pmic_gpio";
                                            // branch -> 0x8f61834c
                                            goto lab_0x8f61834c_4;
                                        } else {
                                            // 0x8f6181f0
                                            v14 = 36;
                                            memset(mem2, v20, 36);
                                            if (get_pmic_gpio_setting(v12, v18, v14, v15, v13, a1, v2, str, 0, 0, 0) >= 0) {
                                                goto lab_0x8f61838c;
                                            }
                                            // after_if_8f618210_0
                                            v21 = (int32_t)"Invalid pmic_gpio setting\n";
                                            // branch -> 0x8f61837c
                                            goto lab_0x8f61837c_4;
                                        }
                                      lab_0x8f61838c_2:
                                        // 0x8f61838c
                                        *(int32_t *)(v19 + 4) = v18;
                                        if (*(int32_t *)(v19 + 4) == 0) {
                                            goto lab_0x8f6183a0_4;
                                        }
                                        goto lab_if_8f618398_0_true_4;
                                    } else {
                                        int32_t strcmp_rc3 = strcmp((char *)str3, "ldo"); // 0x8f618224
                                        v20 = strcmp_rc3;
                                        if (strcmp_rc3 == 0) {
                                            // 0x8f618230
                                            v15 = 3;
                                            *(char *)(v18 + a2) = 3;
                                            print_log(2, (int32_t)"%s is called...\n", (int32_t)"parse_ldo_settings", v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                            char * mem3 = malloc(56); // 0x8f61824c
                                            v18 = (int32_t)mem3;
                                            if (mem3 == NULL) {
                                                // if_8f618254_0_true
                                                v22 = (int32_t)"ldo";
                                                // branch -> 0x8f61834c
                                                goto lab_0x8f61834c_4;
                                            } else {
                                                // 0x8f618264
                                                v14 = 56;
                                                memset(mem3, v20, 56);
                                                if (get_ldo_setting(v12, v18, v14, v15, v13, a1, v2, str, 0, 0, 0, 0) >= 0) {
                                                    goto lab_0x8f61838c_2;
                                                }
                                                // after_if_8f618284_0
                                                v21 = (int32_t)"Invalid ldo setting\n";
                                                // branch -> 0x8f61837c
                                                goto lab_0x8f61837c_4;
                                            }
                                          lab_0x8f61838c_3:
                                            // 0x8f61838c
                                            *(int32_t *)(v19 + 4) = v18;
                                            if (*(int32_t *)(v19 + 4) == 0) {
                                                goto lab_0x8f6183a0_4;
                                            }
                                            goto lab_if_8f618398_0_true_4;
                                        } else {
                                            int32_t strcmp_rc4 = strcmp((char *)str3, "lvs"); // 0x8f618298
                                            v20 = strcmp_rc4;
                                            if (strcmp_rc4 == 0) {
                                                // 0x8f6182a4
                                                v15 = 5;
                                                *(char *)(v18 + a2) = 5;
                                                print_log(2, (int32_t)"%s is called...\n", (int32_t)"parse_lvs_settings", v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                                char * mem4 = malloc(12); // 0x8f6182c0
                                                v18 = (int32_t)mem4;
                                                if (mem4 == NULL) {
                                                    // if_8f6182c8_0_true
                                                    v22 = (int32_t)"lvs";
                                                    // branch -> 0x8f61834c
                                                    goto lab_0x8f61834c_4;
                                                } else {
                                                    // 0x8f6182d8
                                                    v14 = 12;
                                                    memset(mem4, v20, 12);
                                                    if (get_lvs_setting(v12, v18, v14, v15, v13, a1, v2, str, 0, 0, 0) >= 0) {
                                                        goto lab_0x8f61838c_3;
                                                    }
                                                    // after_if_8f6182f8_0
                                                    v21 = (int32_t)"Invalid lvs setting\n";
                                                    // branch -> 0x8f61837c
                                                    goto lab_0x8f61837c_4;
                                                }
                                              lab_0x8f61838c_4:
                                                // 0x8f61838c
                                                *(int32_t *)(v19 + 4) = v18;
                                                if (*(int32_t *)(v19 + 4) == 0) {
                                                    goto lab_0x8f6183a0_4;
                                                }
                                                goto lab_if_8f618398_0_true_4;
                                            } else {
                                                int32_t strcmp_rc5 = strcmp((char *)str3, "lcd_bias"); // 0x8f61830c
                                                v20 = strcmp_rc5;
                                                if (strcmp_rc5 == 0) {
                                                    // 0x8f618318
                                                    v15 = 4;
                                                    *(char *)(v18 + a2) = 4;
                                                    print_log(2, (int32_t)"%s is called...\n", (int32_t)"parse_lcd_bias_settings", v15, v13, a1, v2, str, 0, 0, 0, 0, 0);
                                                    char * mem5 = malloc(8); // 0x8f618334
                                                    v18 = (int32_t)mem5;
                                                    if (mem5 == NULL) {
                                                        // 0x8f618340
                                                        v22 = (int32_t)"lcd_bias";
                                                        // branch -> 0x8f61834c
                                                        goto lab_0x8f61834c_4;
                                                    } else {
                                                        // 0x8f618354
                                                        v14 = 8;
                                                        memset(mem5, v20, 8);
                                                        if (get_lcd_bias_setting(v12, v18, v14, v15, v13, a1, v2, str) > -1) {
                                                            goto lab_0x8f61838c_4;
                                                        }
                                                        // 0x8f618374
                                                        v21 = (int32_t)"Invalid lcd_bias setting\n";
                                                        // branch -> 0x8f61837c
                                                        goto lab_0x8f61837c_4;
                                                    }
                                                  lab_0x8f61838c_8:;
                                                    int32_t v24 = v19; // 0x8f61838c
                                                    int32_t v25 = v18; // 0x8f61838c
                                                    *(int32_t *)(v24 + 4) = v25;
                                                    int32_t v26 = v19; // 0x8f618390
                                                    int32_t v27 = *(int32_t *)(v26 + 4); // 0x8f618390
                                                    if (v27 == 0) {
                                                        goto lab_0x8f6183a0_4;
                                                    }
                                                    goto lab_if_8f618398_0_true_4;
                                                } else {
                                                    // 0x8f6183b4
                                                    v17 = str3;
                                                    v16 = (int32_t)"Not support power supply type: %s for %s\n";
                                                    // branch -> 0x8f6180ec
                                                    goto lab_0x8f6180ec_2;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                          lab_0x8f6180f0:
                            // 0x8f6180f0
                            print_log(1, v16, v17, a4, v13, a1, v2, str, 0, 0, 0, 0, 0);
                            // branch -> 0x8f6180f4
                            goto lab_0x8f6180f4_2;
                        } else {
                            // 0x8f6180e0
                            v17 = v12;
                            v16 = (int32_t)"No %s found for %s\n";
                            // branch -> 0x8f6180ec
                            goto lab_0x8f6180ec_2;
                        }
                    }
                    // 0x8f618100
                    v11 = v10;
                    // branch -> 0x8f6183c4
                }
                // 0x8f6183c4
                v7 = v11;
                v8 = v11;
                // branch -> 0x8f6183e0
            }
            // 0x8f6183e0
            if (v4 != g6) {
                // 0x8f6183f4
                __stack_chk_fail();
                result = v7;
                // branch -> 0x8f6183f8
            } else {
                result = v8;
            }
            // 0x8f6183f8
            return result;
        }
        // if_8f618074_0_true
        // branch -> 0x8f618098
        // 0x8f618098
        print_log(-1, (int32_t)"Invalid power_supply_count setting for %s: %d\n", a4, v9, v5, a1, v9, v3, 0, 0, 0, 0, 0);
        v7 = -1;
        v8 = -1;
        // branch -> 0x8f6183e0
    } else {
        // 0x8f6183cc
        print_log(1, (int32_t)"No power supply defined for %s\n", a4, v4, v5, a1, v2, v3, 0, 0, 0, 0, 0);
        v7 = 0;
        v8 = 0;
        // branch -> 0x8f6183e0
    }
    // 0x8f6183e0
    if (v4 != g6) {
        // 0x8f6183f4
        __stack_chk_fail();
        result = v7;
        // branch -> 0x8f6183f8
    } else {
        result = v8;
    }
    // 0x8f6183f8
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 21
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:34:22
