//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_validate(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __utag_write(char * a1, int32_t a2, char * a3, int32_t a4);
int32_t adc_configure(int32_t * a1);
int32_t check_and_backup_partition(int32_t a1, int32_t result, int32_t a3, int32_t a4);
int32_t clock_lib2_branch_clk_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t clock_lib2_branch_set_rate(int32_t a1, int32_t a2, int32_t a3);
int32_t factory_kill_is_supported(char * a1, int32_t a2);
int32_t factory_otv_bypass(int32_t a1, int32_t a2);
int32_t fboot_cmd_erase_post_validate(int32_t a1, int32_t a2, int32_t a3);
void function_8f64abd0(void);
void function_8f64ac04(int32_t a1, int32_t a2, int32_t a3);
int32_t get_log_level_by_desc(char * a1, char * str2);
int32_t get_sector_start(void);
int32_t handle_fboot_command_erase(int32_t a1, int32_t a2);
int32_t is_factory_cable(void);
int32_t is_inductive_charger_present(int32_t a1, int32_t a2, int32_t a3);
int32_t md5_finish(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mmc_get_eraseunit_size(int32_t a1, int32_t a2);
int32_t pm8x41_uninit(int32_t a1);
char * print_log(int32_t a1, char * a2, int32_t a3, int32_t a4);
int32_t qup_blsp_i2c_init(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t qup_i2c_read_word(int32_t a1, int32_t a2, int32_t a3);
int32_t reboot_bootloader(int32_t a1, int32_t a2, int32_t a3);
int32_t strings_from(char * a1, int32_t a2, int32_t a3);
int32_t strings_split_from(char * str, int32_t a2);
int32_t ufs_erase(int32_t a1, int32_t a2, int32_t a3);
char * update_cmdline(char * a1, char * a2);
int32_t update_ker_tags_rdisk_addr(int32_t a1, int32_t a2, int32_t a3);
int32_t XXH32_digest(char * a1, int32_t a2);
int32_t XXH32_intermediateDigest(void);

// --------------------- Global Variables ---------------------

int32_t g22 = 0; // LR
int32_t g23 = 0; // R0
int32_t g24 = 0; // R1
int32_t g25 = 0; // R10
int32_t g26 = 0; // R11
int32_t g27 = 0; // R2
int32_t g28 = 0; // R3
int32_t g29 = 0; // R4
int32_t g30 = 0; // R5
int32_t g31 = 0; // R6
int32_t g32 = 0; // R7
int32_t g33 = 0; // R8
int32_t g34 = 0; // R9
char * g1; // 0x8f623ee8
int32_t (*g2)(int32_t) = (int32_t (*)(int32_t))-0x1a60cf58; // 0x8f656df8
int32_t g3 = 0x7325002f; // 0x8f686fbc
int32_t g4 = 0x65440030; // 0x8f69c66f
int32_t g5 = 0x65440031; // 0x8f69c693
int32_t g6 = 0; // 0x8f6a3ea0
char * g7 = "\x01"; // 0x8f6a3f48
char * g8; // 0x8f6a4e20
int32_t g9 = 1; // 0x8f6ac0f0
int32_t g10 = -1; // 0x8f6ac214
int32_t g11; // 0x8f6afe74
char g13 = 0; // 0x8f6afea8
int32_t g14 = 6; // 0x8f6afee0
int32_t g15 = 0; // 0x8f6b8b14
char * g16; // 0x8f6c0335
char * g17; // 0x8f6e069d
char * g18; // 0x8f6e06a4
char * g19; // 0x8f6ed800
char * g20; // 0x8f6ed801
int32_t g21 = 0; // 0x8f7112f4
int32_t * g12 = &g14; // 0x8f6afe7c

// ------------------------ Functions -------------------------

// Address range: 0x8f656968 - 0x8f656aef
char * print_log(int32_t a1, char * a2, int32_t a3, int32_t a4) {
    int32_t v1 = g29; // 0x8f656970
    int32_t v2 = g30; // 0x8f656970
    int32_t v3 = g31; // 0x8f656970
    int32_t v4 = g32; // 0x8f656970
    int32_t v5 = g33; // 0x8f656970
    int32_t v6 = g34; // 0x8f656970
    int32_t v7 = g25; // 0x8f656970
    int32_t v8 = g22; // 0x8f656970
    g34 = &g21;
    int32_t str;
    g31 = &str;
    g29 = a1;
    g25 = (int32_t)a2;
    int32_t v9 = g21;
    g23 = (int32_t)memset((char *)&str, 0, 1024);
    int32_t v10 = g11; // 0x8f6569a4
    g32 = v10;
    int32_t v11 = *(int32_t *)-0x70950188; // 0x8f6569a8
    g30 = v11;
    int32_t v12 = *(int32_t *)&g12; // 0x8f6569a8
    g33 = v12;
    int32_t v13; // 0x8f6569f0_0
    int32_t v14; // 0x8f6569f4_0
    int32_t v15; // 0x8f656a80_0
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20; // 0x8f656a58
    int32_t format; // 0x8f656a08
    int32_t v21; // 0x8f656a44
    int32_t v22; // 0x8f656a50
    int32_t v23; // 0x8f656a60
    int32_t v24; // 0x8f656a6c
    int32_t v25; // 0x8f656a7c
    int32_t v26; // 0x8f656aac
    if (*(char *)(v10 + 44) == 0) {
        // 0x8f6569b8
        if (g13 == 0) {
            // 0x8f6569c4
            if (*(char *)(v11 + 44) == 0) {
                uint32_t v27 = g29; // 0x8f6569d0
                if (v27 >= 3) {
                    // 0x8f6569d8
                    if (0x1000000 * v12 / 0x1000000 >= v27) {
                        // 0x8f6569e4
                        v13 = &a3;
                        v14 = 0x1000000 * g29 / 0x1000000;
                        v17 = v14;
                        memset((char *)&str, 0, 1024);
                        g24 = 1024;
                        format = g25;
                        g27 = format;
                        vsnprintf((char *)&str, 1024, (char *)format, v13);
                        g23 = strlen((char *)&str);
                        if (*(char *)&g20 != 0) {
                            // 0x8f656a34
                            if (*(char *)&g19 != 0) {
                                // 0x8f656a58
                                v20 = g29;
                                if (v20 <= 2) {
                                    // 0x8f656a60
                                    v23 = *(int32_t *)(g30 + 64);
                                    ram_logger_output((char *)&v17, 1024, format, v23, v18, v13, v14);
                                    v24 = *(int32_t *)(g32 + 64);
                                    g28 = v24;
                                    v16 = &v17;
                                    // branch -> 0x8f656ab0
                                    // 0x8f656ab0
                                    g23 = v16;
                                    g22 = -0x709a9548;
                                    ((int32_t (*)(int32_t))v24)(v16);
                                    // branch -> 0x8f656ab8
                                    // 0x8f656ab8
                                    g27 = v9;
                                    v19 = g21;
                                    g28 = v19;
                                    if (v9 != v19) {
                                        // 0x8f656ac8
                                        __stack_chk_fail();
                                        // branch -> 0x8f656acc
                                    }
                                    // 0x8f656acc
                                    g29 = v1;
                                    g30 = v2;
                                    g31 = v3;
                                    g32 = v4;
                                    g33 = v5;
                                    g34 = v6;
                                    g25 = v7;
                                    g22 = v8;
                                    return (char *)g23;
                                }
                                // 0x8f656a74
                                if (v20 > 7) {
                                    // 0x8f656aa4
                                    if (v20 <= 12) {
                                        // 0x8f656aac
                                        v26 = *(int32_t *)(g30 + 64);
                                        g28 = v26;
                                        v16 = &v17;
                                        // branch -> 0x8f656ab0
                                        // 0x8f656ab0
                                        g23 = v16;
                                        g22 = -0x709a9548;
                                        ((int32_t (*)(int32_t))v26)(v16);
                                        // branch -> 0x8f656ab8
                                    }
                                } else {
                                    // 0x8f656a7c
                                    v25 = *(int32_t *)(g30 + 64);
                                    v15 = &v17;
                                    ram_logger_output((char *)&v17, 1024, format, v25, v18, v13, v14);
                                    v17 = 0x1000000 * g29 / 0x1000000;
                                    g27 = uart_logger_output((char *)&v17, 1024, format, *(int32_t *)(g32 + 64));
                                    v17 = 0x1000000 * g29 / 0x1000000;
                                    g28 = (int32_t)&g2;
                                    v16 = v15;
                                    // branch -> 0x8f656ab0
                                    // 0x8f656ab0
                                    g23 = v16;
                                    g22 = -0x709a9548;
                                    ((int32_t (*)(int32_t))(int32_t)&g2)(v16);
                                    // branch -> 0x8f656ab8
                                }
                                // 0x8f656ab8
                                g27 = v9;
                                v19 = g21;
                                g28 = v19;
                                if (v9 != v19) {
                                    // 0x8f656ac8
                                    __stack_chk_fail();
                                    // branch -> 0x8f656acc
                                }
                                // 0x8f656acc
                                g29 = v1;
                                g30 = v2;
                                g31 = v3;
                                g32 = v4;
                                g33 = v5;
                                g34 = v6;
                                g25 = v7;
                                g22 = v8;
                                return (char *)g23;
                            }
                            // 0x8f656a44
                            v21 = *(int32_t *)(g30 + 60);
                            ram_logger_output((char *)&v17, 1024, format, v21, v18, v13, v14);
                            v22 = *(int32_t *)(g32 + 60);
                            g28 = v22;
                            v16 = &v17;
                            // branch -> 0x8f656ab0
                            // 0x8f656ab0
                            g23 = v16;
                            g22 = -0x709a9548;
                            ((int32_t (*)(int32_t))v22)(v16);
                            // branch -> 0x8f656ab8
                        }
                    }
                }
                // 0x8f656ab8
                g27 = v9;
                v19 = g21;
                g28 = v19;
                if (v9 != v19) {
                    // 0x8f656ac8
                    __stack_chk_fail();
                    // branch -> 0x8f656acc
                }
                // 0x8f656acc
                g29 = v1;
                g30 = v2;
                g31 = v3;
                g32 = v4;
                g33 = v5;
                g34 = v6;
                g25 = v7;
                g22 = v8;
                return (char *)g23;
            }
        }
    }
    // 0x8f6569e4
    v13 = &a3;
    v14 = 0x1000000 * g29 / 0x1000000;
    v17 = v14;
    memset((char *)&str, 0, 1024);
    g24 = 1024;
    format = g25;
    g27 = format;
    vsnprintf((char *)&str, 1024, (char *)format, v13);
    g23 = strlen((char *)&str);
    if (*(char *)&g20 != 0) {
        // 0x8f656a34
        if (*(char *)&g19 != 0) {
            // 0x8f656a58
            v20 = g29;
            if (v20 <= 2) {
                // 0x8f656a60
                v23 = *(int32_t *)(g30 + 64);
                ram_logger_output((char *)&v17, 1024, format, v23, v18, v13, v14);
                v24 = *(int32_t *)(g32 + 64);
                g28 = v24;
                v16 = &v17;
                // branch -> 0x8f656ab0
                // 0x8f656ab0
                g23 = v16;
                g22 = -0x709a9548;
                ((int32_t (*)(int32_t))v24)(v16);
                // branch -> 0x8f656ab8
                // 0x8f656ab8
                g27 = v9;
                v19 = g21;
                g28 = v19;
                if (v9 != v19) {
                    // 0x8f656ac8
                    __stack_chk_fail();
                    // branch -> 0x8f656acc
                }
                // 0x8f656acc
                g29 = v1;
                g30 = v2;
                g31 = v3;
                g32 = v4;
                g33 = v5;
                g34 = v6;
                g25 = v7;
                g22 = v8;
                return (char *)g23;
            }
            // 0x8f656a74
            if (v20 > 7) {
                // 0x8f656aa4
                if (v20 <= 12) {
                    // 0x8f656aac
                    v26 = *(int32_t *)(g30 + 64);
                    g28 = v26;
                    v16 = &v17;
                    // branch -> 0x8f656ab0
                    // 0x8f656ab0
                    g23 = v16;
                    g22 = -0x709a9548;
                    ((int32_t (*)(int32_t))v26)(v16);
                    // branch -> 0x8f656ab8
                }
            } else {
                // 0x8f656a7c
                v25 = *(int32_t *)(g30 + 64);
                v15 = &v17;
                ram_logger_output((char *)&v17, 1024, format, v25, v18, v13, v14);
                v17 = 0x1000000 * g29 / 0x1000000;
                g27 = uart_logger_output((char *)&v17, 1024, format, *(int32_t *)(g32 + 64));
                v17 = 0x1000000 * g29 / 0x1000000;
                g28 = (int32_t)&g2;
                v16 = v15;
                // branch -> 0x8f656ab0
                // 0x8f656ab0
                g23 = v16;
                g22 = -0x709a9548;
                ((int32_t (*)(int32_t))(int32_t)&g2)(v16);
                // branch -> 0x8f656ab8
            }
            // 0x8f656ab8
            g27 = v9;
            v19 = g21;
            g28 = v19;
            if (v9 != v19) {
                // 0x8f656ac8
                __stack_chk_fail();
                // branch -> 0x8f656acc
            }
            // 0x8f656acc
            g29 = v1;
            g30 = v2;
            g31 = v3;
            g32 = v4;
            g33 = v5;
            g34 = v6;
            g25 = v7;
            g22 = v8;
            return (char *)g23;
        }
        // 0x8f656a44
        v21 = *(int32_t *)(g30 + 60);
        ram_logger_output((char *)&v17, 1024, format, v21, v18, v13, v14);
        v22 = *(int32_t *)(g32 + 60);
        g28 = v22;
        v16 = &v17;
        // branch -> 0x8f656ab0
        // 0x8f656ab0
        g23 = v16;
        g22 = -0x709a9548;
        ((int32_t (*)(int32_t))v22)(v16);
        // branch -> 0x8f656ab8
    }
    // 0x8f656ab8
    g27 = v9;
    v19 = g21;
    g28 = v19;
    if (v9 != v19) {
        // 0x8f656ac8
        __stack_chk_fail();
        // branch -> 0x8f656acc
    }
    // 0x8f656acc
    g29 = v1;
    g30 = v2;
    g31 = v3;
    g32 = v4;
    g33 = v5;
    g34 = v6;
    g25 = v7;
    g22 = v8;
    return (char *)g23;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strdup(const char * s);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:57:50
