//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t bare_board_clk_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t can_write_partition(int32_t a1, uint32_t a2, int32_t a3);
int32_t charger_gone_irq_handler(int32_t (*a1)(int32_t), int32_t a2, int32_t a3);
int32_t dbval_free(char * a1, int32_t a2, int32_t a3);
int32_t dbval_pal_cid_get_secondary_serial_num_type(char * a1, int32_t a2, int32_t a3);
int32_t dbval_start_timer(int32_t a1, int32_t a2);
int32_t display_image(char * str3, int32_t a2, int32_t a3, int32_t a4);
int32_t fdt_check_header(int32_t * a1, int32_t a2, int32_t a3);
int32_t fdt_get_name(int32_t a1, int32_t a2, int32_t * a3);
int32_t fdt_offset_ptr(int32_t a1, int32_t a2, int32_t a3);
int32_t fdt_subnode_offset(char * a1, int32_t a2, char * str, int32_t a4, int32_t a5);
int32_t finalize_security_policies(int32_t a1, int32_t a2, int32_t a3);
void function_8f64a18c(void);
void function_8f64a1e0(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_check_bound_sig_allowed(int32_t a1, int32_t a2);
int32_t hab_su_srk_selection(int32_t a1, int32_t a2);
int32_t LZ4_decompress_safe_withPrefix64k(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mcs_habp_rsa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t mcs_habp_rsa_crt(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t mcs_rng_seed_data(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_pal_delete_user_partition(int32_t a1, int32_t a2);
int32_t mot_sst_pal_erase_token(int32_t a1, int32_t a2);
int32_t ondraw_44(void);
int32_t pm8x41_irq_mask_ack(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t pm8x41_irq_unmask(uint32_t a1, uint32_t a2);
int32_t power_source_detected(int32_t a1, int32_t a2, int32_t a3);
int32_t register_usb_connection_callback(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t resume_usb_detection(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t type_atoi_2(char * str, int32_t a2, int32_t a3);
int32_t XXH32(char * a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g48 = 0; // LR
int32_t g49 = 0; // R0
int32_t g50 = 0; // R1
int32_t g51 = 0; // R10
int32_t g52 = 0; // R12
int32_t g53 = 0; // R2
int32_t g54 = 0; // R3
int32_t g55 = 0; // R4
int32_t g56 = 0; // R5
int32_t g57 = 0; // R6
int32_t g58 = 0; // R7
int32_t g59 = 0; // R8
int32_t g60 = 0; // R9
bool g1 = false; // flagn
bool g2 = false; // flagv
int32_t g3 = -0x16d2bf09; // 0x8f634ac0
int32_t (*g4)() = (int32_t (*)())-0x16d2bff0; // 0x8f665d64
int32_t g5 = -0x16d2bff0; // 0x8f665ddc
int32_t g6 = -0x16d2bff0; // 0x8f6663f0
int32_t g7 = -0x16d2bff0; // 0x8f666470
int32_t g8 = -0x16d2bfd0; // 0x8f6664f4
int32_t g9 = 0x6e61000a; // 0x8f6826e7
char g10[2] = "/"; // 0x8f686fbc
int32_t g11 = 0x5b5e0029; // 0x8f687c45
char * g13[5] = {
    "Your device didn't start up successfully.\n",
    "Use the Software Repair Assistant on computer\n",
    "to repair your device.\n",
    "Connect your device to your computer to get\n",
    "the Software Repair Assistant.\n"
}; // 0x8f69cca0
char * g14[4] = {
    "Use the Software Repair Assistant on computer\n",
    "to repair your device.\n",
    "Connect your device to your computer to get\n",
    "the Software Repair Assistant.\n"
}; // 0x8f69cca4
char * g15[3] = {
    "to repair your device.\n",
    "Connect your device to your computer to get\n",
    "the Software Repair Assistant.\n"
}; // 0x8f69cca8
char * g16[2] = {
    "Connect your device to your computer to get\n",
    "the Software Repair Assistant.\n"
}; // 0x8f69ccac
char (*g17)[32] = "the Software Repair Assistant.\n"; // 0x8f69ccb0
int32_t g18 = 0; // 0x8f69ccc4
char * g19 = "\x01"; // 0x8f6a3f48
int32_t g20 = 0x746e6300; // 0x8f6a4e20
char * g21[2] = {
    "sp",
    "keystore"
}; // 0x8f6a7d98
char * g22 = "\x01"; // 0x8f6aca1c
char * g23 = "\x02"; // 0x8f6aca74
int32_t g24 = 0; // 0x8f6e0724
int32_t g25 = 0; // 0x8f6e0740
char * g26; // 0x8f6e0a00
char * g27; // 0x8f6e0a08
char * g28; // 0x8f6e0a09
int32_t g29 = 0; // 0x8f6e0a28
int32_t g30 = 0; // 0x8f6e0a44
int32_t g31 = 0; // 0x8f6e0a58
int32_t g32 = 0; // 0x8f70dab0
int32_t g33 = 0; // 0x8f7112f4
char * g34; // 0x8f711464
char * g35; // 0x8f711580
char * g36; // 0x8f711588
char * g37; // 0x8f711589
char g38 = 0; // 0x8f71158a
char g39 = 0; // 0x8f71158b
int32_t g40 = 0; // 0x8f712580
int32_t g41 = 0; // 0x8f712584
int32_t g42 = 0; // 0x8f712588
int32_t g43 = 0; // 0x8f71258c
int32_t g44 = 0; // 0x8f712590
int32_t g45 = 0; // 0x8f712594
int32_t g46 = 0; // 0x8f712598
int32_t g47 = 0; // 0x8f7125ec
char * g12[7] = {
    "         Start Up Failed:\n",
    (char *)&g9,
    "Your device didn't start up successfully.\n",
    "Use the Software Repair Assistant on computer\n",
    "to repair your device.\n",
    "Connect your device to your computer to get\n",
    "the Software Repair Assistant.\n"
}; // 0x8f69cc98

// ------------------------ Functions -------------------------

// Address range: 0x8f658270 - 0x8f65866f
int32_t LZ4_decompress_safe_withPrefix64k(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = g33;
    int32_t v4 = v1 + a3; // 0x8f658294
    int32_t v5 = v2 + a4; // 0x8f658298
    int32_t result;
    if (a4 == 0) {
        // 0x8f6582ec
        if (a3 == 1) {
            char v6 = *a1; // 0x8f6582f4
            result = v6 == 0 ? (int32_t)v6 : -1;
            // branch -> 0x8f658648
        } else {
            // 0x8f658644
            result = -1;
            // branch -> 0x8f658648
        }
        // 0x8f658648
        if (v3 != g33) {
            // 0x8f65865c
            __stack_chk_fail();
            // branch -> 0x8f658660
        }
        // 0x8f658660
        return result;
    }
    uint32_t v7 = v5 - 12; // 0x8f6582bc
    int32_t v8 = v5 - 8; // R10
    int32_t v9;
    int32_t v10 = &v9; // 0x8f658404_0
    int32_t v11 = v2; // 0x8f658540
    // branch -> 0x8f658510
    while (true) {
        int32_t v12 = (int32_t)*(char *)v1; // 0x8f658510
        int32_t v13 = v12; // R8
        int32_t v14 = v1 + 1; // 0x8f658514
        int32_t v15 = v14; // 0x8f65853c
        int32_t v16 = v12 / 16; // 0x8f658540
        int32_t v17; // R4
        uint32_t v18; // 0x8f658320
        int32_t v19; // 0x8f658328
        if ((v12 & -16) == 240) {
            // if_8f658520_0_true
            if (v14 < v4) {
                int32_t v20 = 15; // 0x8f658310
                int32_t v21 = v14; // 0x8f65830c
                int32_t v22 = 255; // 0x8f658304
                while (true) {
                    // 0x8f658304
                    if (v22 == 255) {
                        int32_t v23 = v21 + 1; // 0x8f65830c
                        int32_t v24 = (int32_t)*(char *)v21; // 0x8f65830c
                        int32_t v25 = v24 + v20; // 0x8f658310
                        if (v23 >= v4) {
                            v15 = v23;
                            v16 = v25;
                            // break -> 0x8f65831c
                            break;
                        }
                        v20 = v25;
                        v21 = v23;
                        v22 = v24;
                        // continue -> 0x8f658304
                        continue;
                    } else {
                        v15 = v21;
                        v16 = v20;
                    }
                }
                // 0x8f65831c
                v18 = v16 + v11;
                v17 = v18;
                v19 = v16 + v15;
                if (v18 <= v7) {
                  lab_0x8f658330:
                    // 0x8f658330
                    if (v19 <= v4 - 8) {
                        int32_t v26 = v11; // 0x8f658340
                        int32_t v27 = v15; // 0x8f658344
                        while (true) {
                            char v28 = *(char *)(v27 + 1); // 0x8f65833c
                            result = v26 + 8;
                            char v29 = *(char *)v27; // 0x8f658344
                            int32_t v30 = v27 + 8; // R12
                            char v31 = *(char *)(v27 + 2); // 0x8f658350
                            char v32 = *(char *)(v27 + 3); // 0x8f658358
                            int32_t v33 = 0x1000000 * (int32_t)v32 | 0x10000 * (int32_t)v31 | (int32_t)v29 | 256 * (int32_t)v28; // R3
                            *(char *)v26 = v29;
                            *(char *)(result - 7) = (char)(v33 / 256);
                            uint32_t v34 = v33; // 0x8f65836c
                            *(char *)(result - 6) = (char)(v34 / 0x10000);
                            *(char *)(result - 5) = (char)(v34 / 0x1000000);
                            int32_t v35 = v30; // 0x8f65837c
                            char v36 = *(char *)(v35 - 3); // 0x8f65837c
                            char v37 = *(char *)(v35 - 4); // 0x8f658380
                            char v38 = *(char *)(v35 - 2); // 0x8f658388
                            char v39 = *(char *)(v35 - 1); // 0x8f658390
                            v33 = 0x1000000 * (int32_t)v39 | 0x10000 * (int32_t)v38 | (int32_t)v37 | 256 * (int32_t)v36;
                            *(char *)(result - 4) = v37;
                            *(char *)(result - 3) = (char)(v33 / 256);
                            uint32_t v40 = v33; // 0x8f6583a4
                            *(char *)(result - 2) = (char)(v40 / 0x10000);
                            *(char *)(result - 1) = (char)(v40 / 0x1000000);
                            int32_t v41 = result; // 0x8f6583b4
                            int32_t v42 = v41 - v17; // 0x8f6583b4
                            if (v41 < v17) {
                                // 0x8f65833c
                                v26 = v41;
                                v27 = v30;
                                // branch -> 0x8f65833c
                                continue;
                            } else {
                                int32_t v43 = v13 % 16; // 0x8f6583c0
                                v13 = v43;
                                int32_t v44 = v30 - v42; // 0x8f6583c4
                                int32_t v45 = v44 + 2; // 0x8f6583cc
                                v30 = v45;
                                char v46 = *(char *)(v44 + 1); // 0x8f6583d0
                                int32_t v47 = (int32_t)*(char *)v44 | 256 * (int32_t)v46; // 0x8f6583d8
                                int32_t v48 = v17 - v47; // 0x8f6583dc
                                int32_t v49 = v48; // R2
                                if (v43 == 15) {
                                    // 0x8f65854c
                                    if (v45 >= v4 - 6) {
                                        // 0x8f658558
                                        v30 = v44 + 3;
                                        v13 = (int32_t)*(char *)v45 + 15;
                                        // branch -> 0x8f6583e4
                                    }
                                }
                                // 0x8f6583e4
                                result = v17 + 4;
                                char v50 = *(char *)v48; // 0x8f6583f0
                                int32_t v51; // R1
                                if (v47 > 3) {
                                    char v52 = *(char *)(v48 + 1); // 0x8f658568
                                    v49 = v48 + 4;
                                    char v53 = *(char *)(v48 + 2); // 0x8f658574
                                    char v54 = *(char *)(v48 + 3); // 0x8f65857c
                                    v33 = 0x1000000 * (int32_t)v54 | 0x10000 * (int32_t)v53 | 256 * (int32_t)v52 | (int32_t)v50;
                                    *(char *)v17 = v50;
                                    *(char *)(v17 + 1) = (char)(v33 / 256);
                                    uint32_t v55 = v33; // 0x8f658590
                                    *(char *)(v17 + 2) = (char)(v55 / 0x10000);
                                    *(char *)(v17 + 3) = (char)(v55 / 0x1000000);
                                    v33 = result;
                                    // branch -> 0x8f65846c
                                } else {
                                    // 0x8f6583f8
                                    *(char *)v17 = v50;
                                    int32_t v56 = v49; // 0x8f6583fc
                                    v51 = v56 + 4;
                                    *(char *)(v17 + 1) = *(char *)(v56 + 1);
                                    *(char *)(v17 + 2) = *(char *)(v49 + 2);
                                    *(char *)(v17 + 3) = *(char *)(v49 + 3);
                                    v33 = result;
                                    int32_t v57 = *(int32_t *)(4 * (result - v51) + v10 - 36); // 0x8f658428
                                    int32_t v58 = v51 - v57; // 0x8f658430
                                    v49 = v58;
                                    char v59 = *(char *)v58; // 0x8f658434
                                    char v60 = *(char *)(v58 + 1); // 0x8f658438
                                    char v61 = *(char *)(v58 + 2); // 0x8f658440
                                    char v62 = *(char *)(v58 + 3); // 0x8f658448
                                    v51 = 0x1000000 * (int32_t)v62 | 0x10000 * (int32_t)v61 | 256 * (int32_t)v60 | (int32_t)v59;
                                    *(char *)(v17 + 4) = v59;
                                    *(char *)(v17 + 5) = (char)(v51 / 256);
                                    *(char *)(v17 + 6) = (char)(v51 / 0x10000);
                                    *(char *)(v17 + 7) = (char)(v51 / 0x1000000);
                                    // branch -> 0x8f65846c
                                }
                                uint32_t v63 = v13 + result; // 0x8f65846c
                                result = v63;
                                if (v63 > v8) {
                                    // 0x8f658478
                                    if (v63 > v5 - 5) {
                                        // 0x8f658638
                                        // branch -> 0x8f658638
                                    } else {
                                        int32_t v64 = v33; // 0x8f658488
                                        int32_t v65 = v49; // 0x8f658484
                                        char v66 = *(char *)(v65 + 1); // 0x8f658484
                                        v33 = v64 + 8;
                                        char v67 = *(char *)v65; // 0x8f65848c
                                        v49 = v65 + 8;
                                        char v68 = *(char *)(v65 + 2); // 0x8f658498
                                        char v69 = *(char *)(v65 + 3); // 0x8f6584a0
                                        v51 = 0x1000000 * (int32_t)v69 | 0x10000 * (int32_t)v68 | (int32_t)v67 | 256 * (int32_t)v66;
                                        *(char *)v64 = v67;
                                        *(char *)(v33 - 7) = (char)(v51 / 256);
                                        uint32_t v70 = v51; // 0x8f6584b4
                                        *(char *)(v33 - 6) = (char)(v70 / 0x10000);
                                        *(char *)(v33 - 5) = (char)(v70 / 0x1000000);
                                        int32_t v71 = v49; // 0x8f6584c4
                                        char v72 = *(char *)(v71 - 3); // 0x8f6584c4
                                        char v73 = *(char *)(v71 - 4); // 0x8f6584c8
                                        char v74 = *(char *)(v71 - 2); // 0x8f6584d0
                                        char v75 = *(char *)(v71 - 1); // 0x8f6584d8
                                        v51 = 0x1000000 * (int32_t)v75 | 0x10000 * (int32_t)v74 | (int32_t)v73 | 256 * (int32_t)v72;
                                        *(char *)(v33 - 4) = v73;
                                        *(char *)(v33 - 3) = (char)(v51 / 256);
                                        uint32_t v76 = v51; // 0x8f6584ec
                                        *(char *)(v33 - 2) = (char)(v76 / 0x10000);
                                        *(char *)(v33 - 1) = (char)(v76 / 0x1000000);
                                        int32_t v77 = v33; // 0x8f6584fc
                                        // branch -> 0x8f658484
                                        while (v77 < v8) {
                                            // 0x8f658484
                                            v64 = v77;
                                            v65 = v49;
                                            v66 = *(char *)(v65 + 1);
                                            v33 = v64 + 8;
                                            v67 = *(char *)v65;
                                            v49 = v65 + 8;
                                            v68 = *(char *)(v65 + 2);
                                            v69 = *(char *)(v65 + 3);
                                            v51 = 0x1000000 * (int32_t)v69 | 0x10000 * (int32_t)v68 | (int32_t)v67 | 256 * (int32_t)v66;
                                            *(char *)v64 = v67;
                                            *(char *)(v33 - 7) = (char)(v51 / 256);
                                            v70 = v51;
                                            *(char *)(v33 - 6) = (char)(v70 / 0x10000);
                                            *(char *)(v33 - 5) = (char)(v70 / 0x1000000);
                                            v71 = v49;
                                            v72 = *(char *)(v71 - 3);
                                            v73 = *(char *)(v71 - 4);
                                            v74 = *(char *)(v71 - 2);
                                            v75 = *(char *)(v71 - 1);
                                            v51 = 0x1000000 * (int32_t)v75 | 0x10000 * (int32_t)v74 | (int32_t)v73 | 256 * (int32_t)v72;
                                            *(char *)(v33 - 4) = v73;
                                            *(char *)(v33 - 3) = (char)(v51 / 256);
                                            v76 = v51;
                                            *(char *)(v33 - 2) = (char)(v76 / 0x10000);
                                            *(char *)(v33 - 1) = (char)(v76 / 0x1000000);
                                            v77 = v33;
                                            // continue -> 0x8f658484
                                        }
                                        // 0x8f658504
                                        if (v77 < result) {
                                            for (int32_t i = v77; i < result; i++) {
                                                int32_t v78 = v49; // 0x8f6585a8
                                                v49 = v78 + 1;
                                                *(char *)i = *(char *)v78;
                                                // continue -> 0x8f6585a8
                                            }
                                            // 0x8f65850c
                                            v11 = result;
                                            // branch -> 0x8f658510
                                            break;
                                        }
                                        // 0x8f65850c
                                        v11 = result;
                                        // branch -> 0x8f658510
                                        break;
                                    }
                                    // 0x8f658638
                                    // branch -> 0x8f658648
                                    // 0x8f658648
                                    if (v3 != g33) {
                                        // 0x8f65865c
                                        __stack_chk_fail();
                                        // branch -> 0x8f658660
                                    }
                                    // 0x8f658660
                                    return v1 - v30 - 1;
                                }
                                int32_t v79 = v33; // 0x8f6585b8
                                int32_t v80 = v49; // 0x8f6585b4
                                char v81 = *(char *)(v80 + 1); // 0x8f6585b4
                                v33 = v79 + 8;
                                char v82 = *(char *)v80; // 0x8f6585bc
                                v49 = v80 + 8;
                                char v83 = *(char *)(v80 + 2); // 0x8f6585c8
                                char v84 = *(char *)(v80 + 3); // 0x8f6585d0
                                v51 = 0x1000000 * (int32_t)v84 | 0x10000 * (int32_t)v83 | (int32_t)v82 | 256 * (int32_t)v81;
                                *(char *)v79 = v82;
                                *(char *)(v33 - 7) = (char)(v51 / 256);
                                uint32_t v85 = v51; // 0x8f6585e4
                                *(char *)(v33 - 6) = (char)(v85 / 0x10000);
                                *(char *)(v33 - 5) = (char)(v85 / 0x1000000);
                                int32_t v86 = v49; // 0x8f6585f4
                                char v87 = *(char *)(v86 - 3); // 0x8f6585f4
                                char v88 = *(char *)(v86 - 4); // 0x8f6585f8
                                char v89 = *(char *)(v86 - 2); // 0x8f658600
                                char v90 = *(char *)(v86 - 1); // 0x8f658608
                                v51 = 0x1000000 * (int32_t)v90 | 0x10000 * (int32_t)v89 | (int32_t)v88 | 256 * (int32_t)v87;
                                *(char *)(v33 - 4) = v88;
                                *(char *)(v33 - 3) = (char)(v51 / 256);
                                uint32_t v91 = v51; // 0x8f65861c
                                *(char *)(v33 - 2) = (char)(v91 / 0x10000);
                                *(char *)(v33 - 1) = (char)(v91 / 0x1000000);
                                int32_t v92 = result; // 0x8f65862c
                                // branch -> 0x8f6585b4
                                while (v33 < v92) {
                                    // 0x8f6585b4
                                    v79 = v33;
                                    v80 = v49;
                                    v81 = *(char *)(v80 + 1);
                                    v33 = v79 + 8;
                                    v82 = *(char *)v80;
                                    v49 = v80 + 8;
                                    v83 = *(char *)(v80 + 2);
                                    v84 = *(char *)(v80 + 3);
                                    v51 = 0x1000000 * (int32_t)v84 | 0x10000 * (int32_t)v83 | (int32_t)v82 | 256 * (int32_t)v81;
                                    *(char *)v79 = v82;
                                    *(char *)(v33 - 7) = (char)(v51 / 256);
                                    v85 = v51;
                                    *(char *)(v33 - 6) = (char)(v85 / 0x10000);
                                    *(char *)(v33 - 5) = (char)(v85 / 0x1000000);
                                    v86 = v49;
                                    v87 = *(char *)(v86 - 3);
                                    v88 = *(char *)(v86 - 4);
                                    v89 = *(char *)(v86 - 2);
                                    v90 = *(char *)(v86 - 1);
                                    v51 = 0x1000000 * (int32_t)v90 | 0x10000 * (int32_t)v89 | (int32_t)v88 | 256 * (int32_t)v87;
                                    *(char *)(v33 - 4) = v88;
                                    *(char *)(v33 - 3) = (char)(v51 / 256);
                                    v91 = v51;
                                    *(char *)(v33 - 2) = (char)(v91 / 0x10000);
                                    *(char *)(v33 - 1) = (char)(v91 / 0x1000000);
                                    v92 = result;
                                    // continue -> 0x8f6585b4
                                }
                                // 0x8f65850c
                                v11 = v92;
                                // branch -> 0x8f658510
                                break;
                            }
                        }
                    }
                }
                // 0x8f65852c
                if (v4 == v19) {
                    // 0x8f658534
                    if (v18 <= v5) {
                        // 0x8f65853c
                        memcpy((char *)v11, (char *)v15, v16);
                        // branch -> 0x8f658648
                        // 0x8f658648
                        if (v3 != g33) {
                            // 0x8f65865c
                            __stack_chk_fail();
                            // branch -> 0x8f658660
                        }
                        // 0x8f658660
                        return v17 - v2;
                    }
                }
                // 0x8f658638
                // branch -> 0x8f658648
                // 0x8f658648
                if (v3 != g33) {
                    // 0x8f65865c
                    __stack_chk_fail();
                    // branch -> 0x8f658660
                }
                // 0x8f658660
                return v1 - v15 - 1;
            }
            v15 = v14;
            v16 = 15;
        }
        // 0x8f65831c
        v18 = v16 + v11;
        v17 = v18;
        v19 = v16 + v15;
        if (v18 <= v7) {
            goto lab_0x8f658330;
        }
        // 0x8f65852c
        if (v4 == v19) {
            // 0x8f658534
            if (v18 <= v5) {
                // 0x8f65853c
                memcpy((char *)v11, (char *)v15, v16);
                // branch -> 0x8f658648
                // 0x8f658648
                if (v3 != g33) {
                    // 0x8f65865c
                    __stack_chk_fail();
                    // branch -> 0x8f658660
                }
                // 0x8f658660
                return v17 - v2;
            }
        }
        // 0x8f658638
        // branch -> 0x8f658648
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// int isalpha(int c);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strtok(char * restrict s, const char * restrict delim);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:45:05
