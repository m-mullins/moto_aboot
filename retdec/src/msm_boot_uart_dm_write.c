//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t check_reboot_mode(char * a1, int32_t a2, int32_t a3);
int32_t delay(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
void function_8f60e190(int32_t a1);
int32_t mdp_select_pipe_type_isra_0(int32_t a1, int32_t * a2);
int32_t mdss_mdp_set_flush_isra_1(int32_t a1, int32_t * a2);
int32_t mdss_smp_alloc(int32_t a1, int32_t a2, int32_t a3, int32_t result2);
int32_t mdss_source_pipe_config(int32_t * a1, int32_t * a2, int32_t * a3);
int32_t mmc_erase_card(void);
int32_t mmc_get_ext_csd_isra_11(char * a1, int32_t * a2);
int32_t mmc_parse_response(char * a1, int32_t a2);
int32_t mmc_set_ddr_mode(int32_t a1, int32_t * a2, int32_t a3);
int32_t mmc_set_drv_type(char * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t mmc_set_hs200_mode(char * a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t mmc_set_hs_interface(char * a1);
int32_t mmc_stop_command(char * a1);
int32_t mmc_zero_out(int32_t a1, int32_t a2, int32_t a3);
int32_t msm_boot_uart_dm_write(int32_t a1, int32_t a2, int32_t a3);
int32_t platform_set_periodic_timer(int32_t a1, int32_t a2, int32_t a3);
int32_t qtimer_get_frequency(void);
int32_t qtimer_irq(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t set_restart_reason(int32_t a1);
int32_t uart_dm_init(int32_t a1, int32_t * a2, int32_t * a3);

// --------------------- Global Variables ---------------------

int32_t g15 = 0; // LR
int32_t g16 = 0; // R0
int32_t g17 = 0; // R1
int32_t g18 = 0; // R2
int32_t g19 = 0; // R3
int32_t g20 = 0; // R4
int32_t g21 = 0; // R5
int32_t g22 = 0; // R6
int32_t g23 = 0; // R7
int32_t g24 = 0; // R8
int32_t g25 = 0; // R9
bool g1 = false; // flagz
int32_t g2 = 1; // 0x8f6ac0f0
int32_t g3 = 0; // 0x8f6b8abc
int32_t g4 = 0; // 0x8f6b8ac0
int32_t g5 = 0; // 0x8f6b8ac4
int32_t (*g6)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t) = NULL; // 0x8f6b8ac8
int32_t g7 = 0; // 0x8f6b8acc
int32_t g8 = 0; // 0x8f6b8ad8
int32_t g9 = 0; // 0x8f6b8adc
char * g10; // 0x8f6b8aec
char g11 = 0; // 0x8f6b8aed
int32_t g12 = 0; // 0x8f6b8af0
char * g13; // 0x8f6b8af4
int32_t g14 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f60d358 - 0x8f60d507
int32_t msm_boot_uart_dm_write(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3; // R2
    int32_t v2 = g20; // 0x8f60d364
    int32_t v3 = g21; // 0x8f60d364
    int32_t v4 = g23; // 0x8f60d364
    int32_t v5 = g24; // 0x8f60d364
    int32_t v6 = g14;
    int32_t v7 = v6; // R0
    g20 = a2;
    int32_t result; // 0x8f60d4fc_2
    int32_t v8;
    int32_t v9;
    int32_t v10; // 0x8f60d3c4
    if (a2 == 0 || a3 == 0) {
        // after_if_8f60d384_0.thread
        g21 = 1;
        v7 = 3;
        v8 = v6;
        result = 3;
        // branch -> 0x8f60d3ac
      lab_0x8f60d3ac:
        // 0x8f60d3ac
        v1 = v6;
        if (v6 == v8) {
            // 0x8f60d4f8
            g20 = v2;
            g21 = v3;
            g23 = v4;
            g24 = v5;
            return result;
        }
        // 0x8f60d3c0
        __stack_chk_fail();
        v9 = g20;
        v10 = g21;
        // branch -> 0x8f60d3c4
    } else {
        // after_if_8f60d384_0.thread65
        g21 = 0;
        v9 = a2;
        v10 = 0;
        // branch -> 0x8f60d3c4
    }
    int32_t v11 = v10; // 0x8f60d3d4
    int32_t v12 = v10; // 0x8f60d3c8
    // branch -> 0x8f60d3c8
    int32_t v13; // 0x8f60d3cc
    while (true) {
        // 0x8f60d3c8
        v13 = v12 + 1;
        int32_t v14 = v11; // 0x8f60d3dc
        if (*(char *)(v12 + v9) == 10) {
            int32_t v15 = v11 + 1; // 0x8f60d3d4
            g21 = v15;
            v14 = v15;
            // branch -> after_if_8f60d3d4_0
        }
        int32_t v16 = v14 + 1; // 0x8f60d3dc
        g21 = v16;
        if (v13 == v1) {
            // break -> 0x8f60d3e4
            break;
        }
        v11 = v16;
        v12 = v13;
        // continue -> 0x8f60d3c8
    }
    int32_t v17 = a1 + 164; // 0x8f60d3e4
    int32_t * v18 = (int32_t *)v17; // 0x8f60d3e4_0
    int32_t v19; // R10
    int32_t v20;
    if ((*v18 & 8) == 0) {
        int32_t v21 = *(int32_t *)(a1 + 180); // 0x8f60d41832
        if ((v21 & 128) == 0) {
            // 0x8f60d424
            v7 = udelay(1, v17, v13, v21);
            int32_t v22 = *(int32_t *)(a1 + 180); // 0x8f60d41872
            if ((v22 & 128) == 0) {
                v7 = udelay(1, v17, v1, v22);
                int32_t v23 = *(int32_t *)(a1 + 180); // 0x8f60d418
                while ((v23 & 128) == 0) {
                    // 0x8f60d424
                    v7 = udelay(1, v17, v1, v23);
                    v23 = *(int32_t *)(a1 + 180);
                    // continue -> 0x8f60d424
                }
                // 0x8f60d3f8
                v19 = &g2;
                v20 = g2;
                g2 = v20 + 1;
                if (v20 == 0) {
                  lab_0x8f60d410:
                    // 0x8f60d410
                    function_8f619448(v7);
                    // branch -> 0x8f60d430
                }
              lab_0x8f60d430:;
                uint32_t v24 = g21; // 0x8f60d430
                int32_t v25 = (int32_t)(v24 % 4 != 0) + v24 / 4; // R11
                int32_t v26 = v24 - 4; // R9
                g24 = 0;
                *(int32_t *)(a1 + 64) = v24;
                *(int32_t *)(a1 + 168) = 768;
                int32_t * v27; // 0x8f60d390_0
                int32_t v28; // 0x8f60d394
                if (g24 < v25) {
                    int32_t v29 = g21; // 0x8f60d458
                    // branch -> 0x8f60d458
                    while (true) {
                        int32_t v30 = v29; // 0x8f60d460
                        if (v29 > 3) {
                            // if_8f60d45c_0_true
                            g21 = 4;
                            v30 = 4;
                            // branch -> after_if_8f60d45c_0
                        }
                        // after_if_8f60d45c_0
                        g21 = 0;
                        int32_t v31 = 0; // R3
                        g23 = 0;
                        int32_t v32 = 0; // 0x8f60d4e061
                        if (v30 > 0) {
                            int32_t v33 = 0; // 0x8f60d4b857
                            int32_t v34 = 0; // 0x8f60d484
                            int32_t v35 = 0; // 0x8f60d490
                            while (true) {
                                char * v36 = (char *)(g20 + v35); // 0x8f60d480_0
                                int32_t v37 = 8 * v34; // 0x8f60d484
                                v1 = v37;
                                int32_t v38;
                                int32_t v39; // 0x8f60d4bc
                                if (*v36 == 10) {
                                    // if_8f60d498_0_true
                                    *v36 = (char)-128;
                                    uint32_t v40 = v1 % 256; // 0x8f60d49813
                                    v39 = v31;
                                    v38 = (v40 == 0 ? 13 : v40 < 32 ? 13 << v40 : 0) | g21;
                                    // branch -> 0x8f60d4bc
                                } else {
                                    int32_t v41 = v35 + 1; // 0x8f60d4a4
                                    g23 = v41;
                                    int32_t v42 = (int32_t)*v36; // 0x8f60d4b0
                                    g23 = v41 % 256;
                                    uint32_t v43 = v37 & 248; // 0x8f60d4b8
                                    int32_t v44 = v43 == 0 ? v42 : v43 < 32 ? v42 << v43 : 0; // 0x8f60d4b8
                                    v39 = v34;
                                    v38 = v44 | v33;
                                    // branch -> 0x8f60d4bc
                                }
                                // 0x8f60d4bc
                                g21 = v38;
                                int32_t v45 = v39 + 1; // 0x8f60d4bc
                                v31 = v45;
                                if (v45 < v30) {
                                    // 0x8f60d4bc
                                    v33 = v38;
                                    v34 = v45;
                                    v35 = g23;
                                    // branch -> 0x8f60d480
                                    continue;
                                } else {
                                    v32 = v38;
                                }
                            }
                        }
                        int32_t v46 = *v18; // 0x8f60d4c820
                        if ((v46 & 4) == 0) {
                            udelay(1, v30, v17, v46);
                            int32_t v47 = *v18; // 0x8f60d4c8
                            while ((v47 & 4) == 0) {
                                // 0x8f60d4d4
                                udelay(1, v30, v17, v47);
                                v47 = *v18;
                                // continue -> 0x8f60d4d4
                            }
                            // 0x8f60d4c4
                            v32 = g21;
                            // branch -> 0x8f60d4e0
                        }
                        // 0x8f60d4e0
                        *(int32_t *)(a1 + 256) = v32;
                        g20 += g23;
                        int32_t v48 = v26; // 0x8f60d4e8
                        g21 = v48;
                        int32_t v49 = g24 + 1; // 0x8f60d4ec
                        g24 = v49;
                        v26 = v48 - 4;
                        if (v49 >= v25) {
                            // break -> 0x8f60d390
                            break;
                        }
                        v29 = v48;
                        // continue -> 0x8f60d458
                    }
                    // 0x8f60d390
                    v27 = (int32_t *)v19;
                    v28 = *v27 - 1;
                    g20 = v28;
                    *v27 = v28;
                    if (g20 == 0) {
                      lab_0x8f60d3a4:
                        // 0x8f60d3a4
                        function_8f619438();
                        // branch -> 0x8f60d3a8
                    }
                  lab_0x8f60d3a8:
                    // 0x8f60d3a8
                    v7 = 0;
                    v8 = g14;
                    result = 0;
                    // branch -> 0x8f60d3ac
                    goto lab_0x8f60d3ac;
                }
                // 0x8f60d390
                v27 = (int32_t *)v19;
                v28 = *v27 - 1;
                g20 = v28;
                *v27 = v28;
                if (g20 == 0) {
                    goto lab_0x8f60d3a4;
                }
                goto lab_0x8f60d3a8;
            }
        }
    }
    // 0x8f60d3f8
    v19 = &g2;
    v20 = g2;
    g2 = v20 + 1;
    if (v20 == 0) {
        goto lab_0x8f60d410;
    }
    goto lab_0x8f60d430;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 22
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:33:58
