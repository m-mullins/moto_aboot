//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t bq24296_chg_enable(int32_t result, int32_t a2, int32_t a3);
int32_t bq24296_config_for_fact_cbl(void);
int32_t clk_disable(int32_t a1, int32_t a2);
int32_t clk_enable(int32_t a1, int32_t a2);
int32_t dbval_pal_get_serial_num_type(char * a1, int32_t a2, int32_t a3);
int32_t dbval_pal_rand(char * a1, int32_t a2);
int32_t fboot_oem_early_init(void);
int32_t fboot_oem_init(void);
void function_8f64b0ac(void);
void function_8f64b108(int32_t a1, int32_t a2, int32_t a3);
int32_t get_barcode_scale(int32_t a1, int32_t a2);
int32_t get_barcode_width(void);
int32_t get_product_id_by_name(char * a1, int32_t a2);
int32_t get_ui_coordinates(int32_t a1, int32_t a2);
int32_t is_kung_pow_enabled(int32_t a1);
int32_t is_recovery_mode(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbm_fdt_find_node(int32_t a1, int32_t a2);
char * mbm_fdt_init(void);
int32_t mcs_cert_get_rsa_public_key(char * a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t mcs_clear_cert_ctx(char * a1, int32_t a2, int32_t a3);
int32_t mcs_habp_rsa_med_window(int32_t a1);
int32_t mcs_habp_rsa_small_window(int32_t a1);
int32_t mot_sst_pal_get_flash_uid_length(int32_t * a1, int32_t a2, int32_t a3);
int32_t mot_sst_pal_get_processor_uid(int32_t a1, int32_t a2);
int32_t mp_compare(int32_t a1, int32_t a2, int32_t a3);
int32_t mp_copy(int32_t a1, int32_t a2, int32_t a3);
char * platform_early_init(char * result);
int32_t recovery_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t set_show_battery_fn(char * a1, int32_t a2, int32_t a3);
int32_t target_display_init(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g26 = 0; // LR
int32_t g27 = 0; // R0
int32_t g28 = 0; // R1
int32_t g29 = 0; // R2
int32_t g30 = 0; // R3
int32_t g31 = 0; // R4
int32_t g32 = 0; // R5
int32_t g33 = 0; // R6
int32_t g34 = 0; // R7
int32_t g1 = -0x16d2bfed; // 0x8f626204
int32_t g2 = -0x16d2be0d; // 0x8f627388
int32_t g3 = -0x1a60cf3c; // 0x8f627420
int32_t g4 = -0x1a60df7c; // 0x8f627e38
int32_t g5 = 0x5b5e0029; // 0x8f687c45
char * g6 = "\xd0\x0d\xfe\xed"; // 0x8f68ac00
char * g7 = "\n"; // 0x8f6ac1b0
int32_t g8 = -1; // 0x8f6ac1e8
int32_t g9 = -1; // 0x8f6ac1f4
int32_t g10 = -1; // 0x8f6ac1f8
int32_t g11 = -1; // 0x8f6ac1fc
int32_t g12 = -1; // 0x8f6ac200
int32_t g13 = -1; // 0x8f6ac204
int32_t g14 = -1; // 0x8f6ac208
int32_t g15 = -1; // 0x8f6ac20c
int32_t g16 = -1; // 0x8f6ac214
int32_t g17 = -1; // 0x8f6acaac
char * g18; // 0x8f6e06a0
char * g19; // 0x8f6e06a6
char * g20; // 0x8f6e06ab
char * g21; // 0x8f6e0848
int32_t g22 = 0; // 0x8f6e0850
int32_t g23 = 0; // 0x8f6e0aa0
int32_t g24 = 0; // 0x8f6e0aa4
int32_t g25 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f630c98 - 0x8f63103b
char * mbm_fdt_init(void) {
    int32_t str2;
    int32_t v1 = &str2; // 0x8f630ca4_0
    int32_t str;
    int32_t v2 = &str; // 0x8f630cb0_0
    int32_t str3;
    int32_t v3 = &str3; // 0x8f630cb4_0
    int32_t v4 = g25;
    int32_t v5 = v4; // R3
    memset((char *)&str, 0, 16);
    memset((char *)&str2, 0, 32);
    memset((char *)&str3, 0, 16);
    int32_t v6 = 0; // R1
    int32_t v7 = 32; // R2
    int32_t str4;
    int32_t v8 = &str4; // 0x8f630cec_0
    char * set_mem = memset((char *)&str4, 0, 32); // 0x8f630cf0
    int32_t v9 = target_platform_id(set_mem, v6, v7, v5); // 0x8f630cf4
    int32_t v10 = v9; // R7
    int32_t v11;
    int32_t v12;
    int32_t v13;
    int32_t v14 = target_mot_hw_id((char *)v9, v6, v7, v5, v13, v12, v11); // 0x8f630cfc
    int32_t v15 = target_mot_prod_id((char *)v14, v6, v7, v5); // R10
    int32_t v16;
    int32_t v17 = fdt_check_header((int32_t)&g6, v6, v7, v5, v13, v12, v11, v16, 0, str, 0, 0, 0, str3, 0); // 0x8f630d10
    if (v17 != 0) {
        // if_8f630d18_0_true
        // branch -> 0x8f630e80
        // 0x8f630e80
        print_log(-1, (int32_t)"Not found invalid mbm fdt\n", v7, v5, v13, v12, v11, v16, 0, str, 0, 0, 0);
        // branch -> 0x8f630d78
        // 0x8f630d78
        // branch -> 0x8f630fa8
        // 0x8f630fa8
        if (v4 != g25) {
            // 0x8f630fbc
            __stack_chk_fail();
            // branch -> 0x8f630fc0
        }
        // 0x8f630fc0
        return (char *)-1;
    }
    // 0x8f630d24
    snprintf((char *)&str, 16, "/platform@%d", v10);
    print_log(2, (int32_t)"Try to get fdt platform offset: %s\n", v2, v10, v13, v12, v11, v16, 0, str, 0, 0, 0);
    int32_t v18 = fdt_path_offset((char *)&g6, v2, v2, v10, v13, v12, v11, v16, 0, str, 0, 0, 0); // 0x8f630d50
    v5 = &g12;
    g12 = v18;
    if (v18 <= -1) {
        int32_t v19 = &g12; // 0x8f630d74
        // branch -> 0x8f630d74
        // 0x8f630d74
        print_log(-1, (int32_t)"No setting for platform%d\n", v10, v19, v13, v12, v11, v16, 0, str, 0, 0, 0);
        // branch -> 0x8f630d78
        // 0x8f630d78
        // branch -> 0x8f630fa8
        // 0x8f630fa8
        if (v4 != g25) {
            // 0x8f630fbc
            __stack_chk_fail();
            // branch -> 0x8f630fc0
        }
        // 0x8f630fc0
        return (char *)-1;
    }
    int32_t v20 = get_string_prop((int32_t)"platform_name", v18, v2, (int32_t)&g12, v13, v12, v11, v16); // 0x8f630d84
    *(int32_t *)&g18 = v20;
    if (v20 == 0) {
        // if_8f630d98_0_true
        // branch -> 0x8f630e80
        // 0x8f630e80
        print_log(-1, (int32_t)"Not platform name defined\n", v20, v5, v13, v12, v11, v16, 0, str, 0, 0, 0);
        // branch -> 0x8f630d78
        // 0x8f630d78
        // branch -> 0x8f630fa8
        // 0x8f630fa8
        if (v4 != g25) {
            // 0x8f630fbc
            __stack_chk_fail();
            // branch -> 0x8f630fc0
        }
        // 0x8f630fc0
        return (char *)-1;
    }
    // 0x8f630da4
    print_log(2, (int32_t)"get platform name: %s\n", v20, v5, v13, v12, v11, v16, 0, str, 0, 0, 0);
    int32_t v21 = v15 - 64; // 0x8f630db0
    snprintf((char *)&str2, 32, "/%s,product@%d", g18, v21);
    int32_t v22 = v14 - 64; // 0x8f630dd0
    v5 = v22;
    snprintf((char *)&str3, 16, "hw@%d", v22);
    int32_t v23 = fdt_path_offset((char *)&g6, v1, (int32_t)"hw@%d", v5, v21, v12, v11, v16, 0, str, 0, 0, 0); // 0x8f630dec
    *(int32_t *)(int32_t)&g16 = v23;
    int32_t v24; // 0x8f630fac
    if (v23 < 0) {
        // if_8f630dfc_0_true
        // branch -> 0x8f630d74
        // 0x8f630d74
        print_log(-1, (int32_t)"No setting for %s\n", v1, v5, v21, v12, v11, v16, 0, str, 0, 0, 0);
        // branch -> 0x8f630d78
        // 0x8f630d78
        v24 = -1;
        // branch -> 0x8f630fa8
    } else {
        int32_t v25 = &g9; // R11
        print_log(2, (int32_t)"get product name: %s\n", v1, v5, v21, v12, v11, v16, 0, str, 0, 0, 0);
        uint32_t v26 = fdt_subnode_offset((char *)&g6, g16, v3, v5, v21, v12, v11, v16, 0); // 0x8f630e2c
        *(int32_t *)v25 = v26;
        if (v26 <= 0xffffffff) {
            // 0x8f630e3c
            print_log(-1, (int32_t)"No setting for %s, using default setting\n", v3, v5, v21, v12, v11, v16, 0, str, 0, 0, 0);
            snprintf((char *)&str3, 16, "hw@default");
            uint32_t v27 = fdt_subnode_offset((char *)&g6, g16, v3, v5, v21, v12, v11, v16, 0); // 0x8f630e68
            *(int32_t *)v25 = v27;
            if (v27 <= 0xffffffff) {
                // 0x8f630e78
                // branch -> 0x8f630e80
                // 0x8f630e80
                print_log(-1, (int32_t)"No default setting for HW_REV\n", v3, v5, v21, v12, v11, v16, 0, str, 0, 0, 0);
                // branch -> 0x8f630d78
                // 0x8f630d78
                // branch -> 0x8f630fa8
                // 0x8f630fa8
                if (v4 != g25) {
                    // 0x8f630fbc
                    __stack_chk_fail();
                    // branch -> 0x8f630fc0
                }
                // 0x8f630fc0
                return (char *)-1;
            }
        }
        int32_t v28 = g16;
        int32_t v29 = g9;
        int32_t v30 = g12;
        print_log(2, (int32_t)"get node for platform@%d(0x%x), %s(0x%x), %s(0x%x)\n", v10, v30, v1, v28, v3, v29, 0, str, 0, 0, 0);
        strlcat(v8, (int32_t)"/devices@0", 32, v30, v1, v28, v3, v29, 0, str, 0, 0);
        int32_t v31 = fdt_path_offset((char *)&g6, v8, 32, v30, v1, v28, v3, v29, 0, str, 0, 0, 0); // 0x8f630ed4
        *(int32_t *)(int32_t)&g10 = v31;
        memset((char *)&str4, 0, 32);
        snprintf((char *)&str4, 32, "devices@%d", v10);
        int32_t v32 = fdt_subnode_offset((char *)&g6, g12, v8, v10, v1, v28, v3, v29, 0); // 0x8f630f10
        *(int32_t *)(int32_t)&g15 = v32;
        memset((char *)&str4, 0, 32);
        strlcat(v8, (int32_t)"devices", 32, v10, v1, v28, v3, v29, 0, str, 0, 0);
        int32_t v33 = fdt_subnode_offset((char *)&g6, g16, v8, v10, v1, v28, v3, v29, 0); // 0x8f630f48
        *(int32_t *)(int32_t)&g8 = v33;
        memset((char *)&str4, 0, 32);
        strlcat(v8, (int32_t)"devices", 32, v10, v1, v28, v3, v29, 0, str, 0, 0);
        int32_t v34 = fdt_subnode_offset((char *)&g6, g9, v8, v10, v1, v28, v3, v29, 0); // 0x8f630f7c
        g13 = v34;
        print_log(2, (int32_t)"get devices nodes offset: [%d, %d, %d, %d]\n", g10, g15, g8, v34, v3, v29, 0, str, 0, 0, 0);
        v24 = v17;
        // branch -> 0x8f630fa8
    }
    // 0x8f630fa8
    if (v4 != g25) {
        // 0x8f630fbc
        __stack_chk_fail();
        // branch -> 0x8f630fc0
    }
    // 0x8f630fc0
    return (char *)v24;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// char * strstr(char * haystack, const char * needle);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:08:11
