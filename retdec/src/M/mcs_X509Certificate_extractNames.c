//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t cache_state_to_sp(void);
int32_t get_boot_component_version(int32_t a1);
int32_t get_policy_executor(char * a1);
int32_t get_primary_gpt_partition(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_add_verified_blocks(char * a1, int32_t a2, int32_t a3);
int32_t hab_code_hash(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t hab_code_sig_verification(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t hab_parse_certificate(int32_t a1, char * a2, int32_t * a3, int16_t * a4, int32_t * a5);
int32_t hab_rsa_verification(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t hab_skip_identifier(int32_t a1);
int32_t hab_sw_rsa(char * str, char * str2, uint32_t n, int32_t a4, uint32_t a5);
int32_t locking_phone(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_X509Certificate_decodeExtension(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_X509Certificate_extractAlgorithm(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t mcs_X509Certificate_extractNames(int32_t a1, int32_t a2, int32_t * a3, int16_t * a4);
int32_t mcs_X509Certificate_getExtensions(int32_t a1, int32_t * a2, int16_t * a3);
int32_t mcs_X509Certificate_removePadding(int32_t a1, int32_t a2);
int32_t set_current_secure_state(char a1, int32_t a2, int32_t a3);
int32_t unlock_phone(int32_t a1, int32_t a2, int32_t a3);
int32_t validate_sparse_partition(int32_t a1, int32_t a2);
int32_t write_protect_on_partition(int32_t a1, int32_t a2);
int32_t write_protect_was_enabled(char * a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g54 = 0; // LR
int32_t g55 = 0; // R0
int32_t g56 = 0; // R1
int32_t g57 = 0; // R10
int32_t g58 = 0; // R11
int32_t g59 = 0; // R2
int32_t g60 = 0; // R3
int32_t g61 = 0; // R4
int32_t g62 = 0; // R5
int32_t g63 = 0; // R6
int32_t g64 = 0; // R7
int32_t g65 = 0; // R8
int32_t g66 = 0; // R9
int32_t g1 = 1; // 0x8f6b0044
int32_t g2 = 0; // 0x8f6b0070
char g3 = 0; // 0x8f70dad8
int32_t g4 = 0; // 0x8f70dcf4
int32_t g5 = 0; // 0x8f70ddf8
int32_t g6 = 0; // 0x8f70ddfc
int32_t g7 = 0; // 0x8f70dff4
int32_t g8 = 0; // 0x8f70dff8
char * g9; // 0x8f70dffc
int32_t g10 = 0; // 0x8f70e3fc
char g11 = 0; // 0x8f70e500
char g12 = 0; // 0x8f70e604
char * g13; // 0x8f70e708
char g14 = 0; // 0x8f70e709
char g15 = 0; // 0x8f70e70a
char g16 = 0; // 0x8f70e70b
char g17 = 0; // 0x8f70e70c
char g18 = 0; // 0x8f70e70d
int32_t g19 = 0; // 0x8f70e718
int32_t g20 = 0; // 0x8f70e719
int32_t g21 = 0; // 0x8f70e71a
int32_t g22 = 0; // 0x8f70e71b
char g23 = 0; // 0x8f70e71c
char g24 = 0; // 0x8f70e71d
char g25 = 0; // 0x8f70e71e
char g26 = 0; // 0x8f70e71f
char * g27; // 0x8f70f724
int32_t g28 = 0; // 0x8f70f725
int32_t g29 = 0; // 0x8f70f745
int32_t g30 = 0; // 0x8f70f746
int32_t g31 = 0; // 0x8f70f747
int32_t g32 = 0; // 0x8f70f748
int32_t g33 = 0; // 0x8f70f749
int32_t g34 = 0; // 0x8f70f74a
int32_t g35 = 0; // 0x8f70f74b
int32_t g36 = 0; // 0x8f70f74c
int32_t g37 = 0; // 0x8f70f74d
int32_t g38 = 0; // 0x8f70f74e
int32_t g39 = 0; // 0x8f70f74f
int32_t g40 = 0; // 0x8f70f750
int32_t g41 = 0; // 0x8f70f751
int32_t g42 = 0; // 0x8f70f752
int32_t g43 = 0; // 0x8f70f753
int32_t g44 = 0; // 0x8f70f754
char g45 = 0; // 0x8f70f755
char g46 = 0; // 0x8f70f756
char * g47; // 0x8f70f75d
char * g48; // 0x8f710a25
int32_t g49 = 0; // 0x8f7112f4
int32_t g50 = 0; // 0x8f7129dc
int32_t g51 = 0; // 0x8f712e1c
int32_t g52 = 0; // 0x8f712f2c
int32_t g53 = 0; // 0x8f71302c

// ------------------------ Functions -------------------------

// Address range: 0x8f66af0c - 0x8f66b183
int32_t mcs_X509Certificate_extractNames(int32_t a1, int32_t a2, int32_t * a3, int16_t * a4) {
    int32_t v1 = (int32_t)a4;
    int32_t v2;
    int32_t v3 = &v2; // 0x8f66af18_0
    int32_t v4 = (int32_t)a3; // R4
    int32_t v5 = g49;
    int32_t v6;
    int32_t v7 = &v6; // 0x8f66af44_0
    int32_t v8 = v3; // 0x8f66af3c
    int32_t v9 = 0;
    // branch -> 0x8f66af38
    while (true) {
        int32_t v10 = v9; // R5
        uint32_t v11 = v9 + 1; // 0x8f66af38
        v6 = 0x10000 * a2 / 0x10000;
        int32_t v12 = v11 % 256; // R10
        v2 = 0x1000000 * v11 / 0x1000000;
        int32_t v13;
        int32_t v14;
        int32_t v15 = mcs_DER_locate(a1, v7, 6, 2, v8, 0, v14, v1, 0, v5, 0, g61, g62, g63, g64, g65, g66, g57, g58, g54, v13, 0); // 0x8f66af5c
        int32_t result = v15; // R0
        if (v15 != 0) {
            // 0x8f66af6c
            if (v10 != 0) {
                int32_t size = 24 * v10; // 0x8f66af78
                if (size == 0) {
                    // 0x8f66af84
                    *(int32_t *)v4 = 0;
                    // branch -> 0x8f66b104
                } else {
                    char * mem = malloc(size); // 0x8f66af80
                    *(int32_t *)v4 = (int32_t)mem;
                    if (mem != NULL) {
                        int32_t v16 = 0; // R3
                        v12 = 1;
                        if (v10 == 0) {
                            char v17 = 6;
                            int32_t v18 = 0; // 0x8f66afbc
                            while (true) {
                                int32_t v19 = 24 * v18; // 0x8f66afb4
                                int32_t v20 = v19; // R1
                                *(char *)(*(int32_t *)v4 + v19) = v17;
                                int32_t v21 = v20 + *(int32_t *)v4; // 0x8f66afc8
                                *(int32_t *)(v21 + 4) = v16;
                                *(int16_t *)(v21 + 2) = (int16_t)v16;
                                int32_t v22 = v20 + *(int32_t *)v4; // 0x8f66afd8
                                *(char *)(v22 + 12) = (char)v16;
                                *(int16_t *)(v22 + 8) = (int16_t)v12;
                                int32_t v23 = v20 + *(int32_t *)v4; // 0x8f66afe8
                                *(int16_t *)(v23 + 14) = (int16_t)v16;
                                *(int32_t *)(v23 + 16) = v16;
                                int32_t v24 = *(int32_t *)v4; // 0x8f66aff4
                                *(int16_t *)(v24 + 20 + v20) = (int16_t)5;
                                int32_t v25 = v18 + 1; // 0x8f66afa8
                                if (v25 % 0x10000 >= v10) {
                                    // 0x8f66afb4
                                    v17 = 6;
                                    v18 = v25;
                                    // branch -> 0x8f66afb4
                                    continue;
                                }
                            }
                        }
                        int32_t v26 = *(int32_t *)v4; // 0x8f66b114
                        int32_t v27 = mcs_X509Certificate_decodeName(a1, a2, v26, v10, v8, 0, v14, v1, 0, v5, 0, g61, g62, g63, g64, g65, g66, g57, g58, g54, v13, 0); // 0x8f66b11c
                        result = v27;
                        if (v27 == 0) {
                            int32_t v28 = 0; // R7
                            int32_t v29 = 0; // 0x8f66b134
                            // branch -> 0x8f66b044
                            while (true) {
                                uint32_t v30 = v29 % 0x10000; // 0x8f66b044
                                v12 = v30;
                                if (v30 < v10) {
                                    int32_t v31 = 24 * v29; // 0x8f66b134
                                    int32_t v32 = v31; // R8
                                    int32_t v33 = *(int32_t *)v4 + v31; // 0x8f66b13c
                                    uint16_t v34 = *(int16_t *)(v33 + 2); // 0x8f66b140
                                    int32_t size2 = v34; // 0x8f66b140
                                    int32_t mem2 = size2; // 0x8f66b158
                                    int32_t v35 = v14; // 0x8f66b1544
                                    if (v34 != 0) {
                                        // 0x8f66b14c
                                        mem2 = (int32_t)malloc(size2);
                                        v35 = v33;
                                        // branch -> 0x8f66b158
                                    }
                                    // 0x8f66b158
                                    *(int32_t *)(v33 + 4) = mem2;
                                    int32_t v36 = v32 + *(int32_t *)v4; // 0x8f66b160
                                    int32_t v37 = 2; // 0x8f66b038
                                    if (*(int32_t *)(v36 + 4) != 0) {
                                        uint16_t v38 = *(int16_t *)(v36 + 14); // 0x8f66b004
                                        int32_t size3 = v38; // 0x8f66b004
                                        int32_t mem3 = size3; // 0x8f66b01c
                                        if (v38 != 0) {
                                            // 0x8f66b010
                                            mem3 = (int32_t)malloc(size3);
                                            v35 = v36;
                                            // branch -> 0x8f66b01c
                                        }
                                        // 0x8f66b01c
                                        *(int32_t *)(v36 + 16) = mem3;
                                        v37 = 0;
                                        // branch -> 0x8f66b024
                                    }
                                    // 0x8f66b024
                                    if (*(int32_t *)(*(int32_t *)v4 + v32 + 16) != 0) {
                                        int32_t v39 = v28 + 1; // 0x8f66b03c
                                        v28 = v39;
                                        if (v37 != 0) {
                                            // break -> 0x8f66b084
                                            break;
                                        }
                                        v29 = v39;
                                        v14 = v35;
                                        // continue -> 0x8f66b044
                                        continue;
                                    }
                                } else {
                                    int32_t v40 = *(int32_t *)v4; // 0x8f66b058
                                    result = mcs_X509Certificate_decodeName(a1, a2, v40, v10, v8, 0, v14, v1, 0, v5, 0, g61, g62, g63, g64, g65, g66, g57, g58, g54, v13, 0);
                                    // branch -> 0x8f66b064
                                  lab_0x8f66b064:
                                    // 0x8f66b064
                                    *a4 = (int16_t)v10;
                                    if (v5 == g49) {
                                        // 0x8f66b178
                                        return result;
                                    }
                                  lab_0x8f66b080_2:
                                    // 0x8f66b080
                                    __stack_chk_fail();
                                    // branch -> 0x8f66b084
                                }
                                // 0x8f66b084
                                a1 = 0;
                                a2 = 0;
                                int32_t v41 = 0; // 0x8f66b090
                                // branch -> 0x8f66b090
                                while (true) {
                                  lab_0x8f66b090:;
                                    int32_t v42 = 24 * v41; // 0x8f66b090
                                    v28 = v42;
                                    int32_t v43 = *(int32_t *)(*(int32_t *)v4 + v42 + 4); // 0x8f66b09c
                                    if (v43 != 0) {
                                        // 0x8f66b0a8
                                        free((char *)v43);
                                        v42 = v28;
                                        // branch -> 0x8f66b0ac
                                    }
                                    int32_t v44 = *(int32_t *)(*(int32_t *)v4 + v42 + 16); // 0x8f66b0b4
                                    if (v44 != 0) {
                                        // 0x8f66b0c0
                                        free((char *)v44);
                                        v42 = v28;
                                        // branch -> 0x8f66b0c4
                                    }
                                    uint32_t v45 = (a1 + 1) % 0x10000; // 0x8f66b0d0
                                    a1 = v45;
                                    *(int32_t *)(*(int32_t *)v4 + v42 + 4) = a2;
                                    *(int32_t *)(v28 + *(int32_t *)v4 + 16) = a2;
                                    if (v45 > v12) {
                                        int32_t v46 = *(int32_t *)v4; // 0x8f66b0ec
                                        if (v46 != 0) {
                                            // 0x8f66b0f8
                                            free((char *)v46);
                                            // branch -> 0x8f66b0fc
                                        }
                                        // 0x8f66b0fc
                                        *(int32_t *)v4 = 0;
                                        // branch -> 0x8f66b104
                                        // 0x8f66b104
                                        result = 2;
                                        // branch -> 0x8f66b064
                                        goto lab_0x8f66b064;
                                    } else {
                                        // 0x8f66b0c4
                                        v41 = a1;
                                        // branch -> 0x8f66b090
                                        continue;
                                    }
                                }
                            }
                        }
                      lab_0x8f66b064_2:
                        // 0x8f66b064
                        *a4 = (int16_t)v10;
                        if (v5 != g49) {
                            goto lab_0x8f66b080_2;
                        }
                        // 0x8f66b178
                        return result;
                    }
                }
                // 0x8f66b104
                result = 2;
                // branch -> 0x8f66b064
                goto lab_0x8f66b064_2;
            }
            // 0x8f66b064
            *a4 = (int16_t)v10;
            if (v5 != g49) {
                goto lab_0x8f66b080_2;
            }
            // 0x8f66b178
            return result;
        }
        // if_8f66af64_0_true
        v8 = v3;
        v9 = v12;
        // branch -> 0x8f66af38
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 22
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:53:28
