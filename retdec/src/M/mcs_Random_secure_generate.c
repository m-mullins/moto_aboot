//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t check_cid_provisioned(void);
int32_t dbval_validate_cert_chain(char * a1);
int32_t erase_partition(int32_t a1);
int32_t flash_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t get_delay_abs_time(int32_t a1, int32_t a2, int32_t a3);
int32_t get_panel_offset_by_index(int32_t a1, int32_t a2);
int32_t hab_command_parser(int32_t * a1, int32_t * a2, int32_t a3);
int32_t hab_rehash(int32_t result, int32_t a2, char * a3);
int32_t is_menu_auto_scroll(int32_t a1);
int32_t led_blink_stop(int32_t a1, int32_t a2, int32_t a3);
int32_t led_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_ctx_init_rng(int32_t a1, int32_t a2, int32_t a3, char * a4);
int32_t mcs_Random_secure_generate(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_X509Certificate_getExtensions(int32_t a1, int32_t * a2, int16_t * a3);
int32_t mcs_X509Certificate_getSignatureAlgorithm(int32_t a1, int32_t * a2);
int32_t mipi_cmd_trigger(int32_t a1, int32_t a2);
int32_t mipi_dsi_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_pal_debug_print(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_pal_get_security_version_length(int32_t * a1, int32_t a2, int32_t a3);
int32_t platform_irq(int32_t a1, int32_t a2);
int32_t pm8x41_clear_pmic_watchdog(void);
int32_t pm8x41_ldo_control(int32_t a1, int32_t a2);
int32_t SecGetSVNum(uint32_t a1, int32_t a2);
int32_t SecSetSVNum(uint32_t a1, uint32_t a2, int32_t a3);
int32_t target_cont_splash_screen(int32_t a1, int32_t a2, int32_t a3);
int32_t target_dev_tree_mem(int32_t a1, int32_t a2);
int32_t target_is_ssd_enabled(void);
int32_t target_mmc_device(void);
int32_t target_power_up_reason_correction(char * a1, int32_t a2);
int32_t target_sdc_init(void);

// --------------------- Global Variables ---------------------

int32_t g32 = 0; // LR
int32_t g33 = 0; // R1
int32_t g34 = 0; // R10
int32_t g35 = 0; // R11
int32_t g36 = 0; // R2
int32_t g37 = 0; // R3
int32_t g38 = 0; // R4
int32_t g39 = 0; // R5
int32_t g40 = 0; // R6
int32_t g41 = 0; // R7
int32_t g42 = 0; // R8
int32_t g43 = 0; // R9
int32_t g1 = 6; // 0x8f67c000
int32_t g2 = 1799; // 0x8f67c004
int32_t g3 = 0x110a000; // 0x8f67c008
int32_t g4 = 3; // 0x8f67c00c
int32_t g5 = 1796; // 0x8f67c010
int32_t g6 = 0x110a000; // 0x8f67c014
int32_t g7 = 0; // 0x8f67c018
int32_t g8 = 1796; // 0x8f67c01c
int32_t g9 = 0x110a000; // 0x8f67c020
int32_t g10 = 13; // 0x8f67c024
int32_t g11 = 768; // 0x8f67c028
int32_t g12 = 0x110a000; // 0x8f67c02c
int32_t g13 = 11; // 0x8f67c030
int32_t g14 = 771; // 0x8f67c034
int32_t g15 = 0x110a000; // 0x8f67c038
int32_t g16 = 9; // 0x8f67c03c
int32_t g17 = 771; // 0x8f67c040
int32_t g18 = 0x110a000; // 0x8f67c044
char * g19 = "\xd0\x0d\xfe\xed"; // 0x8f68ac00
int32_t g20 = 0x65440030; // 0x8f69c66f
int32_t g21 = -0x21fc7dd0; // 0x8f6a56d3
int32_t g22 = 0xf0e0d; // 0x8f6a6b06
int32_t g23 = 1; // 0x8f6ac0dc
int32_t g24 = -1; // 0x8f6ac210
char * g25; // 0x8f6e0c48
int32_t g26 = 0; // 0x8f6e0c49
int32_t g27 = 0; // 0x8f6e0c4c
char * g28; // 0x8f70da9b
int32_t g29 = 0; // 0x8f7112dc
int32_t g30 = 0; // 0x8f7112f4
int32_t g31 = 0; // 0x8f7129d8

// ------------------------ Functions -------------------------

// Address range: 0x8f6679d4 - 0x8f667b27
// Used cryptographic patterns:
//  - Lucifer__outerbridge__DFLTKY (8-bit, little endian)
int32_t mcs_Random_secure_generate(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g38; // 0x8f6679d4
    int32_t v2 = g39; // 0x8f6679d4
    int32_t v3 = g40; // 0x8f6679d4
    int32_t v4 = g41; // 0x8f6679d4
    int32_t v5 = g42; // 0x8f6679d4
    int32_t v6 = g43; // 0x8f6679d4
    int32_t v7 = g34; // 0x8f6679d4
    int32_t v8 = g35; // 0x8f6679d4
    int32_t v9 = g37; // 0x8f6679d8
    g39 = a3;
    uint32_t v10 = v9 + 19; // 0x8f6679f0
    int32_t v11 = g30;
    int32_t v12;
    int32_t v13 = &v12; // 0x8f6679f8_0
    int32_t v14 = 0; // R10
    int32_t result2 = v10 / 20;
    int32_t v15 = v11;
    if (v10 >= 20) {
        // 0x8f667a1c
        int32_t v16;
        int32_t v17 = &v16; // 0x8f667a64_0
        // branch -> 0x8f667a1c
      lab_0x8f667a1c:
        while (true) {
            // 0x8f667a1c
            g38 = 20;
            int32_t v18 = 0; // 0x8f667a2c
            int32_t v19 = 20; // 0x8f667a24
            // branch -> 0x8f667a24
            while (true) {
                int32_t v20 = v19 - 1; // 0x8f667a24
                g38 = v20;
                int32_t v21;
                char v22 = *(char *)(v20 + v21); // 0x8f667a34
                char v23 = *(char *)(v20 + a1); // 0x8f667a3c
                uint32_t v24 = (int32_t)v23 + (int32_t)v22 + (v18 & -256);
                int32_t v25 = v24 % 0x10000; // R2
                *(char *)(v13 + v20) = (char)v24;
                int32_t v26 = g38; // 0x8f667a50
                if (v20 == 0) {
                    // 0x8f667a50
                    int32_t v27;
                    mcs_memset((int32_t)&v27, v26, 44, a1);
                    int32_t v28;
                    mcs_hashSHA(v13, (int32_t)"\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10", v17, a1, v28, a1, v16, 0, 0, 0, 0, v12, 0, 0, 0, 0, v27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, v11, 0, v1, v2, v3, v4, v5, v6, v7, v8, g32, v21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    int32_t v29 = g38; // 0x8f667a80
                    int32_t v30;
                    int32_t v31 = &v30; // 0x8f667a7c
                    // branch -> 0x8f667a78
                    while (true) {
                        int32_t v32 = v31 + 4; // R1
                        uint32_t v33 = *(int32_t *)(v29 + v17); // 0x8f667a80
                        int32_t result = v33; // R0
                        int32_t v34 = v29 + 4; // 0x8f667a84
                        v25 = v34;
                        *(char *)(v31 + 2) = (char)v33;
                        *(char *)(v32 - 5) = (char)(v33 / 0x1000000);
                        *(char *)(v32 - 4) = (char)(result / 0x10000);
                        int32_t v35 = result / 256; // 0x8f667aa0
                        g32 = v35;
                        *(char *)(v32 - 3) = (char)v35;
                        if (v34 == 20) {
                            int32_t v36 = result2 - 1; // 0x8f667aac
                            int32_t v37; // 0x8f667ac0
                            if (v14 == v36) {
                                // if_8f667abc_0_true
                                v37 = v9 - v25 * v36;
                                // branch -> after_if_8f667abc_0
                            } else {
                                // 0x8f667aac
                                v37 = v25;
                                // branch -> after_if_8f667abc_0
                            }
                            // after_if_8f667abc_0
                            mcs_memmove(g39, v13, v37, v17, v28);
                            int32_t v38 = 256; // 0x8f667ad0
                            int32_t v39 = 20; // 0x8f667acc
                            // branch -> 0x8f667acc
                            while (true) {
                                int32_t v40 = v39 - 1; // 0x8f667acc
                                v25 = v40;
                                char v41 = *(char *)(v40 + v13); // 0x8f667ad8
                                char * v42 = (char *)(v21 + v40); // 0x8f667ae0_0
                                int32_t v43 = (int32_t)*v42; // 0x8f667ae0
                                result = v43;
                                uint32_t v44 = v43 + (int32_t)v41 + (v38 & -256);
                                v32 = v44 % 0x10000;
                                *v42 = (char)v44;
                                if (v40 == 0) {
                                    int32_t v45 = v14 + 1; // 0x8f667af4
                                    v14 = v45;
                                    g39 += 20;
                                    if (v45 == result2) {
                                        // break (via goto) -> 0x8f667a14
                                        goto lab_0x8f667a14;
                                    }
                                    // continue (via goto) -> 0x8f667a1c
                                    goto lab_0x8f667a1c;
                                } else {
                                    // 0x8f667acc
                                    v38 = v32;
                                    v39 = v25;
                                    // branch -> 0x8f667acc
                                    continue;
                                }
                            }
                          lab_0x8f667a14:
                            // 0x8f667a14
                            v15 = g30;
                            // branch -> 0x8f667b00
                            // 0x8f667b00
                            g33 = &g30;
                            g36 = v11;
                            g37 = v15;
                            if (v11 != v15) {
                                // 0x8f667b14
                                __stack_chk_fail();
                                // branch -> 0x8f667b18
                            }
                            // 0x8f667b18
                            g38 = v1;
                            g39 = v2;
                            g40 = v3;
                            g41 = v4;
                            g42 = v5;
                            g43 = v6;
                            g34 = v7;
                            g35 = v8;
                            return result;
                        }
                        // 0x8f667a78
                        v29 = v25;
                        v31 = v32;
                        // branch -> 0x8f667a78
                    }
                } else {
                    // 0x8f667a24
                    v18 = v25;
                    v19 = v26;
                    // branch -> 0x8f667a24
                    continue;
                }
            }
        }
    }
    // 0x8f667b00
    g33 = &g30;
    g36 = v11;
    g37 = v15;
    if (v11 != v15) {
        // 0x8f667b14
        __stack_chk_fail();
        // branch -> 0x8f667b18
    }
    // 0x8f667b18
    g38 = v1;
    g39 = v2;
    g40 = v3;
    g41 = v4;
    g42 = v5;
    g43 = v6;
    g34 = v7;
    g35 = v8;
    return result2;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:33:35
