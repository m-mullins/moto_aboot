//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t check_reboot_mode(char * a1, int32_t a2, int32_t a3);
int32_t delay(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
void function_8f60e190(int32_t a1);
int32_t mdp_select_pipe_type_isra_0(int32_t a1, int32_t * a2);
int32_t mdss_mdp_set_flush_isra_1(int32_t a1, int32_t * a2);
int32_t mdss_smp_alloc(int32_t a1, int32_t a2, int32_t a3, int32_t result2);
int32_t mdss_source_pipe_config(int32_t * a1, int32_t * a2, int32_t * a3);
int32_t mmc_erase_card(void);
int32_t mmc_get_ext_csd_isra_11(char * a1, int32_t * a2);
int32_t mmc_parse_response(char * a1, int32_t a2);
int32_t mmc_set_ddr_mode(int32_t a1, int32_t * a2, int32_t a3);
int32_t mmc_set_drv_type(char * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t mmc_set_hs200_mode(char * a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t mmc_set_hs_interface(char * a1);
int32_t mmc_stop_command(char * a1);
int32_t mmc_zero_out(int32_t a1, int32_t a2, int32_t a3);
int32_t msm_boot_uart_dm_write(int32_t a1, int32_t a2, int32_t a3);
int32_t platform_set_periodic_timer(int32_t a1, int32_t a2, int32_t a3);
int32_t qtimer_get_frequency(void);
int32_t qtimer_irq(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t set_restart_reason(int32_t a1);
int32_t uart_dm_init(int32_t a1, int32_t * a2, int32_t * a3);

// --------------------- Global Variables ---------------------

int32_t g15 = 0; // LR
int32_t g16 = 0; // R0
int32_t g17 = 0; // R1
int32_t g18 = 0; // R2
int32_t g19 = 0; // R3
int32_t g20 = 0; // R4
int32_t g21 = 0; // R5
int32_t g22 = 0; // R6
int32_t g23 = 0; // R7
int32_t g24 = 0; // R8
int32_t g25 = 0; // R9
bool g1 = false; // flagz
int32_t g2 = 1; // 0x8f6ac0f0
int32_t g3 = 0; // 0x8f6b8abc
int32_t g4 = 0; // 0x8f6b8ac0
int32_t g5 = 0; // 0x8f6b8ac4
int32_t (*g6)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t) = NULL; // 0x8f6b8ac8
int32_t g7 = 0; // 0x8f6b8acc
int32_t g8 = 0; // 0x8f6b8ad8
int32_t g9 = 0; // 0x8f6b8adc
char * g10; // 0x8f6b8aec
char g11 = 0; // 0x8f6b8aed
int32_t g12 = 0; // 0x8f6b8af0
char * g13; // 0x8f6b8af4
int32_t g14 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f60bbd4 - 0x8f60bee3
int32_t mmc_erase_card(void) {
    int32_t v1 = 0; // R10
    int32_t v2 = g20; // 0x8f60bbd4
    int32_t v3 = g21; // 0x8f60bbd4
    int32_t v4 = g22; // 0x8f60bbd4
    int32_t v5 = g23; // 0x8f60bbd4
    int32_t v6 = g24; // 0x8f60bbd4
    int32_t v7 = g25; // 0x8f60bbd4
    int32_t v8 = 0; // 0x8f60bbd4
    int32_t v9 = g15; // 0x8f60bbd4
    int32_t v10 = g14;
    int32_t v11 = mmc_get_device_blocksize(g16); // 0x8f60bbf4
    int32_t v12 = target_mmc_device(v11); // 0x8f60bbfc
    int64_t v13 = v11;
    g21 = 0;
    g20 = v11;
    g25 = v12;
    int64_t v14 = g16;
    __aeabi_uldivmod(v14, v13);
    int32_t v15;
    char * v16 = (char *)v15;
    int32_t v17;
    if (v11 != 0) {
        // 0x8f60bc24
        _panic(v9, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/mmc_wrapper.c", (int32_t)"!(addr % block_size)" & -0x10000 | 334, (int32_t)"!(addr % block_size)", v17, g16);
        v16 = "!(addr % block_size)";
        // branch -> 0x8f60bc40
    }
    int64_t v18 = g18;
    int32_t v19 = g20; // 0x8f60bc44
    int32_t v20 = v19; // R2
    int32_t v21 = g21; // R3
    int32_t v22 = v21; // 0x8f60bc50
    int32_t v23 = v20; // 0x8f60bc50
    int32_t v24 = v23 | v22; // 0x8f60bc50
    int32_t v25 = v22; // 0x8f60bc74
    int32_t v26 = v22; // 0x8f60bc74
    int32_t v27 = __aeabi_uldivmod(v18, (int64_t)v19); // 0x8f60bc74
    if (v23 != v22) {
        // 0x8f60bc58
        v24 = (int32_t)"ASSERT FAILED at (%s:%d): %s\n";
        v20 = (int32_t)"platform/msm_shared/mmc_wrapper.c";
        v21 = (int32_t)"!(len % block_size)" & -0x10000 | 335;
        v25 = v21;
        v26 = v20;
        v27 = _panic(v9, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm_shared/mmc_wrapper.c", (int32_t)"!(len % block_size)" & -0x10000 | 335, (int32_t)"!(len % block_size)", v17, g16);
        v16 = "!(len % block_size)";
        // branch -> 0x8f60bc74
    }
    int32_t v28 = platform_boot_dev_isemmc(v27, v24, v26, v25); // 0x8f60bc74
    int32_t result2; // R0
    int32_t result; // bp+233
    int32_t v29;
    if (v28 == 0) {
        int32_t v30 = __aeabi_uldivmod(v18, (int64_t)g20); // 0x8f60be68
        if (ufs_erase(g25, g19, g16, g17) == 0) {
            // 0x8f60be2c
            result2 = 0;
            result = 0;
            // branch -> 0x8f60be94
        } else {
            // 0x8f60be84
            // branch -> 0x8f60be8c
            // 0x8f60be8c
            print_log(-1, (int32_t)"mmc_erase_card: UFS erase failed\n", g16, g17, v30, v17, g16, g17, g18, g19, 0, v11, 0);
            // branch -> 0x8f60be90
            // 0x8f60be90
            result2 = 1;
            result = 1;
            // branch -> 0x8f60be94
        }
        // 0x8f60be94
        v29 = g14;
        g1 = v10 == v29;
        if (v10 == v29) {
            // 0x8f60bea8
            g20 = v2;
            g21 = v3;
            g23 = v5;
            g24 = v6;
            return result;
        }
        // 0x8f60bea4
        __stack_chk_fail();
        // branch -> 0x8f60bea8
        // 0x8f60bea8
        g20 = v2;
        g21 = v3;
        g23 = v5;
        g24 = v6;
        return result2;
    }
    int32_t v31 = mmc_get_eraseunit_size(v28, v24, v20, v21); // 0x8f60bc80
    g22 = v31;
    int32_t v32 = (int32_t)v16;
    print_log(2, (int32_t)"erase_unit_sz:0x%x\n", v31, v21, v32, v17, g16, g17, g18, g19, 0, v11, 0);
    int32_t v33 = __aeabi_uldivmod(v14, (int64_t)g20); // 0x8f60bca4
    g23 = v33;
    g24 = v33;
    int32_t v34 = __aeabi_uldivmod(v18, (int64_t)g20); // 0x8f60bcbc
    int32_t v35 = g23; // 0x8f60bcc0
    g21 = v34;
    g20 = v34;
    print_log(1, (int32_t)"Erasing card: 0x%x:0x%x\n", v35, v34, v32, v17, g16, g17, g18, g19, 0, v11, 0);
    uint32_t v36 = g22; // 0x8f60bcdc
    uint32_t v37 = g23; // 0x8f60bce0
    int32_t v38;
    int32_t v39;
    int32_t v40;
    if ((g21 + v37) / v36 == v37 / v36) {
        // 0x8f60bd00
        result2 = print_log(1, (int32_t)"SDHCI unit erase not required\n", v35, v34, v32, v17, g16, g17, g18, g19, 0, v11, 0);
        int32_t v41 = g14;
        g1 = v10 == v41;
        if (v10 != v41) {
            // 0x8f60bea4
            __stack_chk_fail();
            // branch -> 0x8f60bea8
            // 0x8f60bea8
            g20 = v2;
            g21 = v3;
            g23 = v5;
            g24 = v6;
            return result2;
        }
        // 0x8f60bdc4
        v40 = g25;
        v39 = g23;
        v38 = g21;
        g20 = v2;
        g21 = v3;
        g22 = v4;
        g23 = v5;
        g24 = v6;
        g25 = v7;
        g15 = v9;
        return mmc_zero_out(v40, v39, v38);
    }
    int32_t v42 = v36 - v37 % v36; // 0x8f60bd38
    int32_t v43 = v42; // R11
    int32_t v44; // 0x8f60be0c
    int32_t v45; // 0x8f60be0c
    int32_t v46; // 0x8f60be10
    int32_t v47;
    int32_t result3; // 0x8f60beac_2
    int32_t v48;
    uint32_t v49; // 0x8f60bde8
    uint64_t v50; // 0x8f60be0c
    int32_t v51; // 0x8f60bde8
    if (v42 < v36) {
        // 0x8f60bd2c
        v49 = g20;
        // branch -> 0x8f60bdd0
        // 0x8f60bdd0
        v48 = v49 % v36;
        g21 = 0;
        v51 = v49 - v48;
        g22 = v51;
        g23 = v48;
        g20 = v51;
        print_log(2, (int32_t)"Performing SDHCI erase: 0x%x:0x%llx\n", g24, v34, v51, 0, g16, g17, g18, g19, 0, v11, 0);
        v50 = (int64_t)g22 * v13;
        v44 = v50;
        v45 = v50 / 0x100000000;
        v21 = v45;
        v20 = v44;
        v46 = mmc_sdhci_erase(g25, g24, v44, v45, v51, 0, g16, g17, g18, g19, 0, v11, 0, v10, 0, v2, v3, v4, v5, v6, v7, v1, v8);
        if (v46 != 0) {
            // if_8f60be18_0_true
            // branch -> 0x8f60be8c
            // 0x8f60be8c
            print_log(-1, (int32_t)"MMC erase failed\n", v20, v21, v51, 0, g16, g17, g18, g19, 0, v11, 0);
            // branch -> 0x8f60be90
            // 0x8f60be90
            // branch -> 0x8f60be94
            // 0x8f60be94
            v29 = g14;
            g1 = v10 == v29;
            if (v10 != v29) {
                // 0x8f60bea4
                __stack_chk_fail();
                // branch -> 0x8f60bea8
            }
            // 0x8f60bea8
            g20 = v2;
            g21 = v3;
            g23 = v5;
            g24 = v6;
            return 1;
        }
        // 0x8f60be24
        if (g23 == 0) {
            // 0x8f60be2c
            result2 = 0;
            result = 0;
            // branch -> 0x8f60be94
        } else {
            // 0x8f60be34
            print_log(2, (int32_t)"Handling unaligned tail blocks\n", v20, v21, v51, 0, g16, g17, g18, g19, 0, v11, 0);
            v47 = mmc_zero_out(g25, g22 + g24, g23) != 0;
            result2 = v47;
            result = v47;
            // branch -> 0x8f60be94
        }
        // 0x8f60be94
        v29 = g14;
        g1 = v10 == v29;
        if (v10 != v29) {
            // 0x8f60bea4
            __stack_chk_fail();
            result3 = result2;
            // branch -> 0x8f60bea8
        } else {
            result3 = result;
        }
        // 0x8f60bea8
        g20 = v2;
        g21 = v3;
        g23 = v5;
        g24 = v6;
        return result3;
    }
    // 0x8f60bd44
    print_log(2, (int32_t)"Handling unaligned head blocks\n", v35, v34, v32, v17, g16, g17, g18, g19, 0, v11, 0);
    if (mmc_zero_out(g25, g23, v43) != 0) {
        // 0x8f60be90
        // branch -> 0x8f60be94
        // 0x8f60be94
        v29 = g14;
        g1 = v10 == v29;
        if (v10 == v29) {
            // 0x8f60bea8
            g20 = v2;
            g21 = v3;
            g23 = v5;
            g24 = v6;
            return 1;
        }
        // 0x8f60bea4
        __stack_chk_fail();
        // branch -> 0x8f60bea8
        // 0x8f60bea8
        g20 = v2;
        g21 = v3;
        g23 = v5;
        g24 = v6;
        return 1;
    }
    int32_t v52 = g23; // 0x8f60bd68
    int32_t v53 = v52 + v43; // 0x8f60bd68
    g24 = v53;
    int32_t v54 = g21; // 0x8f60bd6c
    int32_t v55 = v54 - v43; // 0x8f60bd6c
    g20 = v55;
    uint32_t v56 = g22; // 0x8f60bd74
    int32_t v57 = (v52 - 1 + v54) / v56;
    g21 = v57;
    if (v57 - v53 / v56 > 1) {
        v49 = v55;
        // 0x8f60bdd0
        v48 = v49 % v56;
        g21 = 0;
        v51 = v49 - v48;
        g22 = v51;
        g23 = v48;
        g20 = v51;
        print_log(2, (int32_t)"Performing SDHCI erase: 0x%x:0x%llx\n", v53, v34, v51, 0, g16, g17, g18, g19, 0, v11, 0);
        v50 = (int64_t)g22 * v13;
        v44 = v50;
        v45 = v50 / 0x100000000;
        v21 = v45;
        v20 = v44;
        v46 = mmc_sdhci_erase(g25, g24, v44, v45, v51, 0, g16, g17, g18, g19, 0, v11, 0, v10, 0, v2, v3, v4, v5, v6, v7, v1, v8);
        if (v46 == 0) {
            // 0x8f60be24
            if (g23 == 0) {
                // 0x8f60be2c
                result2 = 0;
                result = 0;
                // branch -> 0x8f60be94
            } else {
                // 0x8f60be34
                print_log(2, (int32_t)"Handling unaligned tail blocks\n", v20, v21, v51, 0, g16, g17, g18, g19, 0, v11, 0);
                v47 = mmc_zero_out(g25, g22 + g24, g23) != 0;
                result2 = v47;
                result = v47;
                // branch -> 0x8f60be94
            }
            // 0x8f60be94
            v29 = g14;
            g1 = v10 == v29;
            if (v10 != v29) {
                // 0x8f60bea4
                __stack_chk_fail();
                result3 = result2;
                // branch -> 0x8f60bea8
            } else {
                result3 = result;
            }
            // 0x8f60bea8
            g20 = v2;
            g21 = v3;
            g23 = v5;
            g24 = v6;
            return result3;
        }
        // if_8f60be18_0_true
        // branch -> 0x8f60be8c
        // 0x8f60be8c
        print_log(-1, (int32_t)"MMC erase failed\n", v20, v21, v51, 0, g16, g17, g18, g19, 0, v11, 0);
        // branch -> 0x8f60be90
        // 0x8f60be90
        // branch -> 0x8f60be94
        // 0x8f60be94
        v29 = g14;
        g1 = v10 == v29;
        if (v10 != v29) {
            // 0x8f60bea4
            __stack_chk_fail();
            result3 = 1;
            // branch -> 0x8f60bea8
        } else {
            result3 = 1;
        }
    } else {
        // 0x8f60bd9c
        result2 = print_log(1, (int32_t)"SDHCI unit erase not required\n", v43, v34, v32, v17, g16, g17, g18, g19, 0, v11, 0);
        int32_t v58 = g14;
        g1 = v10 == v58;
        if (v10 == v58) {
            // 0x8f60bdc4
            v40 = g25;
            v39 = g24;
            v38 = g20;
            g20 = v2;
            g21 = v3;
            g22 = v4;
            g23 = v5;
            g24 = v6;
            g25 = v7;
            g15 = v9;
            return mmc_zero_out(v40, v39, v38);
        }
        // 0x8f60bea4
        __stack_chk_fail();
        result3 = result2;
        // branch -> 0x8f60bea8
    }
    // 0x8f60bea8
    g20 = v2;
    g21 = v3;
    g23 = v5;
    g24 = v6;
    return result3;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 22
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:33:58
