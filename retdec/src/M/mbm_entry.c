//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_constprop_4_4(char * a1, int32_t a2, int32_t a3);
char * __utag_puts_constprop_5(char * str2, char * a2);
int32_t app_thread_entry(int32_t a1, int32_t a2);
int32_t apps_init(int32_t a1, int32_t a2, int32_t a3);
int32_t gpt_get_back_zone_address(int32_t a1, int32_t a2, int32_t a3);
int32_t insert_timer_in_queue(int32_t a1, int32_t a2, int32_t a3);
char * mbm_entry(void);
int32_t pmic_decode_reg(int32_t a1, int32_t a2);
int32_t pmic_get_name(void);
int32_t pmic_get_version(int32_t a1);
int32_t pmic_read_reg(int32_t a1, int32_t a2);
int32_t pmic_write_reg(int32_t a1, uint32_t a2);
int32_t timer_initialize(int32_t * a1, int32_t a2, int32_t a3);
int32_t timer_set(int32_t a1, int32_t a2, int32_t a3);
int32_t timer_tick(int32_t a1, int32_t a2, int32_t a3);
int32_t type_atoi_3(char * str, int32_t a2, int32_t a3);
int32_t type_itoa(int32_t a1, int32_t a2, int32_t a3);
int32_t wait_queue_timeout_handler(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g33 = 0; // LR
int32_t g34 = 0; // R0
int32_t g35 = 0; // R1
int32_t g36 = 0; // R2
int32_t g37 = 0; // R3
int32_t g38 = 0; // R4
int32_t g39 = 0; // R5
int32_t g40 = 0; // R6
int32_t g41 = 0; // R7
int32_t g42 = 0; // R8
int32_t g43 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f61c6b4
int32_t g2 = -0x16d2be10; // 0x8f61cfe4
int32_t g3 = -0x16d2bf90; // 0x8f61db1c
int32_t g4 = -0x16d2bf81; // 0x8f61dca0
int32_t g5 = -0x1a60ced0; // 0x8f638854
int32_t g6 = -0x16d2bfe1; // 0x8f6389cc
char * g7[28] = {
    "unknown",
    "pm8941",
    "pm8841",
    "pm8019",
    "pm8026",
    "pm8110",
    "pma8084",
    "pmi8962",
    "pmd9635",
    "pm8994",
    "pmi8994",
    "pm8916",
    "reserved",
    "warm reset",
    "immediate XVDD shutdown",
    "reserved",
    "shutdown",
    "DVDD shutdown",
    "XVDD shutdown",
    "hardware reset",
    "DVDD hardware reset",
    "XVDD hardware reset",
    "warm reset and DVDD shutdown",
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681dcc
char * g8[12] = {
    "shutdown",
    "DVDD shutdown",
    "XVDD shutdown",
    "hardware reset",
    "DVDD hardware reset",
    "XVDD hardware reset",
    "warm reset and DVDD shutdown",
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e0c
char * g9[8] = {
    "DVDD hardware reset",
    "XVDD hardware reset",
    "warm reset and DVDD shutdown",
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e1c
char * g10[7] = {
    "XVDD hardware reset",
    "warm reset and DVDD shutdown",
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e20
char * g11[6] = {
    "warm reset and DVDD shutdown",
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e24
char * g12[5] = {
    "warm reset and XVDD shutdown",
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e28
char * g13[4] = {
    "warm reset and shutdown",
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e2c
char * g14[3] = {
    "warm reset then hardware reset",
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e30
char * g15[2] = {
    "warm reset then DVDD hardware reset",
    "warm reset then XVDD hardware reset"
}; // 0x8f681e34
char (*g16)[36] = "warm reset then XVDD hardware reset"; // 0x8f681e38
int32_t g17 = 0x2020003a; // 0x8f686ac4
int32_t g20 = -0x709d39dc; // 0x8f6a93e4
int32_t g21 = 1; // 0x8f6ac0f0
char * g24[2] = {
    "ttyHSL0,115200,n8",
    "ttyHSL0,115200,n8"
}; // 0x8f6ac1a8
int32_t g25 = 0; // 0x8f6c01d0
int32_t g26 = 0; // 0x8f6c01d4
char * g27; // 0x8f6c01d8
char * g28; // 0x8f6c0258
char * g29; // 0x8f6c0298
int32_t g30 = 0; // 0x8f7112f4
char * g31; // 0x8f7114b0
int32_t g32 = 0; // 0x8f7114b4
char * g18[2] = {
    "mbm",
    (char *)&g2
}; // 0x8f6a93c4
char * g19[3] = {
    "screen_manager",
    (char *)&g6,
    (char *)&g5
}; // 0x8f6a93d4
char * g22[4] = {
    "null",
    "fastboot",
    (char *)&g3,
    (char *)&g4
}; // 0x8f6ac108
char * g23[3] = {
    "fastboot",
    (char *)&g3,
    (char *)&g4
}; // 0x8f6ac10c

// ------------------------ Functions -------------------------

// Address range: 0x8f61cc94 - 0x8f61cfe3
char * mbm_entry(void) {
    g38 = 0;
    g39 = &g30;
    int32_t v1 = 0; // bp-136
    int32_t v2 = g30;
    g43 = &g30;
    int32_t v3;
    memset((char *)&v3, 0, 29);
    int32_t v4;
    int32_t v5 = &v4; // 0x8f61cccc_0
    memset((char *)&v4, g38, 11);
    int32_t v6 = 0x1000000 * g38 / 0x1000000; // bp-149
    print_log(1, (int32_t)"MBM version is %02X.%02X (%s)\n", 129, 4, (int32_t)"3220316", 0, 0, v4, 0, 0, 0, v3, 0);
    char * v7; // 0x8f61ced0
    int32_t v8; // 0x8f61cd40_0
    int32_t v9; // 0x8f61ce28_0
    int32_t v10; // 0x8f61cd74
    int32_t v11; // 0x8f61cdb0
    int32_t v12; // 0x8f61cdec
    int32_t v13; // 0x8f61ce10
    int32_t v14; // 0x8f61ce34
    int32_t v15; // 0x8f61ce44
    int32_t v16; // 0x8f61ce58
    int32_t v17; // 0x8f61ce5c
    int32_t v18; // 0x8f61cea0
    int32_t v19; // 0x8f61cea4
    int32_t v20; // 0x8f61ceb8
    int32_t v21; // 0x8f61cecc
    int32_t v22; // R1
    int32_t v23; // 0x8f61ced0
    int32_t v24; // R4
    int32_t str;
    int32_t v25; // 0x8f61ce98
    int32_t v26; // 0x8f61cedc
    int32_t v27; // 0x8f61cee88
    int32_t v28; // 0x8f61cf0c
    int32_t v29; // 0x8f61cf14
    int32_t v30; // 0x8f61cf3c
    int32_t v31; // 0x8f61cf70
    int32_t v32; // 0x8f61ce38
    int32_t v33; // 0x8f61cf00
    int32_t v34; // 0x8f61cf68
    int32_t v35; // 0x8f61cf2c
    int32_t v36; // 0x8f61cf58
    if (__utag_sizeof((char *)g38, (int32_t)"console", 129, 4, (int32_t)"3220316", 0, 0, v4, 0) == 1) {
        // 0x8f61cd0c
        g35 = (int32_t)"console";
        int32_t v37;
        int32_t v38 = &v37; // 0x8f61cd14_0
        g36 = v38;
        int32_t v39 = g38; // 0x8f61cd1c
        if (__utag_read((char *)g38, (int32_t)"console", v38, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, 0, v3, 0) == v39) {
            // 0x8f61cd3c
            v8 = &v1;
            __utag_gets_constprop_4_4("console", v8, 33);
            // branch -> 0x8f61cd50
            // 0x8f61cd50
            set_console_string((char *)v8, g35, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (__utag_gets_constprop_4_4("loglevel.uart", v5, 11) != 0) {
                // 0x8f61cd6c
                v10 = get_log_level_by_desc(NULL, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
                if (v10 != -10) {
                    // 0x8f61cd84
                    set_logger_level(NULL, 0x1000000 * v10 / 0x1000000, 11, g37);
                    // branch -> 0x8f61cd90
                }
            }
            // 0x8f61cd90
            if (__utag_gets_constprop_4_4("loglevel.ui", v5, 11) != 0) {
                // 0x8f61cda8
                v11 = get_log_level_by_desc((char *)2, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
                if (v11 != -10) {
                    // 0x8f61cdc0
                    set_logger_level((char *)2, 0x1000000 * v11 / 0x1000000, 11, g37);
                    // branch -> 0x8f61cdcc
                }
            }
            // 0x8f61cdcc
            if (__utag_gets_constprop_4_4("loglevel.ram", v5, 11) != 0) {
                // 0x8f61cde4
                v12 = get_log_level_by_desc((char *)1, v5, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
                if (v12 != -10) {
                    // 0x8f61cdfc
                    g36 = set_logger_level((char *)1, 0x1000000 * v12 / 0x1000000, g36, g37);
                    // branch -> 0x8f61ce08
                }
            }
            // 0x8f61ce08
            v22 = (int32_t)"disable-reset";
            v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v13 == 1) {
                // 0x8f61ce20
                v22 = (int32_t)"disable-reset";
                v9 = &v6;
                g36 = v9;
                __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                // branch -> 0x8f61ce30
            }
            // 0x8f61ce30
            v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
            v32 = 0x1000000 * v6 / 0x1000000;
            *(char *)&g31 = (char)v32;
            v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
            switch (v15) {
                case -2: {
                    // 0x8f61ce50
                    v22 = (int32_t)"Invalid sp partition - resetting...\n";
                    v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    if (v17 == 0) {
                        // 0x8f61ce78
                        sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                        // branch -> 0x8f61ce88
                        // 0x8f61ce88
                        v24 = (int32_t)&g29;
                        target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                        g35 = (int32_t)"Serial number: \"%s\"\n";
                        v25 = v24;
                        v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                        *(int32_t *)(v19 + 16) = v24;
                        g32 = v19;
                        v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v20;
                        v7 = NULL;
                        if (v20 != 0) {
                            // 0x8f61cec4
                            sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                            v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                            g34 = v21;
                            v7 = (char *)v21;
                            // branch -> 0x8f61ced0
                        }
                        // 0x8f61ced0
                        v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                        g36 = v23;
                        g40 = (int32_t)&g23;
                        g38 = 0;
                        g39 = 0;
                        g41 = (int32_t)&g23;
                        v27 = *(int32_t *)((int32_t)&g23 + 4);
                        g37 = v27;
                        if (v27 != 0) {
                            while (true) {
                                // 0x8f61cef4
                                g33 = -0x709e3108;
                                ((int32_t (*)())v27)();
                                if (g34 == 0) {
                                    goto lab_0x8f61cf24_17;
                                }
                                // 0x8f61cef4
                                // branch -> 0x8f61cf00
                            }
                        }
                        // 0x8f61cf00
                        v33 = (int32_t)&g23;
                        g40 = v33;
                        g34 = 0;
                        g42 = (int32_t)&g23;
                        v28 = *(int32_t *)(v33 + 8);
                        g37 = v28;
                        g33 = -0x709e30ec;
                        ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                        v29 = *(int32_t *)(g40 + 12);
                        if (v29 != 0) {
                            // 0x8f61cf2c
                            v35 = *(int32_t *)(16 * g38 + g42);
                            g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                            print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                            v30 = *(int32_t *)(g40 + 12);
                            g36 = v30;
                            if (v30 == (int32_t)&g4) {
                                // 0x8f61cf4c
                                g35 = 64;
                                g36 = (int32_t)"Fall-through from %s boot mode";
                                v36 = *(int32_t *)(16 * g38 + g42);
                                snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                                fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                                // branch -> 0x8f61cf68
                            }
                            // 0x8f61cf68
                            v34 = g41 + g39;
                            g39 = v34;
                            g34 = 0;
                            v31 = *(int32_t *)(v34 + 12);
                            g37 = v31;
                            g33 = -0x709e3088;
                            ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                            // branch -> 0x8f61cf78
                        }
                        // 0x8f61cf78
                        if (v2 != g30) {
                            // 0x8f61cf88
                            __stack_chk_fail();
                            // branch -> 0x8f61cf8c
                        }
                        // 0x8f61cf8c
                        return (char *)g34;
                    }
                    break;
                }
                case 0: {
                    // 0x8f61ce88
                    v24 = (int32_t)&g29;
                    target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    g35 = (int32_t)"Serial number: \"%s\"\n";
                    v25 = v24;
                    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    *(int32_t *)(v19 + 16) = v24;
                    g32 = v19;
                    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v20;
                    v7 = NULL;
                    if (v20 != 0) {
                        // 0x8f61cec4
                        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v21;
                        v7 = (char *)v21;
                        // branch -> 0x8f61ced0
                    }
                    // 0x8f61ced0
                    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                    g36 = v23;
                    g40 = (int32_t)&g23;
                    g38 = 0;
                    g39 = 0;
                    g41 = (int32_t)&g23;
                    v27 = *(int32_t *)((int32_t)&g23 + 4);
                    g37 = v27;
                    if (v27 != 0) {
                        while (true) {
                            // 0x8f61cef4
                            g33 = -0x709e3108;
                            ((int32_t (*)())v27)();
                            if (g34 == 0) {
                                goto lab_0x8f61cf24_17;
                            }
                            // 0x8f61cef4
                            // branch -> 0x8f61cf00
                        }
                    }
                    // 0x8f61cf00
                    v33 = (int32_t)&g23;
                    g40 = v33;
                    g34 = 0;
                    g42 = (int32_t)&g23;
                    v28 = *(int32_t *)(v33 + 8);
                    g37 = v28;
                    g33 = -0x709e30ec;
                    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                    v29 = *(int32_t *)(g40 + 12);
                    if (v29 != 0) {
                        // 0x8f61cf2c
                        v35 = *(int32_t *)(16 * g38 + g42);
                        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v30 = *(int32_t *)(g40 + 12);
                        g36 = v30;
                        if (v30 == (int32_t)&g4) {
                            // 0x8f61cf4c
                            g35 = 64;
                            g36 = (int32_t)"Fall-through from %s boot mode";
                            v36 = *(int32_t *)(16 * g38 + g42);
                            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                            // branch -> 0x8f61cf68
                        }
                        // 0x8f61cf68
                        v34 = g41 + g39;
                        g39 = v34;
                        g34 = 0;
                        v31 = *(int32_t *)(v34 + 12);
                        g37 = v31;
                        g33 = -0x709e3088;
                        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                        // branch -> 0x8f61cf78
                    }
                    // 0x8f61cf78
                    if (v2 != g30) {
                        // 0x8f61cf88
                        __stack_chk_fail();
                        // branch -> 0x8f61cf8c
                    }
                    // 0x8f61cf8c
                    return (char *)g34;
                }
            }
            // 0x8f61ce68
            print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            // branch -> 0x8f61ce88
            // 0x8f61ce88
            v24 = (int32_t)&g29;
            target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
            g35 = (int32_t)"Serial number: \"%s\"\n";
            v25 = v24;
            v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
            *(int32_t *)(v19 + 16) = v24;
            g32 = v19;
            v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v20;
            v7 = NULL;
            if (v20 != 0) {
                // 0x8f61cec4
                sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v21;
                v7 = (char *)v21;
                // branch -> 0x8f61ced0
            }
            // 0x8f61ced0
            v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
            g36 = v23;
            g40 = (int32_t)&g23;
            g38 = 0;
            g39 = 0;
            g41 = (int32_t)&g23;
            v27 = *(int32_t *)((int32_t)&g23 + 4);
            g37 = v27;
            if (v27 != 0) {
                while (true) {
                    // 0x8f61cef4
                    g33 = -0x709e3108;
                    ((int32_t (*)())v27)();
                    if (g34 == 0) {
                        goto lab_0x8f61cf24_17;
                    }
                    // 0x8f61cef4
                    // branch -> 0x8f61cf00
                }
            }
            // 0x8f61cf00
            v33 = (int32_t)&g23;
            g40 = v33;
            g34 = 0;
            g42 = (int32_t)&g23;
            v28 = *(int32_t *)(v33 + 8);
            g37 = v28;
            g33 = -0x709e30ec;
            ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
            v29 = *(int32_t *)(g40 + 12);
            if (v29 != 0) {
                // 0x8f61cf2c
                v35 = *(int32_t *)(16 * g38 + g42);
                g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v30 = *(int32_t *)(g40 + 12);
                g36 = v30;
                if (v30 == (int32_t)&g4) {
                    // 0x8f61cf4c
                    g35 = 64;
                    g36 = (int32_t)"Fall-through from %s boot mode";
                    v36 = *(int32_t *)(16 * g38 + g42);
                    snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                    fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                    // branch -> 0x8f61cf68
                }
                // 0x8f61cf68
                v34 = g41 + g39;
                g39 = v34;
                g34 = 0;
                v31 = *(int32_t *)(v34 + 12);
                g37 = v31;
                g33 = -0x709e3088;
                ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                // branch -> 0x8f61cf78
            }
            // 0x8f61cf78
            if (v2 != g30) {
                // 0x8f61cf88
                __stack_chk_fail();
                // branch -> 0x8f61cf8c
            }
            // 0x8f61cf8c
            return (char *)g34;
        }
        int32_t v40 = 0x1000000 * v37 / 0x1000000 == v39 ? (int32_t)&g22 : (int32_t)&g24;
        int32_t v41 = *(int32_t *)v40;
        // branch -> 0x8f61cd50
        // 0x8f61cd50
        set_console_string((char *)v41, g35, g36, v40, (int32_t)"3220316", 0, 0, v4, 0);
        if (__utag_gets_constprop_4_4("loglevel.uart", v5, 11) != 0) {
            // 0x8f61cd6c
            v10 = get_log_level_by_desc(NULL, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v10 != -10) {
                // 0x8f61cd84
                set_logger_level(NULL, 0x1000000 * v10 / 0x1000000, 11, g37);
                // branch -> 0x8f61cd90
            }
        }
        // 0x8f61cd90
        if (__utag_gets_constprop_4_4("loglevel.ui", v5, 11) != 0) {
            // 0x8f61cda8
            v11 = get_log_level_by_desc((char *)2, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v11 != -10) {
                // 0x8f61cdc0
                set_logger_level((char *)2, 0x1000000 * v11 / 0x1000000, 11, g37);
                // branch -> 0x8f61cdcc
            }
        }
        // 0x8f61cdcc
        if (__utag_gets_constprop_4_4("loglevel.ram", v5, 11) != 0) {
            // 0x8f61cde4
            v12 = get_log_level_by_desc((char *)1, v5, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v12 != -10) {
                // 0x8f61cdfc
                g36 = set_logger_level((char *)1, 0x1000000 * v12 / 0x1000000, g36, g37);
                // branch -> 0x8f61ce08
            }
        }
        // 0x8f61ce08
        v22 = (int32_t)"disable-reset";
        v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v13 == 1) {
            // 0x8f61ce20
            v22 = (int32_t)"disable-reset";
            v9 = &v6;
            g36 = v9;
            __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            // branch -> 0x8f61ce30
        }
        // 0x8f61ce30
        v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
        v32 = 0x1000000 * v6 / 0x1000000;
        *(char *)&g31 = (char)v32;
        v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
        switch (v15) {
            case -2: {
                // 0x8f61ce50
                v22 = (int32_t)"Invalid sp partition - resetting...\n";
                v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                if (v17 == 0) {
                    // 0x8f61ce78
                    sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                    // branch -> 0x8f61ce88
                    // 0x8f61ce88
                    v24 = (int32_t)&g29;
                    target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    g35 = (int32_t)"Serial number: \"%s\"\n";
                    v25 = v24;
                    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    *(int32_t *)(v19 + 16) = v24;
                    g32 = v19;
                    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v20;
                    v7 = NULL;
                    if (v20 != 0) {
                        // 0x8f61cec4
                        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v21;
                        v7 = (char *)v21;
                        // branch -> 0x8f61ced0
                    }
                    // 0x8f61ced0
                    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                    g36 = v23;
                    g40 = (int32_t)&g23;
                    g38 = 0;
                    g39 = 0;
                    g41 = (int32_t)&g23;
                    v27 = *(int32_t *)((int32_t)&g23 + 4);
                    g37 = v27;
                    if (v27 != 0) {
                        int32_t v42 = v27; // 0x8f61cef4
                        while (true) {
                            // 0x8f61cef4
                            g33 = -0x709e3108;
                            ((int32_t (*)())v42)();
                            if (g34 == 0) {
                              lab_0x8f61cf24_17:;
                                int32_t v43 = g38 + 1; // 0x8f61cf24
                                g38 = v43;
                                v26 = 16 * v43;
                                g39 = v26;
                                g41 = (int32_t)&g23;
                                int32_t v44 = *(int32_t *)(v26 + g40 + 4); // 0x8f61cee8
                                g37 = v44;
                                if (v44 == 0) {
                                    // break (via goto) -> 0x8f61cf00
                                    goto lab_0x8f61cf00;
                                }
                                v42 = v44;
                                // continue -> 0x8f61cef4
                                continue;
                            }
                            // 0x8f61cf00
                            v33 = g39 + g41;
                            g40 = v33;
                            g34 = 0;
                            g42 = (int32_t)&g23;
                            v28 = *(int32_t *)(v33 + 8);
                            g37 = v28;
                            g33 = -0x709e30ec;
                            ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                            v29 = *(int32_t *)(g40 + 12);
                            if (v29 != 0) {
                                // 0x8f61cf2c
                                v35 = *(int32_t *)(16 * g38 + g42);
                                g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                                print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                                v30 = *(int32_t *)(g40 + 12);
                                g36 = v30;
                                if (v30 == (int32_t)&g4) {
                                    // 0x8f61cf4c
                                    g35 = 64;
                                    g36 = (int32_t)"Fall-through from %s boot mode";
                                    v36 = *(int32_t *)(16 * g38 + g42);
                                    snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                                    fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                                    // branch -> 0x8f61cf68
                                }
                                // 0x8f61cf68
                                v34 = g41 + g39;
                                g39 = v34;
                                g34 = 0;
                                v31 = *(int32_t *)(v34 + 12);
                                g37 = v31;
                                g33 = -0x709e3088;
                                ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                                // branch -> 0x8f61cf78
                            }
                            // 0x8f61cf78
                            if (v2 != g30) {
                                // 0x8f61cf88
                                __stack_chk_fail();
                                // branch -> 0x8f61cf8c
                            }
                            // 0x8f61cf8c
                            return (char *)g34;
                        }
                    }
                    // 0x8f61cf00
                    v33 = (int32_t)&g23;
                    g40 = v33;
                    g34 = 0;
                    g42 = (int32_t)&g23;
                    v28 = *(int32_t *)(v33 + 8);
                    g37 = v28;
                    g33 = -0x709e30ec;
                    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                    v29 = *(int32_t *)(g40 + 12);
                    if (v29 != 0) {
                        // 0x8f61cf2c
                        v35 = *(int32_t *)(16 * g38 + g42);
                        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v30 = *(int32_t *)(g40 + 12);
                        g36 = v30;
                        if (v30 == (int32_t)&g4) {
                            // 0x8f61cf4c
                            g35 = 64;
                            g36 = (int32_t)"Fall-through from %s boot mode";
                            v36 = *(int32_t *)(16 * g38 + g42);
                            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                            // branch -> 0x8f61cf68
                        }
                        // 0x8f61cf68
                        v34 = g41 + g39;
                        g39 = v34;
                        g34 = 0;
                        v31 = *(int32_t *)(v34 + 12);
                        g37 = v31;
                        g33 = -0x709e3088;
                        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                        // branch -> 0x8f61cf78
                    }
                    // 0x8f61cf78
                    if (v2 != g30) {
                        // 0x8f61cf88
                        __stack_chk_fail();
                        // branch -> 0x8f61cf8c
                    }
                    // 0x8f61cf8c
                    return (char *)g34;
                }
                break;
            }
            case 0: {
                // 0x8f61ce88
                v24 = (int32_t)&g29;
                target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                g35 = (int32_t)"Serial number: \"%s\"\n";
                v25 = v24;
                v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                *(int32_t *)(v19 + 16) = v24;
                g32 = v19;
                v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v20;
                v7 = NULL;
                if (v20 != 0) {
                    // 0x8f61cec4
                    sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                    v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v21;
                    v7 = (char *)v21;
                    // branch -> 0x8f61ced0
                }
                // 0x8f61ced0
                v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                g36 = v23;
                g40 = (int32_t)&g23;
                g38 = 0;
                g39 = 0;
                g41 = (int32_t)&g23;
                v27 = *(int32_t *)((int32_t)&g23 + 4);
                g37 = v27;
                if (v27 != 0) {
                    while (true) {
                        // 0x8f61cef4
                        g33 = -0x709e3108;
                        ((int32_t (*)())v27)();
                        if (g34 == 0) {
                            goto lab_0x8f61cf24_17;
                        }
                        // 0x8f61cef4
                        // branch -> 0x8f61cf00
                    }
                }
                // 0x8f61cf00
                v33 = (int32_t)&g23;
                g40 = v33;
                g34 = 0;
                g42 = (int32_t)&g23;
                v28 = *(int32_t *)(v33 + 8);
                g37 = v28;
                g33 = -0x709e30ec;
                ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                v29 = *(int32_t *)(g40 + 12);
                if (v29 != 0) {
                    // 0x8f61cf2c
                    v35 = *(int32_t *)(16 * g38 + g42);
                    g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                    print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v30 = *(int32_t *)(g40 + 12);
                    g36 = v30;
                    if (v30 == (int32_t)&g4) {
                        // 0x8f61cf4c
                        g35 = 64;
                        g36 = (int32_t)"Fall-through from %s boot mode";
                        v36 = *(int32_t *)(16 * g38 + g42);
                        snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                        fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                        // branch -> 0x8f61cf68
                    }
                    // 0x8f61cf68
                    v34 = g41 + g39;
                    g39 = v34;
                    g34 = 0;
                    v31 = *(int32_t *)(v34 + 12);
                    g37 = v31;
                    g33 = -0x709e3088;
                    ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                    // branch -> 0x8f61cf78
                }
                // 0x8f61cf78
                if (v2 != g30) {
                    // 0x8f61cf88
                    __stack_chk_fail();
                    // branch -> 0x8f61cf8c
                }
                // 0x8f61cf8c
                return (char *)g34;
            }
        }
        // 0x8f61ce68
        print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        // branch -> 0x8f61ce88
        // 0x8f61ce88
        v24 = (int32_t)&g29;
        target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        g35 = (int32_t)"Serial number: \"%s\"\n";
        v25 = v24;
        v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        *(int32_t *)(v19 + 16) = v24;
        g32 = v19;
        v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
        g34 = v20;
        v7 = NULL;
        if (v20 != 0) {
            // 0x8f61cec4
            sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
            v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v21;
            v7 = (char *)v21;
            // branch -> 0x8f61ced0
        }
        // 0x8f61ced0
        v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
        g36 = v23;
        g40 = (int32_t)&g23;
        g38 = 0;
        g39 = 0;
        g41 = (int32_t)&g23;
        v27 = *(int32_t *)((int32_t)&g23 + 4);
        g37 = v27;
        if (v27 != 0) {
            while (true) {
                // 0x8f61cef4
                g33 = -0x709e3108;
                ((int32_t (*)())v27)();
                if (g34 == 0) {
                    goto lab_0x8f61cf24_17;
                }
                // 0x8f61cef4
                // branch -> 0x8f61cf00
            }
        }
        // 0x8f61cf00
        v33 = (int32_t)&g23;
        g40 = v33;
        g34 = 0;
        g42 = (int32_t)&g23;
        v28 = *(int32_t *)(v33 + 8);
        g37 = v28;
        g33 = -0x709e30ec;
        ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
        v29 = *(int32_t *)(g40 + 12);
        if (v29 != 0) {
            // 0x8f61cf2c
            v35 = *(int32_t *)(16 * g38 + g42);
            g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
            print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v30 = *(int32_t *)(g40 + 12);
            g36 = v30;
            if (v30 == (int32_t)&g4) {
                // 0x8f61cf4c
                g35 = 64;
                g36 = (int32_t)"Fall-through from %s boot mode";
                v36 = *(int32_t *)(16 * g38 + g42);
                snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                // branch -> 0x8f61cf68
            }
            // 0x8f61cf68
            v34 = g41 + g39;
            g39 = v34;
            g34 = 0;
            v31 = *(int32_t *)(v34 + 12);
            g37 = v31;
            g33 = -0x709e3088;
            ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
            // branch -> 0x8f61cf78
        }
        // 0x8f61cf78
        if (v2 != g30) {
            // 0x8f61cf88
            __stack_chk_fail();
            // branch -> 0x8f61cf8c
        }
        // 0x8f61cf8c
        return (char *)g34;
    }
    // 0x8f61cd3c
    v8 = &v1;
    __utag_gets_constprop_4_4("console", v8, 33);
    // branch -> 0x8f61cd50
    // 0x8f61cd50
    set_console_string((char *)v8, g35, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
    if (__utag_gets_constprop_4_4("loglevel.uart", v5, 11) != 0) {
        // 0x8f61cd6c
        v10 = get_log_level_by_desc(NULL, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v10 != -10) {
            // 0x8f61cd84
            set_logger_level(NULL, 0x1000000 * v10 / 0x1000000, 11, g37);
            // branch -> 0x8f61cd90
        }
        // 0x8f61cd90
        if (__utag_gets_constprop_4_4("loglevel.ui", v5, 11) != 0) {
            // 0x8f61cda8
            v11 = get_log_level_by_desc((char *)2, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v11 != -10) {
                // 0x8f61cdc0
                set_logger_level((char *)2, 0x1000000 * v11 / 0x1000000, 11, g37);
                // branch -> 0x8f61cdcc
            }
        }
        // 0x8f61cdcc
        if (__utag_gets_constprop_4_4("loglevel.ram", v5, 11) != 0) {
            // 0x8f61cde4
            v12 = get_log_level_by_desc((char *)1, v5, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v12 != -10) {
                // 0x8f61cdfc
                g36 = set_logger_level((char *)1, 0x1000000 * v12 / 0x1000000, g36, g37);
                // branch -> 0x8f61ce08
            }
        }
        // 0x8f61ce08
        v22 = (int32_t)"disable-reset";
        v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v13 == 1) {
            // 0x8f61ce20
            v22 = (int32_t)"disable-reset";
            v9 = &v6;
            g36 = v9;
            __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            // branch -> 0x8f61ce30
        }
        // 0x8f61ce30
        v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
        v32 = 0x1000000 * v6 / 0x1000000;
        *(char *)&g31 = (char)v32;
        v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
        switch (v15) {
            case -2: {
                // 0x8f61ce50
                v22 = (int32_t)"Invalid sp partition - resetting...\n";
                v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                if (v17 == 0) {
                    // 0x8f61ce78
                    sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                    // branch -> 0x8f61ce88
                    // 0x8f61ce88
                    v24 = (int32_t)&g29;
                    target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    g35 = (int32_t)"Serial number: \"%s\"\n";
                    v25 = v24;
                    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    *(int32_t *)(v19 + 16) = v24;
                    g32 = v19;
                    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v20;
                    v7 = NULL;
                    if (v20 != 0) {
                        // 0x8f61cec4
                        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v21;
                        v7 = (char *)v21;
                        // branch -> 0x8f61ced0
                    }
                    // 0x8f61ced0
                    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                    g36 = v23;
                    g40 = (int32_t)&g23;
                    g38 = 0;
                    g39 = 0;
                    g41 = (int32_t)&g23;
                    v27 = *(int32_t *)((int32_t)&g23 + 4);
                    g37 = v27;
                    if (v27 != 0) {
                        while (true) {
                            // 0x8f61cef4
                            g33 = -0x709e3108;
                            ((int32_t (*)())v27)();
                            if (g34 == 0) {
                                goto lab_0x8f61cf24_17;
                            }
                            // 0x8f61cef4
                            // branch -> 0x8f61cf00
                        }
                    }
                    // 0x8f61cf00
                    v33 = (int32_t)&g23;
                    g40 = v33;
                    g34 = 0;
                    g42 = (int32_t)&g23;
                    v28 = *(int32_t *)(v33 + 8);
                    g37 = v28;
                    g33 = -0x709e30ec;
                    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                    v29 = *(int32_t *)(g40 + 12);
                    if (v29 != 0) {
                        // 0x8f61cf2c
                        v35 = *(int32_t *)(16 * g38 + g42);
                        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v30 = *(int32_t *)(g40 + 12);
                        g36 = v30;
                        if (v30 == (int32_t)&g4) {
                            // 0x8f61cf4c
                            g35 = 64;
                            g36 = (int32_t)"Fall-through from %s boot mode";
                            v36 = *(int32_t *)(16 * g38 + g42);
                            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                            // branch -> 0x8f61cf68
                        }
                        // 0x8f61cf68
                        v34 = g41 + g39;
                        g39 = v34;
                        g34 = 0;
                        v31 = *(int32_t *)(v34 + 12);
                        g37 = v31;
                        g33 = -0x709e3088;
                        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                        // branch -> 0x8f61cf78
                    }
                    // 0x8f61cf78
                    if (v2 != g30) {
                        // 0x8f61cf88
                        __stack_chk_fail();
                        // branch -> 0x8f61cf8c
                    }
                    // 0x8f61cf8c
                    return (char *)g34;
                }
                break;
            }
            case 0: {
                // 0x8f61ce88
                v24 = (int32_t)&g29;
                target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                g35 = (int32_t)"Serial number: \"%s\"\n";
                v25 = v24;
                v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                *(int32_t *)(v19 + 16) = v24;
                g32 = v19;
                v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v20;
                v7 = NULL;
                if (v20 != 0) {
                    // 0x8f61cec4
                    sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                    v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v21;
                    v7 = (char *)v21;
                    // branch -> 0x8f61ced0
                }
                // 0x8f61ced0
                v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                g36 = v23;
                g40 = (int32_t)&g23;
                g38 = 0;
                g39 = 0;
                g41 = (int32_t)&g23;
                v27 = *(int32_t *)((int32_t)&g23 + 4);
                g37 = v27;
                if (v27 != 0) {
                    while (true) {
                        // 0x8f61cef4
                        g33 = -0x709e3108;
                        ((int32_t (*)())v27)();
                        if (g34 == 0) {
                            goto lab_0x8f61cf24_17;
                        }
                        // 0x8f61cef4
                        // branch -> 0x8f61cf00
                    }
                }
                // 0x8f61cf00
                v33 = (int32_t)&g23;
                g40 = v33;
                g34 = 0;
                g42 = (int32_t)&g23;
                v28 = *(int32_t *)(v33 + 8);
                g37 = v28;
                g33 = -0x709e30ec;
                ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                v29 = *(int32_t *)(g40 + 12);
                if (v29 != 0) {
                    // 0x8f61cf2c
                    v35 = *(int32_t *)(16 * g38 + g42);
                    g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                    print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v30 = *(int32_t *)(g40 + 12);
                    g36 = v30;
                    if (v30 == (int32_t)&g4) {
                        // 0x8f61cf4c
                        g35 = 64;
                        g36 = (int32_t)"Fall-through from %s boot mode";
                        v36 = *(int32_t *)(16 * g38 + g42);
                        snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                        fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                        // branch -> 0x8f61cf68
                    }
                    // 0x8f61cf68
                    v34 = g41 + g39;
                    g39 = v34;
                    g34 = 0;
                    v31 = *(int32_t *)(v34 + 12);
                    g37 = v31;
                    g33 = -0x709e3088;
                    ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                    // branch -> 0x8f61cf78
                }
                // 0x8f61cf78
                if (v2 != g30) {
                    // 0x8f61cf88
                    __stack_chk_fail();
                    // branch -> 0x8f61cf8c
                }
                // 0x8f61cf8c
                return (char *)g34;
            }
        }
        // 0x8f61ce68
        print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        // branch -> 0x8f61ce88
        // 0x8f61ce88
        v24 = (int32_t)&g29;
        target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        g35 = (int32_t)"Serial number: \"%s\"\n";
        v25 = v24;
        v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        *(int32_t *)(v19 + 16) = v24;
        g32 = v19;
        v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
        g34 = v20;
        v7 = NULL;
        if (v20 != 0) {
            // 0x8f61cec4
            sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
            v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v21;
            v7 = (char *)v21;
            // branch -> 0x8f61ced0
        }
        // 0x8f61ced0
        v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
        g36 = v23;
        g40 = (int32_t)&g23;
        g38 = 0;
        g39 = 0;
        g41 = (int32_t)&g23;
        v27 = *(int32_t *)((int32_t)&g23 + 4);
        g37 = v27;
        if (v27 != 0) {
            while (true) {
                // 0x8f61cef4
                g33 = -0x709e3108;
                ((int32_t (*)())v27)();
                if (g34 == 0) {
                    goto lab_0x8f61cf24_17;
                }
                // 0x8f61cef4
                // branch -> 0x8f61cf00
            }
        }
        // 0x8f61cf00
        v33 = (int32_t)&g23;
        g40 = v33;
        g34 = 0;
        g42 = (int32_t)&g23;
        v28 = *(int32_t *)(v33 + 8);
        g37 = v28;
        g33 = -0x709e30ec;
        ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
        v29 = *(int32_t *)(g40 + 12);
        if (v29 != 0) {
            // 0x8f61cf2c
            v35 = *(int32_t *)(16 * g38 + g42);
            g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
            print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v30 = *(int32_t *)(g40 + 12);
            g36 = v30;
            if (v30 == (int32_t)&g4) {
                // 0x8f61cf4c
                g35 = 64;
                g36 = (int32_t)"Fall-through from %s boot mode";
                v36 = *(int32_t *)(16 * g38 + g42);
                snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                // branch -> 0x8f61cf68
            }
            // 0x8f61cf68
            v34 = g41 + g39;
            g39 = v34;
            g34 = 0;
            v31 = *(int32_t *)(v34 + 12);
            g37 = v31;
            g33 = -0x709e3088;
            ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
            // branch -> 0x8f61cf78
        }
        // 0x8f61cf78
        if (v2 != g30) {
            // 0x8f61cf88
            __stack_chk_fail();
            // branch -> 0x8f61cf8c
        }
        // 0x8f61cf8c
        return (char *)g34;
    }
    // 0x8f61cd90
    if (__utag_gets_constprop_4_4("loglevel.ui", v5, 11) != 0) {
        // 0x8f61cda8
        v11 = get_log_level_by_desc((char *)2, v5, 11, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v11 != -10) {
            // 0x8f61cdc0
            set_logger_level((char *)2, 0x1000000 * v11 / 0x1000000, 11, g37);
            // branch -> 0x8f61cdcc
        }
        // 0x8f61cdcc
        if (__utag_gets_constprop_4_4("loglevel.ram", v5, 11) != 0) {
            // 0x8f61cde4
            v12 = get_log_level_by_desc((char *)1, v5, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
            if (v12 != -10) {
                // 0x8f61cdfc
                g36 = set_logger_level((char *)1, 0x1000000 * v12 / 0x1000000, g36, g37);
                // branch -> 0x8f61ce08
            }
        }
        // 0x8f61ce08
        v22 = (int32_t)"disable-reset";
        v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v13 == 1) {
            // 0x8f61ce20
            v22 = (int32_t)"disable-reset";
            v9 = &v6;
            g36 = v9;
            __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            // branch -> 0x8f61ce30
        }
        // 0x8f61ce30
        v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
        v32 = 0x1000000 * v6 / 0x1000000;
        *(char *)&g31 = (char)v32;
        v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
        switch (v15) {
            case -2: {
                // 0x8f61ce50
                v22 = (int32_t)"Invalid sp partition - resetting...\n";
                v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                if (v17 == 0) {
                    // 0x8f61ce78
                    sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                    // branch -> 0x8f61ce88
                    // 0x8f61ce88
                    v24 = (int32_t)&g29;
                    target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    g35 = (int32_t)"Serial number: \"%s\"\n";
                    v25 = v24;
                    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    *(int32_t *)(v19 + 16) = v24;
                    g32 = v19;
                    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v20;
                    v7 = NULL;
                    if (v20 != 0) {
                        // 0x8f61cec4
                        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v21;
                        v7 = (char *)v21;
                        // branch -> 0x8f61ced0
                    }
                    // 0x8f61ced0
                    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                    g36 = v23;
                    g40 = (int32_t)&g23;
                    g38 = 0;
                    g39 = 0;
                    g41 = (int32_t)&g23;
                    v27 = *(int32_t *)((int32_t)&g23 + 4);
                    g37 = v27;
                    if (v27 != 0) {
                        while (true) {
                            // 0x8f61cef4
                            g33 = -0x709e3108;
                            ((int32_t (*)())v27)();
                            if (g34 == 0) {
                                goto lab_0x8f61cf24_17;
                            }
                            // 0x8f61cef4
                            // branch -> 0x8f61cf00
                        }
                    }
                    // 0x8f61cf00
                    v33 = (int32_t)&g23;
                    g40 = v33;
                    g34 = 0;
                    g42 = (int32_t)&g23;
                    v28 = *(int32_t *)(v33 + 8);
                    g37 = v28;
                    g33 = -0x709e30ec;
                    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                    v29 = *(int32_t *)(g40 + 12);
                    if (v29 != 0) {
                        // 0x8f61cf2c
                        v35 = *(int32_t *)(16 * g38 + g42);
                        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v30 = *(int32_t *)(g40 + 12);
                        g36 = v30;
                        if (v30 == (int32_t)&g4) {
                            // 0x8f61cf4c
                            g35 = 64;
                            g36 = (int32_t)"Fall-through from %s boot mode";
                            v36 = *(int32_t *)(16 * g38 + g42);
                            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                            // branch -> 0x8f61cf68
                        }
                        // 0x8f61cf68
                        v34 = g41 + g39;
                        g39 = v34;
                        g34 = 0;
                        v31 = *(int32_t *)(v34 + 12);
                        g37 = v31;
                        g33 = -0x709e3088;
                        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                        // branch -> 0x8f61cf78
                    }
                    // 0x8f61cf78
                    if (v2 != g30) {
                        // 0x8f61cf88
                        __stack_chk_fail();
                        // branch -> 0x8f61cf8c
                    }
                    // 0x8f61cf8c
                    return (char *)g34;
                }
                break;
            }
            case 0: {
                // 0x8f61ce88
                v24 = (int32_t)&g29;
                target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                g35 = (int32_t)"Serial number: \"%s\"\n";
                v25 = v24;
                v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                *(int32_t *)(v19 + 16) = v24;
                g32 = v19;
                v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v20;
                v7 = NULL;
                if (v20 != 0) {
                    // 0x8f61cec4
                    sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                    v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v21;
                    v7 = (char *)v21;
                    // branch -> 0x8f61ced0
                }
                // 0x8f61ced0
                v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                g36 = v23;
                g40 = (int32_t)&g23;
                g38 = 0;
                g39 = 0;
                g41 = (int32_t)&g23;
                v27 = *(int32_t *)((int32_t)&g23 + 4);
                g37 = v27;
                if (v27 != 0) {
                    while (true) {
                        // 0x8f61cef4
                        g33 = -0x709e3108;
                        ((int32_t (*)())v27)();
                        if (g34 == 0) {
                            goto lab_0x8f61cf24_17;
                        }
                        // 0x8f61cef4
                        // branch -> 0x8f61cf00
                    }
                }
                // 0x8f61cf00
                v33 = (int32_t)&g23;
                g40 = v33;
                g34 = 0;
                g42 = (int32_t)&g23;
                v28 = *(int32_t *)(v33 + 8);
                g37 = v28;
                g33 = -0x709e30ec;
                ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                v29 = *(int32_t *)(g40 + 12);
                if (v29 != 0) {
                    // 0x8f61cf2c
                    v35 = *(int32_t *)(16 * g38 + g42);
                    g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                    print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v30 = *(int32_t *)(g40 + 12);
                    g36 = v30;
                    if (v30 == (int32_t)&g4) {
                        // 0x8f61cf4c
                        g35 = 64;
                        g36 = (int32_t)"Fall-through from %s boot mode";
                        v36 = *(int32_t *)(16 * g38 + g42);
                        snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                        fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                        // branch -> 0x8f61cf68
                    }
                    // 0x8f61cf68
                    v34 = g41 + g39;
                    g39 = v34;
                    g34 = 0;
                    v31 = *(int32_t *)(v34 + 12);
                    g37 = v31;
                    g33 = -0x709e3088;
                    ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                    // branch -> 0x8f61cf78
                }
                // 0x8f61cf78
                if (v2 != g30) {
                    // 0x8f61cf88
                    __stack_chk_fail();
                    // branch -> 0x8f61cf8c
                }
                // 0x8f61cf8c
                return (char *)g34;
            }
        }
        // 0x8f61ce68
        print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        // branch -> 0x8f61ce88
        // 0x8f61ce88
        v24 = (int32_t)&g29;
        target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        g35 = (int32_t)"Serial number: \"%s\"\n";
        v25 = v24;
        v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        *(int32_t *)(v19 + 16) = v24;
        g32 = v19;
        v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
        g34 = v20;
        v7 = NULL;
        if (v20 != 0) {
            // 0x8f61cec4
            sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
            v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v21;
            v7 = (char *)v21;
            // branch -> 0x8f61ced0
        }
        // 0x8f61ced0
        v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
        g36 = v23;
        g40 = (int32_t)&g23;
        g38 = 0;
        g39 = 0;
        g41 = (int32_t)&g23;
        v27 = *(int32_t *)((int32_t)&g23 + 4);
        g37 = v27;
        if (v27 != 0) {
            while (true) {
                // 0x8f61cef4
                g33 = -0x709e3108;
                ((int32_t (*)())v27)();
                if (g34 == 0) {
                    goto lab_0x8f61cf24_17;
                }
                // 0x8f61cef4
                // branch -> 0x8f61cf00
            }
        }
        // 0x8f61cf00
        v33 = (int32_t)&g23;
        g40 = v33;
        g34 = 0;
        g42 = (int32_t)&g23;
        v28 = *(int32_t *)(v33 + 8);
        g37 = v28;
        g33 = -0x709e30ec;
        ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
        v29 = *(int32_t *)(g40 + 12);
        if (v29 != 0) {
            // 0x8f61cf2c
            v35 = *(int32_t *)(16 * g38 + g42);
            g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
            print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v30 = *(int32_t *)(g40 + 12);
            g36 = v30;
            if (v30 == (int32_t)&g4) {
                // 0x8f61cf4c
                g35 = 64;
                g36 = (int32_t)"Fall-through from %s boot mode";
                v36 = *(int32_t *)(16 * g38 + g42);
                snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                // branch -> 0x8f61cf68
            }
            // 0x8f61cf68
            v34 = g41 + g39;
            g39 = v34;
            g34 = 0;
            v31 = *(int32_t *)(v34 + 12);
            g37 = v31;
            g33 = -0x709e3088;
            ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
            // branch -> 0x8f61cf78
        }
        // 0x8f61cf78
        if (v2 != g30) {
            // 0x8f61cf88
            __stack_chk_fail();
            // branch -> 0x8f61cf8c
        }
        // 0x8f61cf8c
        return (char *)g34;
    }
    // 0x8f61cdcc
    if (__utag_gets_constprop_4_4("loglevel.ram", v5, 11) == 0) {
        // 0x8f61ce08
        v22 = (int32_t)"disable-reset";
        v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
        if (v13 == 1) {
            // 0x8f61ce20
            v22 = (int32_t)"disable-reset";
            v9 = &v6;
            g36 = v9;
            __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            // branch -> 0x8f61ce30
        }
        // 0x8f61ce30
        v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
        v32 = 0x1000000 * v6 / 0x1000000;
        *(char *)&g31 = (char)v32;
        v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
        switch (v15) {
            case -2: {
                // 0x8f61ce50
                v22 = (int32_t)"Invalid sp partition - resetting...\n";
                v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                if (v17 == 0) {
                    // 0x8f61ce78
                    sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                    // branch -> 0x8f61ce88
                    // 0x8f61ce88
                    v24 = (int32_t)&g29;
                    target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    g35 = (int32_t)"Serial number: \"%s\"\n";
                    v25 = v24;
                    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                    *(int32_t *)(v19 + 16) = v24;
                    g32 = v19;
                    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v20;
                    v7 = NULL;
                    if (v20 != 0) {
                        // 0x8f61cec4
                        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                        g34 = v21;
                        v7 = (char *)v21;
                        // branch -> 0x8f61ced0
                    }
                    // 0x8f61ced0
                    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                    g36 = v23;
                    g40 = (int32_t)&g23;
                    g38 = 0;
                    g39 = 0;
                    g41 = (int32_t)&g23;
                    v27 = *(int32_t *)((int32_t)&g23 + 4);
                    g37 = v27;
                    if (v27 != 0) {
                        while (true) {
                            // 0x8f61cef4
                            g33 = -0x709e3108;
                            ((int32_t (*)())v27)();
                            if (g34 == 0) {
                                goto lab_0x8f61cf24_17;
                            }
                            // 0x8f61cef4
                            // branch -> 0x8f61cf00
                        }
                    }
                    // 0x8f61cf00
                    v33 = (int32_t)&g23;
                    g40 = v33;
                    g34 = 0;
                    g42 = (int32_t)&g23;
                    v28 = *(int32_t *)(v33 + 8);
                    g37 = v28;
                    g33 = -0x709e30ec;
                    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                    v29 = *(int32_t *)(g40 + 12);
                    if (v29 != 0) {
                        // 0x8f61cf2c
                        v35 = *(int32_t *)(16 * g38 + g42);
                        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                        v30 = *(int32_t *)(g40 + 12);
                        g36 = v30;
                        if (v30 == (int32_t)&g4) {
                            // 0x8f61cf4c
                            g35 = 64;
                            g36 = (int32_t)"Fall-through from %s boot mode";
                            v36 = *(int32_t *)(16 * g38 + g42);
                            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                            // branch -> 0x8f61cf68
                        }
                        // 0x8f61cf68
                        v34 = g41 + g39;
                        g39 = v34;
                        g34 = 0;
                        v31 = *(int32_t *)(v34 + 12);
                        g37 = v31;
                        g33 = -0x709e3088;
                        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                        // branch -> 0x8f61cf78
                    }
                    // 0x8f61cf78
                    if (v2 != g30) {
                        // 0x8f61cf88
                        __stack_chk_fail();
                        // branch -> 0x8f61cf8c
                    }
                    // 0x8f61cf8c
                    return (char *)g34;
                }
                break;
            }
            case 0: {
                // 0x8f61ce88
                v24 = (int32_t)&g29;
                target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                g35 = (int32_t)"Serial number: \"%s\"\n";
                v25 = v24;
                v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                *(int32_t *)(v19 + 16) = v24;
                g32 = v19;
                v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v20;
                v7 = NULL;
                if (v20 != 0) {
                    // 0x8f61cec4
                    sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                    v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v21;
                    v7 = (char *)v21;
                    // branch -> 0x8f61ced0
                }
                // 0x8f61ced0
                v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                g36 = v23;
                g40 = (int32_t)&g23;
                g38 = 0;
                g39 = 0;
                g41 = (int32_t)&g23;
                v27 = *(int32_t *)((int32_t)&g23 + 4);
                g37 = v27;
                if (v27 != 0) {
                    while (true) {
                        // 0x8f61cef4
                        g33 = -0x709e3108;
                        ((int32_t (*)())v27)();
                        if (g34 == 0) {
                            goto lab_0x8f61cf24_17;
                        }
                        // 0x8f61cef4
                        // branch -> 0x8f61cf00
                    }
                }
                // 0x8f61cf00
                v33 = (int32_t)&g23;
                g40 = v33;
                g34 = 0;
                g42 = (int32_t)&g23;
                v28 = *(int32_t *)(v33 + 8);
                g37 = v28;
                g33 = -0x709e30ec;
                ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                v29 = *(int32_t *)(g40 + 12);
                if (v29 != 0) {
                    // 0x8f61cf2c
                    v35 = *(int32_t *)(16 * g38 + g42);
                    g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                    print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v30 = *(int32_t *)(g40 + 12);
                    g36 = v30;
                    if (v30 == (int32_t)&g4) {
                        // 0x8f61cf4c
                        g35 = 64;
                        g36 = (int32_t)"Fall-through from %s boot mode";
                        v36 = *(int32_t *)(16 * g38 + g42);
                        snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                        fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                        // branch -> 0x8f61cf68
                    }
                    // 0x8f61cf68
                    v34 = g41 + g39;
                    g39 = v34;
                    g34 = 0;
                    v31 = *(int32_t *)(v34 + 12);
                    g37 = v31;
                    g33 = -0x709e3088;
                    ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                    // branch -> 0x8f61cf78
                }
                // 0x8f61cf78
                if (v2 != g30) {
                    // 0x8f61cf88
                    __stack_chk_fail();
                    // branch -> 0x8f61cf8c
                }
                // 0x8f61cf8c
                return (char *)g34;
            }
        }
        // 0x8f61ce68
        print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        // branch -> 0x8f61ce88
        // 0x8f61ce88
        v24 = (int32_t)&g29;
        target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        g35 = (int32_t)"Serial number: \"%s\"\n";
        v25 = v24;
        v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
        *(int32_t *)(v19 + 16) = v24;
        g32 = v19;
        v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
        g34 = v20;
        v7 = NULL;
        if (v20 != 0) {
            // 0x8f61cec4
            sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
            v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v21;
            v7 = (char *)v21;
            // branch -> 0x8f61ced0
        }
        // 0x8f61ced0
        v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
        g36 = v23;
        g40 = (int32_t)&g23;
        g38 = 0;
        g39 = 0;
        g41 = (int32_t)&g23;
        v27 = *(int32_t *)((int32_t)&g23 + 4);
        g37 = v27;
        v26 = 0;
        if (v27 != 0) {
            while (true) {
                // 0x8f61cef4
                g33 = -0x709e3108;
                ((int32_t (*)())v27)();
                if (g34 == 0) {
                    goto lab_0x8f61cf24_17;
                }
                // 0x8f61cef4
                // branch -> 0x8f61cf00
            }
        }
      lab_0x8f61cf00:
        // 0x8f61cf00
        v33 = v26 + (int32_t)&g23;
        g40 = v33;
        g34 = 0;
        g42 = (int32_t)&g23;
        v28 = *(int32_t *)(v33 + 8);
        g37 = v28;
        g33 = -0x709e30ec;
        ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
        v29 = *(int32_t *)(g40 + 12);
        if (v29 != 0) {
            // 0x8f61cf2c
            v35 = *(int32_t *)(16 * g38 + g42);
            g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
            print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v30 = *(int32_t *)(g40 + 12);
            g36 = v30;
            if (v30 == (int32_t)&g4) {
                // 0x8f61cf4c
                g35 = 64;
                g36 = (int32_t)"Fall-through from %s boot mode";
                v36 = *(int32_t *)(16 * g38 + g42);
                snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                // branch -> 0x8f61cf68
            }
            // 0x8f61cf68
            v34 = g41 + g39;
            g39 = v34;
            g34 = 0;
            v31 = *(int32_t *)(v34 + 12);
            g37 = v31;
            g33 = -0x709e3088;
            ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
            // branch -> 0x8f61cf78
        }
        // 0x8f61cf78
        if (v2 != g30) {
            // 0x8f61cf88
            __stack_chk_fail();
            // branch -> 0x8f61cf8c
        }
        // 0x8f61cf8c
        return (char *)g34;
    }
    // 0x8f61cde4
    v12 = get_log_level_by_desc((char *)1, v5, g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
    if (v12 != -10) {
        // 0x8f61cdfc
        g36 = set_logger_level((char *)1, 0x1000000 * v12 / 0x1000000, g36, g37);
        // branch -> 0x8f61ce08
    }
    // 0x8f61ce08
    v22 = (int32_t)"disable-reset";
    v13 = __utag_sizeof(NULL, (int32_t)"disable-reset", g36, g37, (int32_t)"3220316", 0, 0, v4, 0);
    if (v13 == 1) {
        // 0x8f61ce20
        v22 = (int32_t)"disable-reset";
        v9 = &v6;
        g36 = v9;
        __utag_read(NULL, (int32_t)"disable-reset", v9, 1, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        // branch -> 0x8f61ce30
    }
    // 0x8f61ce30
    v14 = target_disable_resets((char *)(0x1000000 * v6 / 0x1000000), v22, g36, v13, (int32_t)"3220316", 0, 0);
    v32 = 0x1000000 * v6 / 0x1000000;
    *(char *)&g31 = (char)v32;
    v15 = sp_init(v14, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
    switch (v15) {
        case -2: {
            // 0x8f61ce50
            v22 = (int32_t)"Invalid sp partition - resetting...\n";
            v16 = print_log(0, (int32_t)"Invalid sp partition - resetting...\n", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v17 = init_sp_partition((char *)v16, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
            if (v17 == 0) {
                // 0x8f61ce78
                sp_init(0, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0);
                // branch -> 0x8f61ce88
                // 0x8f61ce88
                v24 = (int32_t)&g29;
                target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                g35 = (int32_t)"Serial number: \"%s\"\n";
                v25 = v24;
                v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
                *(int32_t *)(v19 + 16) = v24;
                g32 = v19;
                v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v20;
                v7 = NULL;
                if (v20 != 0) {
                    // 0x8f61cec4
                    sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                    v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                    g34 = v21;
                    v7 = (char *)v21;
                    // branch -> 0x8f61ced0
                }
                // 0x8f61ced0
                v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
                g36 = v23;
                g40 = (int32_t)&g23;
                g38 = 0;
                g39 = 0;
                g41 = (int32_t)&g23;
                v27 = *(int32_t *)((int32_t)&g23 + 4);
                g37 = v27;
                if (v27 != 0) {
                    while (true) {
                        // 0x8f61cef4
                        g33 = -0x709e3108;
                        ((int32_t (*)())v27)();
                        if (g34 == 0) {
                            goto lab_0x8f61cf24_17;
                        }
                        // 0x8f61cef4
                        // branch -> 0x8f61cf00
                    }
                }
                // 0x8f61cf00
                v33 = (int32_t)&g23;
                g40 = v33;
                g34 = 0;
                g42 = (int32_t)&g23;
                v28 = *(int32_t *)(v33 + 8);
                g37 = v28;
                g33 = -0x709e30ec;
                ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
                v29 = *(int32_t *)(g40 + 12);
                if (v29 != 0) {
                    // 0x8f61cf2c
                    v35 = *(int32_t *)(16 * g38 + g42);
                    g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                    print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                    v30 = *(int32_t *)(g40 + 12);
                    g36 = v30;
                    if (v30 == (int32_t)&g4) {
                        // 0x8f61cf4c
                        g35 = 64;
                        g36 = (int32_t)"Fall-through from %s boot mode";
                        v36 = *(int32_t *)(16 * g38 + g42);
                        snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                        fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                        // branch -> 0x8f61cf68
                    }
                    // 0x8f61cf68
                    v34 = g41 + g39;
                    g39 = v34;
                    g34 = 0;
                    v31 = *(int32_t *)(v34 + 12);
                    g37 = v31;
                    g33 = -0x709e3088;
                    ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                    // branch -> 0x8f61cf78
                }
                // 0x8f61cf78
                if (v2 != g30) {
                    // 0x8f61cf88
                    __stack_chk_fail();
                    // branch -> 0x8f61cf8c
                }
                // 0x8f61cf8c
                return (char *)g34;
            }
            break;
        }
        case 0: {
            // 0x8f61ce88
            v24 = (int32_t)&g29;
            target_serialno((char *)&g29, v22, v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
            g35 = (int32_t)"Serial number: \"%s\"\n";
            v25 = v24;
            v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
            v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
            *(int32_t *)(v19 + 16) = v24;
            g32 = v19;
            v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
            g34 = v20;
            v7 = NULL;
            if (v20 != 0) {
                // 0x8f61cec4
                sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
                v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
                g34 = v21;
                v7 = (char *)v21;
                // branch -> 0x8f61ced0
            }
            // 0x8f61ced0
            v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
            g36 = v23;
            g40 = (int32_t)&g23;
            g38 = 0;
            g39 = 0;
            g41 = (int32_t)&g23;
            v27 = *(int32_t *)((int32_t)&g23 + 4);
            g37 = v27;
            if (v27 != 0) {
                while (true) {
                    // 0x8f61cef4
                    g33 = -0x709e3108;
                    ((int32_t (*)())v27)();
                    if (g34 == 0) {
                        goto lab_0x8f61cf24_17;
                    }
                    // 0x8f61cef4
                    // branch -> 0x8f61cf00
                }
            }
            // 0x8f61cf00
            v33 = (int32_t)&g23;
            g40 = v33;
            g34 = 0;
            g42 = (int32_t)&g23;
            v28 = *(int32_t *)(v33 + 8);
            g37 = v28;
            g33 = -0x709e30ec;
            ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
            v29 = *(int32_t *)(g40 + 12);
            if (v29 != 0) {
                // 0x8f61cf2c
                v35 = *(int32_t *)(16 * g38 + g42);
                g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
                print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
                v30 = *(int32_t *)(g40 + 12);
                g36 = v30;
                if (v30 == (int32_t)&g4) {
                    // 0x8f61cf4c
                    g35 = 64;
                    g36 = (int32_t)"Fall-through from %s boot mode";
                    v36 = *(int32_t *)(16 * g38 + g42);
                    snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
                    fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
                    // branch -> 0x8f61cf68
                }
                // 0x8f61cf68
                v34 = g41 + g39;
                g39 = v34;
                g34 = 0;
                v31 = *(int32_t *)(v34 + 12);
                g37 = v31;
                g33 = -0x709e3088;
                ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
                // branch -> 0x8f61cf78
            }
            // 0x8f61cf78
            if (v2 != g30) {
                // 0x8f61cf88
                __stack_chk_fail();
                // branch -> 0x8f61cf8c
            }
            // 0x8f61cf8c
            return (char *)g34;
        }
    }
    // 0x8f61ce68
    print_log(0, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
    // branch -> 0x8f61ce88
    // 0x8f61ce88
    v24 = (int32_t)&g29;
    target_serialno((char *)&g29, (int32_t)"Failed to initialize SP partition", v32, (int32_t)&g31, (int32_t)"3220316", 0, 0);
    g35 = (int32_t)"Serial number: \"%s\"\n";
    v25 = v24;
    v18 = print_log(1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
    v19 = get_udc_device((char *)v18, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g31, (int32_t)"3220316", 0, 0);
    *(int32_t *)(v19 + 16) = v24;
    g32 = v19;
    v20 = misc_check_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
    g34 = v20;
    v7 = NULL;
    if (v20 != 0) {
        // 0x8f61cec4
        sync_up_backup_partitions(v20, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0, v4, 0, 0, v1);
        v21 = misc_clear_mode((char *)1, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32, (int32_t)"3220316", 0, 0);
        g34 = v21;
        v7 = (char *)v21;
        // branch -> 0x8f61ced0
    }
    // 0x8f61ced0
    v23 = poweroff_handler_start(v7, (int32_t)"Serial number: \"%s\"\n", v25, (int32_t)&g32);
    g36 = v23;
    g40 = (int32_t)&g23;
    g38 = 0;
    g39 = 0;
    g41 = (int32_t)&g23;
    v27 = *(int32_t *)((int32_t)&g23 + 4);
    g37 = v27;
    if (v27 != 0) {
        while (true) {
            // 0x8f61cef4
            g33 = -0x709e3108;
            ((int32_t (*)())v27)();
            if (g34 == 0) {
                goto lab_0x8f61cf24_17;
            }
            // 0x8f61cef4
            // branch -> 0x8f61cf00
        }
    }
    // 0x8f61cf00
    v33 = (int32_t)&g23;
    g40 = v33;
    g34 = 0;
    g42 = (int32_t)&g23;
    v28 = *(int32_t *)(v33 + 8);
    g37 = v28;
    g33 = -0x709e30ec;
    ((int32_t (*)(int32_t, int32_t))v28)(0, v28);
    v29 = *(int32_t *)(g40 + 12);
    if (v29 != 0) {
        // 0x8f61cf2c
        v35 = *(int32_t *)(16 * g38 + g42);
        g35 = (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n";
        print_log(1, (int32_t)"Entering %s mode fails, falling into its fail-safe mode.\n", v35, v29, (int32_t)"3220316", 0, 0, v4, 0, 0, v1, v3, 0);
        v30 = *(int32_t *)(g40 + 12);
        g36 = v30;
        if (v30 == (int32_t)&g4) {
            // 0x8f61cf4c
            g35 = 64;
            g36 = (int32_t)"Fall-through from %s boot mode";
            v36 = *(int32_t *)(16 * g38 + g42);
            snprintf((char *)&str, 64, "Fall-through from %s boot mode", (char *)v36);
            fastboot_set_reason((char *)&str, 64, (int32_t)"Fall-through from %s boot mode", v36);
            // branch -> 0x8f61cf68
        }
        // 0x8f61cf68
        v34 = g41 + g39;
        g39 = v34;
        g34 = 0;
        v31 = *(int32_t *)(v34 + 12);
        g37 = v31;
        g33 = -0x709e3088;
        ((int32_t (*)(int32_t, int32_t))v31)(0, v31);
        // branch -> 0x8f61cf78
    }
    // 0x8f61cf78
    if (v2 != g30) {
        // 0x8f61cf88
        __stack_chk_fail();
        // branch -> 0x8f61cf8c
    }
    // 0x8f61cf8c
    return (char *)g34;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// size_t strnlen(const char * string, size_t maxlen);
// char * strrchr(char * s, int c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 18
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:36:16
