//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t free_context(int32_t a1, int32_t a2, int32_t a3);
void function_8f660c54(int32_t * a1, char * a2, int32_t a3, int32_t * a4);
int32_t lbackref(int32_t * a1, char * a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t ldissect(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t lslow(int32_t * a1, char * a2, int32_t a3, int32_t a4);
int32_t mcs_ctx_init_rsa_sig(char a1, char a2, char a3, int32_t a4, uint32_t a5);
int32_t mcs_free_name(char * a1, int32_t a2);
int32_t mcs_rsa_add_cipher_pad_isra_1(int32_t a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8);
int32_t mcs_rsa_do_rsa(char * a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t mcs_rsa_mgf_isra_0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_rsa_remove_cipher_pad_isra_3(char * a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mcs_verify_cert_chain(int32_t a1, int16_t * a2);
int32_t mcs_X509Certificate_decodeExtension(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_X509Certificate_decodeName(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t read_parser_data(int32_t a1);
int32_t read_verify_data(int32_t a1);
int32_t sbackref(int32_t * a1, char * a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t sdissect(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t sslow(int32_t * a1, char * a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g6 = 0; // LR
int32_t g7 = 0; // R1
int32_t g8 = 0; // R10
int32_t g9 = 0; // R11
int32_t g10 = 0; // R2
int32_t g11 = 0; // R3
int32_t g12 = 0; // R4
int32_t g13 = 0; // R5
int32_t g14 = 0; // R6
int32_t g15 = 0; // R7
int32_t g16 = 0; // R8
int32_t g17 = 0; // R9
int32_t g1 = -0x79b779d6; // 0x8f6a69c9
int32_t g2 = 0x2b0b0455; // 0x8f6a69d2
int32_t g3 = 0x20494b50; // 0x8f6a69dd
int32_t g4 = 0x67251d55; // 0x8f6a69e7
int32_t g5 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f668694 - 0x8f66877b
int32_t mcs_ctx_init_rsa_sig(char a1, char a2, char a3, int32_t a4, uint32_t a5) {
    int32_t v1 = a1;
    int32_t v2 = a2;
    g7 = v2;
    int32_t v3 = g12; // 0x8f668694
    int32_t v4 = g13; // 0x8f668694
    int32_t v5 = g8; // 0x8f668694
    int32_t v6 = g5;
    g8 = &g5;
    int32_t v7;
    g12 = v7;
    uint32_t v8 = a4 - 512; // 0x8f6686c0
    int32_t v9;
    if (v8 > 1536 || a5 > 256) {
        // 0x8f668758
        // branch -> 0x8f66875c
        // 0x8f66875c
        g10 = v6;
        v9 = g5;
        g11 = v9;
        if (v6 != v9) {
            // 0x8f66876c
            __stack_chk_fail();
            // branch -> 0x8f668770
        }
        // 0x8f668770
        g12 = v3;
        g13 = v4;
        g8 = v5;
        return 1;
    }
    // 0x8f6686d4
    switch (a1) {
        case 1: {
            // after_if_8f6686d8_0
        }
        case 0: {
            // 0x8f6686e8
            if (v7 != 0) {
                // 0x8f6686f0
                mcs_memclear(v7, v2 & -0x10000 | 1304, v8, (int32_t)&g5);
                int32_t v10 = g12 + 932; // 0x8f668700
                g7 = v10;
                int32_t result = mcs_ctx_init_hash(0x1000000 * v2 / 0x1000000, v10, v8, (int32_t)&g5, v1, v6, v3, v4); // 0x8f668704
                if (v1 != 0) {
                    // 0x8f668710
                    if (result != 0) {
                        // 0x8f66875c
                        g10 = v6;
                        v9 = g5;
                        g11 = v9;
                        if (v6 != v9) {
                            // 0x8f66876c
                            __stack_chk_fail();
                            // branch -> 0x8f668770
                        }
                        // 0x8f668770
                        g12 = v3;
                        g13 = v4;
                        g8 = v5;
                        return result;
                    }
                }
                // 0x8f668718
                *(char *)g12 = 8;
                int32_t result2 = 0; // R0
                *(char *)(g12 + 8) = (char)v1;
                *(char *)(g12 + 9) = (char)v2;
                *(char *)(g12 + 10) = (char)(int32_t)a3;
                *(int32_t *)(g12 + 4) = (a4 + 7) / 8;
                *(int32_t *)(g12 + 12) = a4;
                *(char *)(g12 + 660) = (char)result2;
                *(char *)(g12 + 16) = (char)result2;
                *(int32_t *)(g12 + 1300) = result2;
                *(char *)(g12 + 928) = (char)result2;
                *(int32_t *)(g12 + 1296) = a5;
                // branch -> 0x8f66875c
                // 0x8f66875c
                g10 = v6;
                v9 = g5;
                g11 = v9;
                if (v6 != v9) {
                    // 0x8f66876c
                    __stack_chk_fail();
                    // branch -> 0x8f668770
                }
                // 0x8f668770
                g12 = v3;
                g13 = v4;
                g8 = v5;
                return result2;
            }
            break;
        }
    }
    // 0x8f668758
    // branch -> 0x8f66875c
    // 0x8f66875c
    g10 = v6;
    v9 = g5;
    g11 = v9;
    if (v6 != v9) {
        // 0x8f66876c
        __stack_chk_fail();
        // branch -> 0x8f668770
    }
    // 0x8f668770
    g12 = v3;
    g13 = v4;
    g8 = v5;
    return 1;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// int isalnum(int c);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 19
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:51:38
