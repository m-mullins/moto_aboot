//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t check_wififlash_mode(char * a1, int32_t a2);
int32_t dbval_finalise_cid_datablock(int32_t a1, int32_t a2, int32_t a3);
int32_t endpoint_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t gcc_dsi_clocks_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t gcc_dsi_clocks_enable(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t get_current_boot_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t get_date_buf(int32_t a1, int32_t a2, int32_t a3);
int32_t get_font_type(int32_t a1, int32_t a2);
int32_t init_barcodes(int32_t a1, int32_t a2, int32_t a3);
int32_t is_bootloader_partition(char * str, int32_t a2, int32_t a3);
int32_t is_menu_auto_scroll(int32_t a1);
int32_t mcs_X509Certificate_initialize(int16_t * a1, int32_t a2);
int32_t mdss_dsi_auto_pll_config(int32_t * a1, int32_t a2);
int32_t mdss_dsi_wait4_video_done(int32_t a1);
int32_t mdss_dual_dsi_cmds_tx(int32_t a1, int32_t a2);
int32_t mipi_mot_get_controller_ver(void);
int32_t mipi_mot_get_manufacture_id(int32_t * a1, int32_t a2, int32_t a3);
int32_t normal_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t partition_get_offset(uint32_t a1, int32_t a2);
int32_t qup_i2c_interrupt(int32_t a1, int32_t a2, int32_t a3);
int32_t request_warm_reset(char a1, int32_t a2, int32_t a3);
int32_t smem_get_ram_ptable_version(void);
int32_t spmi_enable_periph_interrupts(int32_t a1, int32_t a2, int32_t a3);
int32_t target_baseband(char * a1, int32_t a2, int32_t a3);
int32_t target_display_panel_node(char * a1, int32_t a2, int32_t a3);
int32_t target_ram_size(int32_t a1, int32_t a2);
int32_t target_usb_init(int32_t a1, int32_t a2);
int32_t write_gpt(int32_t a1, int32_t a2);
int32_t write_protect_was_enabled(char * a1, int32_t a2, int32_t a3);
int32_t write_wdata_from_array(int32_t a1, int32_t a2, int32_t a3, char * a4);

// --------------------- Global Variables ---------------------

int32_t g37 = 0; // LR
int32_t g38 = 0; // R1
int32_t g39 = 0; // R2
int32_t g40 = 0; // R4
int32_t g41 = 0; // R5
int32_t g42 = 0; // R6
int32_t g43 = 0; // R7
int32_t g44 = 0; // R8
int32_t g1 = -0x1a60cf8c; // 0x8f612158
int32_t g2 = 0x1c9496e0; // 0x8f67f5a0
int32_t g3 = 0; // 0x8f67f620
int32_t g4 = 8; // 0x8f67f624
int32_t g5 = 0x65440030; // 0x8f69c66f
char * g6[7] = {
    "utags",
    "pds",
    "persist",
    "mdm1hob",
    "sp",
    "cid",
    "hw"
}; // 0x8f6a2b9c
int32_t g7 = -0x79b779d6; // 0x8f6a6a2b
char * g8 = "\n"; // 0x8f6ac1b0
int32_t g9 = -1; // 0x8f6ac210
int32_t g10 = 0xffff; // 0x8f6acae4
int32_t g11 = 0xffff; // 0x8f6acaec
int32_t g12 = 4; // 0x8f6acb74
int32_t g13 = 4; // 0x8f6acb84
char (*g14)[5] = "sbl1"; // 0x8f6affb4
char g15 = 0; // 0x8f6b50b0
char g16 = 0; // 0x8f6b50b1
char g17 = 0; // 0x8f6b50b2
char g18 = 0; // 0x8f6b50b3
int32_t g19 = 0; // 0x8f6b7944
int32_t g20 = 0; // 0x8f6b8b04
int32_t g21 = 0; // 0x8f6c02aa
int32_t g22 = 0; // 0x8f6c02ba
int32_t g23 = 0; // 0x8f6c02ca
char * g24; // 0x8f6c02dd
char * g25; // 0x8f6c02e4
int32_t g26 = 0; // 0x8f6e130c
int32_t g27 = 0; // 0x8f6e1310
char * g28; // 0x8f6e1314
int32_t g29 = 0; // 0x8f6e1318
int32_t g30 = 0; // 0x8f6e1320
int32_t g31 = 0; // 0x8f6e1324
char * g32; // 0x8f6e9404
char * g33; // 0x8f6e9408
char * g34; // 0x8f70f724
int32_t g35 = 0; // 0x8f7112f4
int32_t g36 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f653bc8 - 0x8f654957
int32_t write_gpt(int32_t a1, int32_t a2) {
    int32_t str6 = g42; // bp-28
    int32_t v1 = g35;
    int32_t v2 = a2; // R8
    int32_t v3 = 0x20494645; // R2
    int32_t str2 = 0x20494645; // bp-96
    int32_t v4 = a1; // 0x8f653c60
    if (*(char *)&g28 != 0) {
        int32_t v5 = a1; // 0x8f653c60245
        if (g33 == (char *)&g32) {
            // 0x8f653c10
            v5 = (int32_t)&g32;
            // branch -> 0x8f653c10
        }
        // 0x8f653c10
        *(char *)&g28 = 0;
        v4 = v5;
        // branch -> 0x8f653c4c
    }
    // 0x8f653c4c
    *(int32_t *)&g32 = (int32_t)&g32;
    g33 = (char *)&g32;
    int32_t v6 = get_default_backup_zone(v4, a2, 0x20494645); // 0x8f653c60
    g31 = v6 - 1 + get_default_backup_zone_size(v6, a2, v3);
    *(char *)(int32_t)&g28 = 1;
    int32_t v7;
    int32_t v8;
    int32_t v9;
    notify_user((int32_t)"Flashing primary GPT image...", a2, v3, 1, v9, v8, v7);
    int32_t v10 = a2 + 512; // 0x8f653c90
    char * str = (char *)v10;
    int32_t v11 = v2 + 1024; // 0x8f653c9c
    int32_t memcmp_rc = memcmp(str, (char *)&str2, 8); // 0x8f653ca8
    int32_t v12 = memcmp_rc; // R11
    int32_t v13;
    int32_t v14;
    int32_t v15;
    int32_t v16;
    if (memcmp_rc != 0) {
        // 0x8f653cb4
        print_log(0, (int32_t)"Invalid EFI signature\n", 8, 1, v9, v8, v7, v16, v15, 0, 0, v14, v13);
        // branch -> 0x8f654668
        // 0x8f654668
        // branch -> 0x8f65489c
        // 0x8f65489c
        if (v1 != g35) {
            // 0x8f6548b0
            __stack_chk_fail();
            // branch -> 0x8f6548b4
        }
        // 0x8f6548b4
        return -1;
    }
    int32_t v17 = v2; // 0x8f653cc4
    char v18 = *(char *)(v17 + 593); // 0x8f653cc4
    char v19 = *(char *)(v17 + 592); // 0x8f653cc8
    char v20 = *(char *)(v17 + 594); // 0x8f653cd0
    int32_t v21 = (int32_t)*(char *)(v17 + 595); // 0x8f653cd8
    uint32_t v22 = 0x1000000 * v21 | 0x10000 * (int32_t)v20 | (int32_t)v19 | 256 * (int32_t)v18; // 0x8f653cdc
    if (v22 < 129) {
        // if_8f653ce4_0_true
        int32_t str3;
        int32_t v23 = &str3; // 0x8f653ec8_0
        int32_t v24;
        int32_t v25;
        int32_t v26;
        int32_t v27;
        int32_t v28 = 0x1000000 * v26 / 0x10000 | 0x1000000 * v27 / 0x1000000 | 0x1000000 * v25 / 256 | 0x1000000 * v24; // 0x8f653fcc
        int32_t v29;
        int32_t v30;
        int32_t v31;
        int32_t v32;
        int32_t v33 = 0x1000000 * v31 / 0x10000 | 0x1000000 * v32 / 0x1000000 | 0x1000000 * v30 / 256 | 0x1000000 * v29; // 0x8f653fe8
        int32_t v34;
        int32_t v35;
        int32_t v36;
        int32_t v37 = 0x1000000 * v1 / 0x1000000 | 0x1000000 * v36 / 0x10000 | 0x1000000 * v35 / 256 | 0x1000000 * v34; // 0x8f654048
        int32_t v38;
        int32_t v39;
        int32_t v40;
        int32_t v41;
        int32_t v42 = 0x1000000 * v40 / 0x10000 | 0x1000000 * v41 / 0x1000000 | 0x1000000 * v39 / 256 | 0x1000000 * v38; // 0x8f654064
        int32_t v43 = 0; // 0x8f653d30
        int32_t v44 = v17; // 0x8f653d28
        int32_t v45 = v17 + 1080; // 0x8f653d90
        int32_t v46 = v9; // 0x8f65488055
        int32_t v47 = v15; // 0x8f65487438
        int32_t v48 = v16; // 0x8f65487433
        int32_t v49 = v7; // 0x8f65488028
        int32_t v50 = v8; // 0x8f65488023
        // branch -> 0x8f653d10
        while (true) {
          lab_0x8f653d10_3:;
            int32_t str5 = v45; // R10
            char v51 = *(char *)(v44 + 593); // 0x8f653d10
            char v52 = *(char *)(v44 + 592); // 0x8f653d14
            int32_t v53 = &g36; // R12
            char v54 = *(char *)(v44 + 594); // 0x8f653d20
            char v55 = *(char *)(v44 + 595); // 0x8f653d28
            int32_t v56 = v44; // 0x8f654260
            int32_t v57 = v14;
            int32_t v58; // 0x8f6548744377
            int32_t v59; // 0x8f6548805076
            int32_t v60; // 0x8f6548801981
            int32_t v61; // 0x8f6548802480
            int32_t v62; // 0x8f6548743279
            int32_t v63; // 0x8f6548743778
            int32_t * v64; // 0x8f654694_0
            int32_t v65; // 0x8f6546c0_12
            uint32_t v66; // 0x8f654384
            uint32_t v67; // 0x8f6543c8
            int32_t v68; // 0x8f654400
            uint32_t v69; // 0x8f654548
            uint32_t v70; // 0x8f65458c
            int32_t v71; // 0x8f6545f8
            int32_t v72; // 0x8f654654
            char * v73; // 0x8f6546c0
            int32_t v74; // R0
            int32_t v75; // R1
            int32_t v76; // R3
            int32_t v77; // R4
            int32_t v78; // R5
            int32_t v79; // R6
            int32_t v80; // R7
            int32_t v81; // R9
            int32_t result; // 0x8f6548b8_2
            int32_t v82; // 0x2128
            int32_t v83;
            int32_t v84;
            char * v85;
            char * v86;
            int32_t v87;
            int32_t v88; // 0x8f65427c
            int32_t v89; // 0x8f654458
            int32_t v90; // 0x8f65427c
            int32_t v91; // 0x8f65443c
            int32_t v92; // 0x8f654314
            int32_t v93; // 0x8f65431c
            int32_t v94; // 0x8f654338
            int32_t v95; // 0x8f654348
            int32_t v96; // 0x8f654354
            int32_t v97; // 0x8f654364
            int32_t v98; // 0x8f654388
            int32_t v99; // 0x8f6543a0
            int32_t v100; // 0x8f6543b0
            int32_t v101; // 0x8f6544dc
            int32_t v102; // 0x8f6544ec
            int32_t v103; // 0x8f654508
            int32_t v104; // 0x8f654518
            int32_t v105; // 0x8f654524
            int32_t v106; // 0x8f654534
            int32_t v107; // 0x8f65454c
            int32_t v108; // 0x8f654564
            int32_t v109; // 0x8f654574
            int32_t v110; // 0x8f654590
            int32_t v111; // 0x8f6545ac
            int32_t v112; // 0x8f6545bc
            int32_t v113; // 0x8f6545c8
            int32_t v114; // 0x8f654608
            int32_t v115; // 0x8f6546a4
            int32_t v116; // 0x8f654270
            int32_t v117; // 0x8f654420
            char v118; // 0x8f654314
            char v119; // 0x8f65431c
            char v120; // 0x8f654320
            char v121; // 0x8f654328
            char v122; // 0x8f654338
            char v123; // 0x8f654348
            char v124; // 0x8f654354
            char v125; // 0x8f654364
            char v126; // 0x8f654388
            char v127; // 0x8f6543a0
            char v128; // 0x8f6543b0
            char v129; // 0x8f6543c0
            int32_t v130; // 0x8f6543f8
            char v131; // 0x8f6544dc
            char v132; // 0x8f6544ec
            char v133; // 0x8f6544f0
            char v134; // 0x8f6544f8
            char v135; // 0x8f654508
            char v136; // 0x8f654518
            char v137; // 0x8f654524
            char v138; // 0x8f654534
            char v139; // 0x8f65454c
            char v140; // 0x8f654564
            char v141; // 0x8f654574
            char v142; // 0x8f654584
            char v143; // 0x8f654590
            char v144; // 0x8f654594
            char v145; // 0x8f6545ac
            char v146; // 0x8f6545bc
            char v147; // 0x8f6545c8
            char v148; // 0x8f6545d0
            char v149; // 0x8f6545d8
            char v150; // 0x8f654608
            char v151; // 0x8f65460c
            char v152; // 0x8f654610
            char v153; // 0x8f654618
            char v154; // 0x8f654624
            char v155; // 0x8f65462c
            char v156; // 0x8f654634
            int32_t v157; // 0x8f6546ac
            int32_t v158; // 0x8f6545c4
            int32_t v159; // 0x8f654620
            uint32_t v160; // 0x8f65444c
            int32_t v161; // 0x8f6545f0
            int32_t v162; // 0x8f65464c
            int32_t v163; // 0x8f654694
            if (v43 >= (0x1000000 * (int32_t)v55 || 0x10000 * (int32_t)v54 || (int32_t)v52 || 256 * (int32_t)v51)) {
                char v164 = *(char *)(v45 - 15); // 0x8f653d38
                v81 = v45 - 56;
                char v165 = *(char *)(v45 - 16); // 0x8f653d40
                char v166 = *(char *)(v45 - 14); // 0x8f653d48
                char v167 = *(char *)(v45 - 13); // 0x8f653d50
                uint32_t v168 = 0x1000000 * (int32_t)v167 | 0x10000 * (int32_t)v166 | (int32_t)v165 | 256 * (int32_t)v164; // 0x8f653d54
                char v169 = *(char *)(v45 - 11); // 0x8f653d58
                char v170 = *(char *)(v45 - 12); // 0x8f653d5c
                char v171 = *(char *)(v45 - 10); // 0x8f653d64
                char v172 = *(char *)(v45 - 9); // 0x8f653d6c
                int32_t v173 = 0x1000000 * (int32_t)v172 | 0x10000 * (int32_t)v171 | (int32_t)v170 | 256 * (int32_t)v169; // 0x8f653d70
                char v174 = *(char *)(v45 - 23); // 0x8f653d74
                char v175 = *(char *)(v45 - 24); // 0x8f653d78
                char v176 = *(char *)(v45 - 22); // 0x8f653d80
                char v177 = *(char *)(v45 - 21); // 0x8f653d88
                int32_t v178 = 0x1000000 * (int32_t)v177 | 0x10000 * (int32_t)v176 | (int32_t)v175 | 256 * (int32_t)v174; // 0x8f653d8c
                char v179 = *(char *)(v45 - 19); // 0x8f653d90
                char v180 = *(char *)(v45 - 20); // 0x8f653d94
                int32_t v181 = str5; // 0x8f653da0
                char v182 = *(char *)(v181 - 18); // 0x8f653da0
                char v183 = *(char *)(v181 - 17); // 0x8f653da8
                if (v168 == v178 - 1 && v173 == (0x1000000 * (int32_t)v183 || 0x10000 * (int32_t)v182 || (int32_t)v180 || 256 * (int32_t)v179) - (int32_t)(v178 == 0)) {
                    int32_t v184 = *(int32_t *)(g36 + 20) - 34; // 0x8f653dcc
                    v75 = v184;
                    *(char *)(v81 + 40) = (char)v184;
                    *(char *)(v81 + 41) = (char)(v75 / 256);
                    uint32_t v185 = v75; // 0x8f653ddc
                    *(char *)(v81 + 42) = (char)(v185 / 0x10000);
                    *(char *)(v81 + 43) = (char)(v185 / 0x1000000);
                    v75 = 0;
                    *(char *)(v81 + 44) = 0;
                    *(char *)(v81 + 45) = (char)v75;
                    *(char *)(v81 + 46) = (char)v75;
                    *(char *)(v81 + 47) = (char)v75;
                    print_log(1, (int32_t)"last partition's ending_lba is 0x%llx\n", v185, 0, v46, v50, v49, v48, v47, 0, 0, v53, v13);
                    v57 = v53;
                    // branch -> 0x8f654254
                    // 0x8f654254
                    v79 = 0;
                    v77 = 1;
                    *(char *)(v2 + 528) = 0;
                    *(char *)(v2 + 529) = (char)v79;
                    v78 = 34;
                    v116 = v79;
                    *(char *)(v2 + 530) = (char)v116;
                    v88 = *(int32_t *)(*(int32_t *)v53 + 20);
                    v90 = v88 - 1;
                    v3 = v90;
                    v76 = v88 - 34;
                    *(char *)(v2 + 531) = (char)v79;
                    *(char *)(v2 + 537) = (char)v79;
                    *(char *)(v2 + 538) = (char)v79;
                    *(char *)(v2 + 539) = (char)v79;
                    *(char *)(v2 + 540) = (char)v79;
                    *(char *)(v2 + 541) = (char)v79;
                    *(char *)(v2 + 542) = (char)v79;
                    *(char *)(v2 + 543) = (char)v79;
                    *(char *)(v2 + 544) = (char)v3;
                    *(char *)(v2 + 545) = (char)(v90 / 256);
                    *(char *)(v2 + 548) = (char)v79;
                    *(char *)(v2 + 546) = (char)(v3 / 0x10000);
                    *(char *)(v2 + 547) = (char)(v3 / 0x1000000);
                    *(char *)(v2 + 549) = (char)v79;
                    *(char *)(v2 + 550) = (char)v79;
                    *(char *)(v2 + 551) = (char)v79;
                    *(char *)(v2 + 553) = (char)v79;
                    *(char *)(v2 + 554) = (char)v79;
                    *(char *)(v2 + 555) = (char)v79;
                    *(char *)(v2 + 556) = (char)v79;
                    *(char *)(v2 + 557) = (char)v79;
                    *(char *)(v2 + 558) = (char)v79;
                    *(char *)(v2 + 559) = (char)v79;
                    *(char *)(v2 + 560) = (char)v76;
                    *(char *)(v2 + 561) = (char)(v76 / 256);
                    *(char *)(v2 + 536) = (char)v77;
                    *(char *)(v2 + 562) = (char)(v76 / 0x10000);
                    *(char *)(v2 + 552) = (char)v78;
                    *(char *)(v2 + 563) = (char)(v76 / 0x1000000);
                    v92 = v2;
                    v118 = *(char *)(v92 + 597);
                    *(char *)(v92 + 584) = 2;
                    v93 = v2;
                    v119 = *(char *)(v93 + 596);
                    v120 = *(char *)(v93 + 593);
                    v121 = *(char *)(v93 + 598);
                    *(char *)(v93 + 564) = (char)v79;
                    *(char *)(v2 + 565) = (char)v79;
                    v94 = v2;
                    v122 = *(char *)(v94 + 599);
                    *(char *)(v94 + 566) = (char)v79;
                    *(char *)(v2 + 567) = (char)v79;
                    v95 = v2;
                    v123 = *(char *)(v95 + 592);
                    *(char *)(v95 + 585) = (char)v79;
                    v96 = v2;
                    v124 = *(char *)(v96 + 594);
                    *(char *)(v96 + 586) = (char)v79;
                    *(char *)(v2 + 587) = (char)v79;
                    v97 = v2;
                    v125 = *(char *)(v97 + 595);
                    *(char *)(v97 + 588) = (char)v79;
                    *(char *)(v2 + 589) = (char)v79;
                    *(char *)(v2 + 590) = (char)v79;
                    *(char *)(v2 + 591) = (char)v79;
                    v85 = (char *)v11;
                    v66 = crc32(v116, v85, (0x1000000 * (int32_t)v125 | 0x10000 * (int32_t)v124 | (int32_t)v123 | 256 * (int32_t)v120) * (0x1000000 * (int32_t)v122 | 0x10000 * (int32_t)v121 | (int32_t)v119 | 256 * (int32_t)v118));
                    v98 = v2;
                    v126 = *(char *)(v98 + 525);
                    *(char *)(v98 + 601) = (char)(v66 / 256);
                    *(char *)(v2 + 602) = (char)(v66 / 0x10000);
                    v99 = v2;
                    v127 = *(char *)(v99 + 524);
                    *(char *)(v99 + 600) = (char)v66;
                    v100 = v2;
                    v128 = *(char *)(v100 + 526);
                    *(char *)(v100 + 603) = (char)(v66 / 0x1000000);
                    v129 = *(char *)(v2 + 527);
                    v67 = crc32(v79, str, 0x1000000 * (int32_t)v129 | 0x10000 * (int32_t)v128 | (int32_t)v127 | 256 * (int32_t)v126);
                    v75 = 0;
                    v3 = a1;
                    *(char *)(v2 + 528) = (char)v67;
                    *(char *)(v2 + 529) = (char)(v67 / 256);
                    *(char *)(v2 + 530) = (char)(v67 / 0x10000);
                    *(char *)(v2 + 531) = (char)(v67 / 0x1000000);
                    v76 = 0;
                    v130 = v2;
                    v68 = generic_mmc_write_logical(0, v75, v3, 0, v130, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
                    v79 = v68;
                    if (v68 == 0) {
                        // 0x8f654410
                        notify_user((int32_t)"Flashing backup GPT image...", v75, v3, v76, v130, v50, v49);
                        *(char *)(v2 + 528) = (char)v79;
                        v117 = v79;
                        *(char *)(v2 + 529) = (char)v117;
                        *(char *)(v2 + 530) = (char)v79;
                        *(char *)(v2 + 531) = (char)v79;
                        v76 = *(int32_t *)(g36 + 20);
                        *(char *)(v2 + 540) = (char)v79;
                        v91 = v76 - 1;
                        v3 = v91;
                        *(char *)(v2 + 536) = (char)v91;
                        *(char *)(v2 + 537) = (char)(v3 / 256);
                        v160 = v3;
                        *(char *)(v2 + 539) = (char)(v160 / 0x1000000);
                        v89 = v76;
                        v3 = v89 - 34;
                        v76 = v89 - 33;
                        *(char *)(v2 + 538) = (char)(v160 / 0x10000);
                        *(char *)(v2 + 560) = (char)v3;
                        *(char *)(v2 + 541) = (char)v79;
                        *(char *)(v2 + 561) = (char)(v3 / 256);
                        *(char *)(v2 + 542) = (char)v79;
                        *(char *)(v2 + 562) = (char)(v3 / 0x10000);
                        *(char *)(v2 + 543) = (char)v79;
                        *(char *)(v2 + 544) = (char)v77;
                        *(char *)(v2 + 545) = (char)v79;
                        *(char *)(v2 + 546) = (char)v79;
                        *(char *)(v2 + 547) = (char)v79;
                        *(char *)(v2 + 548) = (char)v79;
                        *(char *)(v2 + 549) = (char)v79;
                        *(char *)(v2 + 550) = (char)v79;
                        *(char *)(v2 + 551) = (char)v79;
                        *(char *)(v2 + 552) = (char)v78;
                        *(char *)(v2 + 553) = (char)v79;
                        *(char *)(v2 + 554) = (char)v79;
                        *(char *)(v2 + 555) = (char)v79;
                        *(char *)(v2 + 556) = (char)v79;
                        *(char *)(v2 + 557) = (char)v79;
                        *(char *)(v2 + 558) = (char)v79;
                        *(char *)(v2 + 559) = (char)v79;
                        *(char *)(v2 + 563) = (char)(v3 / 0x1000000);
                        *(char *)(v2 + 585) = (char)(v76 / 256);
                        *(char *)(v2 + 586) = (char)(v76 / 0x10000);
                        v101 = v2;
                        v131 = *(char *)(v101 + 597);
                        *(char *)(v101 + 584) = (char)v76;
                        *(char *)(v2 + 587) = (char)(v76 / 0x1000000);
                        v102 = v2;
                        v132 = *(char *)(v102 + 596);
                        v133 = *(char *)(v102 + 593);
                        v134 = *(char *)(v102 + 598);
                        *(char *)(v102 + 564) = (char)v79;
                        *(char *)(v2 + 565) = (char)v79;
                        v103 = v2;
                        v135 = *(char *)(v103 + 599);
                        *(char *)(v103 + 566) = (char)v79;
                        *(char *)(v2 + 567) = (char)v79;
                        v104 = v2;
                        v136 = *(char *)(v104 + 592);
                        *(char *)(v104 + 588) = (char)v79;
                        v105 = v2;
                        v137 = *(char *)(v105 + 594);
                        *(char *)(v105 + 589) = (char)v79;
                        *(char *)(v2 + 590) = (char)v79;
                        v106 = v2;
                        v138 = *(char *)(v106 + 595);
                        *(char *)(v106 + 591) = (char)v79;
                        v69 = crc32(v117, v85, (0x1000000 * (int32_t)v138 | 0x10000 * (int32_t)v137 | (int32_t)v136 | 256 * (int32_t)v133) * (0x1000000 * (int32_t)v135 | 0x10000 * (int32_t)v134 | (int32_t)v132 | 256 * (int32_t)v131));
                        v107 = v2;
                        v139 = *(char *)(v107 + 525);
                        *(char *)(v107 + 601) = (char)(v69 / 256);
                        *(char *)(v2 + 602) = (char)(v69 / 0x10000);
                        v108 = v2;
                        v140 = *(char *)(v108 + 524);
                        *(char *)(v108 + 600) = (char)v69;
                        v109 = v2;
                        v141 = *(char *)(v109 + 526);
                        *(char *)(v109 + 603) = (char)(v69 / 0x1000000);
                        v142 = *(char *)(v2 + 527);
                        v70 = crc32(v79, str, 0x1000000 * (int32_t)v142 | 0x10000 * (int32_t)v141 | (int32_t)v140 | 256 * (int32_t)v139);
                        v110 = v2;
                        v143 = *(char *)(v110 + 537);
                        v144 = *(char *)(v110 + 541);
                        *(char *)(v110 + 529) = (char)(v70 / 256);
                        *(char *)(v2 + 530) = (char)(v70 / 0x10000);
                        v111 = v2;
                        v145 = *(char *)(v111 + 536);
                        *(char *)(v111 + 528) = (char)v70;
                        v112 = v2;
                        v146 = *(char *)(v112 + 538);
                        *(char *)(v112 + 531) = (char)(v70 / 0x1000000);
                        v158 = 0x10000 * (int32_t)v146 | (int32_t)v145 | 256 * (int32_t)v143;
                        v113 = v2;
                        v147 = *(char *)(v113 + 539);
                        v148 = *(char *)(v113 + 540);
                        v149 = *(char *)(v113 + 542);
                        v161 = 512 * (0x10000 * (int32_t)v149 | (int32_t)v148 | 256 * (int32_t)v144) | (0x1000000 * (int32_t)v147 | v158) / 0x800000;
                        v71 = generic_mmc_write_logical(512 * v158, v161, 512, 0, v10, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
                        if (v71 != 0) {
                            // if_8f654600_0_true
                            // branch -> 0x8f654664
                            // 0x8f654664
                            notify_user((int32_t)"Failed to write EFI backup GPT header.\n", v161, 512, 0, v10, v50, v49);
                            // branch -> 0x8f654668
                            // 0x8f654668
                            // branch -> 0x8f65489c
                            // 0x8f65489c
                            if (v1 != g35) {
                                // 0x8f6548b0
                                __stack_chk_fail();
                                // branch -> 0x8f6548b4
                            }
                            // 0x8f6548b4
                            return -1;
                        }
                        // 0x8f654608
                        v114 = v2;
                        v150 = *(char *)(v114 + 585);
                        v151 = *(char *)(v114 + 584);
                        v152 = *(char *)(v114 + 589);
                        v153 = *(char *)(v114 + 586);
                        v159 = 0x10000 * (int32_t)v153 | (int32_t)v151 | 256 * (int32_t)v150;
                        v154 = *(char *)(v114 + 587);
                        v155 = *(char *)(v114 + 588);
                        v156 = *(char *)(v114 + 590);
                        v3 = 0x4000;
                        v162 = 512 * (0x10000 * (int32_t)v156 | (int32_t)v155 | 256 * (int32_t)v152) | (0x1000000 * (int32_t)v154 | v159) / 0x800000;
                        v75 = v162;
                        v76 = 0;
                        v72 = generic_mmc_write_logical(512 * v159, v162, 0x4000, 0, v11, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
                        if (v72 == 0) {
                            // 0x8f654670
                            init_gpt(0, v75, v3, v76, v11, v50, v49, v48, v47, 0, 0);
                            v86 = g33;
                            v87 = (int32_t)v86;
                            if (v86 != (char *)&g32) {
                                // 0x8f654694
                                v80 = v87;
                                v115 = v87;
                                v60 = v50;
                                v61 = v49;
                                v62 = v48;
                                v63 = v47;
                                v58 = v13;
                                v59 = v11;
                                // branch -> 0x8f654694
                                while (true) {
                                    // 0x8f654694
                                    v64 = (int32_t *)v115;
                                    v163 = *(int32_t *)(v115 + 4);
                                    v81 = *(int32_t *)(v115 + 8);
                                    v2 = *(int32_t *)(v115 + 12);
                                    *(int32_t *)v163 = *v64;
                                    v157 = *(int32_t *)v80;
                                    *(int32_t *)(v157 + 4) = v163;
                                    *(int32_t *)(v80 + 4) = 0;
                                    v79 = v115 + 16;
                                    *v64 = 0;
                                    v73 = get_partition_by_name(v79, 0, v157, v163, v59, v60, v61, v62, v63, 0, 0);
                                    v65 = (int32_t)v73;
                                    notify_user((int32_t)"restoring %s", v79, v157, v65, v59, v60, v61);
                                    v76 = v65;
                                    int32_t v186; // 0x8f65487441
                                    int32_t v187; // 0x8f65488051
                                    int32_t v188; // 0x8f65488052
                                    int32_t v189; // 0x8f65488020
                                    int32_t v190; // 0x8f65488021
                                    int32_t v191; // 0x8f65488025
                                    int32_t v192; // 0x8f65488026
                                    int32_t v193; // 0x8f65487430
                                    int32_t v194; // 0x8f65487435
                                    int32_t v195; // 0x8f6546ec
                                    if (v73 == NULL) {
                                      lab_0x8f6546e4:
                                        // 0x8f6546e4
                                        v195 = v79;
                                        print_log(v65, (int32_t)"Unable to find partition \"%s\"\n", v195, v65, v59, v60, v61, v62, v63, 0, 0, v65, v58);
                                        v188 = v59;
                                        v192 = v61;
                                        v190 = v60;
                                        // branch -> 0x8f65487c
                                    } else {
                                      lab_0x8f6546fc:;
                                        char v196 = *(char *)(v65 + 33); // 0x8f6546fc
                                        char v197 = *(char *)(v65 + 32); // 0x8f654700
                                        char v198 = *(char *)(v65 + 41); // 0x8f654704
                                        char v199 = *(char *)(v65 + 34); // 0x8f65470c
                                        int32_t v200 = 0x10000 * (int32_t)v199 | (int32_t)v197 | 256 * (int32_t)v196; // 0x8f654710
                                        uint32_t v201 = 0x1000000 * (int32_t)*(char *)(v65 + 35) | v200; // 0x8f654718
                                        char v202 = *(char *)(v65 + 37); // 0x8f65471c
                                        char v203 = *(char *)(v65 + 36); // 0x8f654720
                                        str5 = 512 * v200;
                                        char v204 = *(char *)(v65 + 38); // 0x8f65472c
                                        int32_t v205 = 0x10000 * (int32_t)v204 | (int32_t)v203 | 256 * (int32_t)v202; // 0x8f654730
                                        char v206 = *(char *)(v65 + 40); // 0x8f65473c
                                        char v207 = *(char *)(v65 + 42); // 0x8f654744
                                        v12 = 512 * v205 | v201 / 0x800000;
                                        char v208 = *(char *)(v65 + 43); // 0x8f654754
                                        int32_t v209 = 0x1000000 * (int32_t)v208 | 0x10000 * (int32_t)v207 | (int32_t)v206 | 256 * (int32_t)v198; // 0x8f654758
                                        char v210 = *(char *)(v65 + 45); // 0x8f65475c
                                        char v211 = *(char *)(v65 + 44); // 0x8f654760
                                        uint32_t v212 = v209 + 1; // 0x8f654764
                                        int32_t v213 = v76; // 0x8f65476c
                                        char v214 = *(char *)(v213 + 46); // 0x8f65476c
                                        uint32_t v215 = v212 - v201; // 0x8f654780
                                        int32_t v216 = v2; // 0x8f654788
                                        v77 = v216;
                                        v78 = 0;
                                        int32_t v217 = 512 * ((int32_t)(v209 == -1) - v205 + (int32_t)(v212 < v201) + (0x10000 * (int32_t)v214 | (int32_t)v211 | 256 * (int32_t)v210)) | v215 / 0x800000; // 0x8f654794
                                        int32_t v218 = 512 * v215; // 0x8f65479c
                                        int32_t v219; // 0x8f654880
                                        int32_t v220; // 0x8f65487431
                                        int32_t v221; // 0x8f65487436
                                        if (v218 < v216 && v217 == 0) {
                                            int32_t v222 = v79; // 0x8f6547c0
                                            v3 = v222;
                                            v76 = v218;
                                            print_log(0, (int32_t)"Dest partition %s has smaller size(0x%llx) than backuped size(0x%llx)\n", v222, v218, v216, v60, v61, v62, v63, 0, 0, v65, v218);
                                            v188 = v216;
                                            v221 = v63;
                                            v220 = v62;
                                            v192 = v61;
                                            v190 = v60;
                                            v219 = (int32_t)"Shrinked %s size, failed to restore";
                                            // branch -> 0x8f65487c
                                          lab_0x8f65487c_2:
                                            // 0x8f65487c
                                            notify_user(v219, v79, v3, v76, v188, v190, v192);
                                            v187 = v188;
                                            v186 = v218;
                                            v194 = v221;
                                            v193 = v220;
                                            v191 = v192;
                                            v189 = v190;
                                            // branch -> 0x8f654884
                                        } else {
                                            unsigned char v223 = *(char *)(v213 + 49); // 0x8f6547d4
                                            int32_t v224; // 0x8f654838
                                            if (image_match_partition_size((int32_t)(v223 % 16), v217, v218, v213, v59, v60, v61) == 0) {
                                                // 0x8f6547d4
                                                v224 = v76;
                                                // branch -> 0x8f654818
                                            } else {
                                                uint32_t v225 = v78; // 0x8f6547ec
                                                uint32_t v226 = v77; // 0x8f6547f0
                                                bool v227 = false; // 0x8f6547f4
                                                bool v228 = v217 >= v225; // 0x8f6547f4
                                                if (v217 == v225) {
                                                    // if_8f6547f0_0_true
                                                    v227 = v218 == v226;
                                                    v228 = v218 >= v226;
                                                    // branch -> after_if_8f6547f0_0
                                                }
                                                // after_if_8f6547f0_0
                                                if (!v227 && !((v228 ^ true))) {
                                                    int32_t v229 = v2; // 0x8f6547fc
                                                    int32_t v230 = v79; // 0x8f654804
                                                    v3 = v230;
                                                    v76 = v218;
                                                    print_log(0, (int32_t)"Dest partition %s size doesn't match: [0x%llx, 0x%llx]\n", v230, v218, v229, v60, v61, v62, v63, 0, 0, v65, v218);
                                                    v188 = v229;
                                                    v221 = v63;
                                                    v220 = v62;
                                                    v192 = v61;
                                                    v190 = v60;
                                                    v219 = (int32_t)"Mismatched partition %s size";
                                                    // branch -> 0x8f65487c
                                                    goto lab_0x8f65487c_2;
                                                } else {
                                                    v224 = v217;
                                                }
                                            }
                                            int32_t v231 = str5; // 0x8f654820
                                            int32_t v232 = v12; // 0x8f654824
                                            int32_t v233 = v81; // 0x8f654834
                                            print_log(2, (int32_t)"write partition %s: size=0x%llx, offset=0x%llx, buff=%p\n", v79, v224, v218, v217, v231, v232, v233, 0, 0, v65, v218);
                                            int32_t v234 = v81; // 0x8f65483c
                                            int32_t v235 = v78; // 0x8f65484c
                                            v76 = v235;
                                            if (generic_mmc_write_logical(str5, v12, v77, v235, v234, v217, v231, v232, v233, 0, 0, v65, v218, v217, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0) != 0) {
                                                int32_t v236 = str5; // 0x8f654860
                                                int32_t v237 = v12; // 0x8f654860
                                                int32_t v238 = v81; // 0x8f654864
                                                int32_t v239 = v79; // 0x8f654868
                                                v3 = v239;
                                                int32_t v240 = v2; // 0x8f65486c
                                                print_log(-1, (int32_t)"mmc_write[%s](0x%llx, %p, %d)\n", v239, v76, v236, v237, v238, v240, v233, 0, 0, v65, v218);
                                                v188 = v236;
                                                v221 = v233;
                                                v220 = v240;
                                                v192 = v238;
                                                v190 = v237;
                                                v219 = (int32_t)"failed to restore %s";
                                                // branch -> 0x8f65487c
                                                goto lab_0x8f65487c_2;
                                            } else {
                                                v187 = v234;
                                                v186 = v218;
                                                v194 = v233;
                                                v193 = v232;
                                                v191 = v231;
                                                v189 = v217;
                                            }
                                        }
                                      lab_0x8f654884:
                                        // 0x8f654884
                                        free((char *)v80);
                                        int32_t v241 = (int32_t)g33;
                                        v80 = v241;
                                        if (g33 == (char *)&g32) {
                                            // break -> 0x8f654890
                                            break;
                                        }
                                        v115 = v241;
                                        v60 = v189;
                                        v61 = v191;
                                        v62 = v193;
                                        v63 = v194;
                                        v58 = v186;
                                        v59 = v187;
                                        // continue -> 0x8f654694
                                        continue;
                                    }
                                    // 0x8f65487c
                                    notify_user((int32_t)"%s no longer exists!", v79, v195, v76, v188, v190, v192);
                                    v187 = v188;
                                    v186 = v58;
                                    v194 = v63;
                                    v193 = v62;
                                    v191 = v192;
                                    v189 = v190;
                                    // branch -> 0x8f654884
                                    goto lab_0x8f654884;
                                }
                                // 0x8f654890
                                *(char *)&g28 = 0;
                                // branch -> 0x8f65489c
                                // 0x8f65489c
                                if (v1 != g35) {
                                    // 0x8f6548b0
                                    __stack_chk_fail();
                                    // branch -> 0x8f6548b4
                                }
                                // 0x8f6548b4
                                return 0;
                            }
                            // 0x8f654890
                            v74 = 0;
                            *(char *)&g28 = 0;
                            v82 = 0;
                            // branch -> 0x8f65489c
                        } else {
                            // 0x8f654660
                            // branch -> 0x8f654664
                            // 0x8f654664
                            notify_user((int32_t)"Failed to write EFI backup GPT entries.\n", v75, v3, v76, v11, v50, v49);
                            // branch -> 0x8f654668
                            // 0x8f654668
                            v74 = -1;
                            v82 = -1;
                            // branch -> 0x8f65489c
                        }
                        // 0x8f65489c
                        if (v1 != g35) {
                            // 0x8f6548b0
                            __stack_chk_fail();
                            result = v74;
                            // branch -> 0x8f6548b4
                        } else {
                            result = v82;
                        }
                        // 0x8f6548b4
                        return result;
                    }
                    // if_8f654408_0_true
                    // branch -> 0x8f654664
                    // 0x8f654664
                    notify_user((int32_t)"Failed to write primary GPT.\n", v75, v3, v76, v130, v50, v49);
                    // branch -> 0x8f654668
                } else {
                    int32_t v242 = *(int32_t *)(g36 + 20); // 0x8f653e24
                    if (v173 != 0 || v242 - 34 < v168) {
                        // 0x8f653e3c
                        print_log(0, (int32_t)"Invalid partition[%d] size: %d, %lld\n", v12, v242 - 33, v168, v173, v49, v48, v47, 0, 0, v14, v13);
                        // branch -> 0x8f654668
                        // 0x8f654668
                        // branch -> 0x8f65489c
                        // 0x8f65489c
                        if (v1 != g35) {
                            // 0x8f6548b0
                            __stack_chk_fail();
                            // branch -> 0x8f6548b4
                        }
                        // 0x8f6548b4
                        return -1;
                    }
                    unsigned char v243 = *(char *)(v81 + 48) / 32 % 2;
                    v77 = v243;
                    int32_t v244; // 0x8f653e80
                    int32_t v245;
                    if (v243 == 0) {
                        // 0x8f653ec4
                        memset((char *)&str3, 0, 37);
                        utf_to_str_constprop_3(str5, v23, 37, 0);
                        int32_t v246 = v77; // 0x8f653ee8
                        // branch -> 0x8f653ee0
                        int32_t v247; // 0x8f653d08
                        while (true) {
                            int32_t str4 = *(int32_t *)(v246 + (int32_t)&g6); // 0x8f653ee8
                            if (strncmp((char *)&str3, (char *)str4, 72) == 0) {
                                // 0x8f653efc
                                print_log(1, (int32_t)"found compulsory backup partition: %s\n", v23, 0, v46, v50, v49, v48, v47, 0, 0, v14, v13);
                                // branch -> 0x8f653e68
                                // 0x8f653e68
                                memset((char *)&str3, 0, 37);
                                v244 = utf_to_str_constprop_3(str5, v23, 37, 0);
                                v245 = g29;
                                v78 = v245;
                                int32_t v248; // 0x8f654080
                                int32_t v249; // 0x8f654080
                                if (v245 == 0) {
                                  lab_0x8f653e94:;
                                    char v250 = *(char *)(g30 + 81); // 0x8f653e9c
                                    char v251 = *(char *)(g30 + 80); // 0x8f653ea0
                                    char v252 = *(char *)(g30 + 82); // 0x8f653ea8
                                    char v253 = *(char *)(g30 + 83); // 0x8f653eac
                                    int32_t v254 = 0x10000 * (int32_t)v252 | (int32_t)v251 | 256 * (int32_t)v250 | 0x1000000 * (int32_t)v253; // 0x8f653eb4
                                    v80 = v254;
                                    v76 = &g26;
                                    int32_t v255 = g26;
                                    v77 = v255;
                                    if (v254 > 0) {
                                        while (true) {
                                            // 0x8f653f10
                                            v79 = v255;
                                            int32_t v256 = v77 + 128; // 0x8f653f24
                                            v77 = v256;
                                            if (memcmp((char *)(v255 + 56), (char *)str5, 72) == 0) {
                                                // 0x8f653f40
                                                if (v79 != 0) {
                                                    // 0x8f653f48
                                                    v75 = (int32_t)"Found partition %s in alternate GPT\n";
                                                    v249 = v76;
                                                    v248 = (int32_t)"Found partition %s in alternate GPT\n";
                                                    // branch -> 0x8f65407c
                                                  lab_0x8f65407c_2:
                                                    // 0x8f65407c
                                                    print_log(1, v248, v23, v249, v46, v50, v49, v48, v47, 0, 0, v14, v13);
                                                    if (v79 != 0) {
                                                        int32_t v257 = get_entry_name(v81, v75, v23, v76, v46, v50, v49, v48); // 0x8f654090
                                                        print_log(1, (int32_t)"partition[%d] %s needs backup\n", v12, v257, v46, v50, v49, v48, v47, 0, 0, v14, v13);
                                                        memset((char *)&str3, 0, 37);
                                                        utf_to_str_constprop_3(v79 + 56, v23, 37, v257);
                                                        notify_user((int32_t)"caching %s ...", v23, 37, v257, v46, v50, v49);
                                                        char * mem = malloc(88); // 0x8f6540d4
                                                        v77 = (int32_t)mem;
                                                        if (mem == NULL) {
                                                            // 0x8f6540e0
                                                            notify_user((int32_t)"Failed to cache %s", v23, 37, v257, v46, v50, v49);
                                                            // branch -> 0x8f653d08
                                                        } else {
                                                            // 0x8f6540f0
                                                            memset(mem, 0, 88);
                                                            int32_t v258 = v79; // 0x8f6540fc
                                                            char v259 = *(char *)(v258 + 33); // 0x8f6540fc
                                                            char v260 = *(char *)(v258 + 32); // 0x8f654100
                                                            char v261 = *(char *)(v258 + 41); // 0x8f654104
                                                            char v262 = *(char *)(v258 + 34); // 0x8f65410c
                                                            char v263 = *(char *)(v258 + 40); // 0x8f654110
                                                            int32_t v264 = 0x10000 * (int32_t)v262 | (int32_t)v260 | 256 * (int32_t)v259; // 0x8f654114
                                                            char v265 = *(char *)(v258 + 42); // 0x8f654120
                                                            uint32_t v266 = 0x1000000 * (int32_t)*(char *)(v258 + 35) | v264; // 0x8f654124
                                                            char v267 = *(char *)(v258 + 37); // 0x8f654128
                                                            char v268 = *(char *)(v258 + 36); // 0x8f65412c
                                                            char v269 = *(char *)(v258 + 43); // 0x8f654134
                                                            int32_t v270 = 512 * v264; // 0x8f654138
                                                            char v271 = *(char *)(v258 + 38); // 0x8f654140
                                                            int32_t v272 = 0x10000 * (int32_t)v271 | (int32_t)v268 | 256 * (int32_t)v267; // 0x8f654148
                                                            char v273 = *(char *)(v258 + 39); // 0x8f65414c
                                                            int32_t v274 = 0x1000000 * (int32_t)v269 | 0x10000 * (int32_t)v265 | (int32_t)v263 | 256 * (int32_t)v261; // 0x8f654154
                                                            char v275 = *(char *)(v258 + 45); // 0x8f654158
                                                            uint32_t v276 = v274 + 1; // 0x8f65415c
                                                            char v277 = *(char *)(v258 + 44); // 0x8f654160
                                                            v81 = 512 * v272 | v266 / 0x800000;
                                                            char v278 = *(char *)(v258 + 46); // 0x8f654170
                                                            char v279 = *(char *)(v258 + 47); // 0x8f654178
                                                            uint32_t v280 = v276 - v266; // 0x8f654184
                                                            int32_t v281 = (int32_t)(v274 == -1) - (0x1000000 * (int32_t)v273 | v272) + (int32_t)(v276 < v266) + (0x1000000 * (int32_t)v279 | 0x10000 * (int32_t)v278 | (int32_t)v277 | 256 * (int32_t)v275); // 0x8f654188
                                                            int32_t v282 = 512 * v280; // 0x8f654190
                                                            v78 = v282;
                                                            v79 = 512 * v281 | v280 / 0x800000;
                                                            int32_t v283 = g31 - v282; // 0x8f6541a4
                                                            g31 = v283;
                                                            v80 = v283 + 1;
                                                            partition_get_index(v23, v281, v283, (int32_t)&g31, v46, v50);
                                                            int32_t v284 = v79; // 0x8f6541bc
                                                            int32_t v285 = v81; // 0x8f6541c0
                                                            int32_t v286 = v80; // 0x8f6541c4
                                                            print_log(2, (int32_t)"read partition %s[%d]: size=0x%llx, offset=0x%llx, buff=0x%x\n", v23, v23, v78, v284, v270, v285, v286, 0, 0, v14, v13);
                                                            int32_t v287 = v80; // 0x8f6541dc
                                                            int32_t v288 = v79; // 0x8f6541ec
                                                            if (generic_mmc_read_logical(v270, v81, v78, v288, v287, v284, v270, v285, v286, 0, 0, v14, v13, v84, v10, v11, v270, a1, str2, 0x54524150, 0, str3, 0) == 0) {
                                                                // 0x8f654224
                                                                *(int32_t *)(v77 + 8) = v80;
                                                                *(int32_t *)(v77 + 12) = v78;
                                                                memcpy((char *)(v77 + 16), (char *)&str3, 72);
                                                                int32_t v289 = (int32_t)g32;
                                                                int32_t v290 = v77; // 0x8f654244
                                                                *(int32_t *)&g32 = v290;
                                                                *(int32_t *)v290 = v289;
                                                                *(int32_t *)(v290 + 4) = (int32_t)&g32;
                                                                *(int32_t *)(v289 + 4) = v77;
                                                                // branch -> 0x8f653d08
                                                            } else {
                                                                // 0x8f6541fc
                                                                print_log(-1, (int32_t)"failed to read partition %s\n", v23, v288, v287, v284, v270, v285, v286, 0, 0, v14, v13);
                                                                notify_user((int32_t)"Failed to cache %s", v23, v23, v288, v287, v284, v270);
                                                                free((char *)v77);
                                                                // branch -> 0x8f653d08
                                                            }
                                                            // 0x8f653d08
                                                            v247 = v12 + 1;
                                                            v12 = v247;
                                                            v43 = v247;
                                                            v44 = v2;
                                                            v45 = str5 + 128;
                                                            v46 = v287;
                                                            v83 = v270;
                                                            v47 = v286;
                                                            v48 = v285;
                                                            v49 = v270;
                                                            v50 = v284;
                                                            // branch -> 0x8f653d10
                                                            goto lab_0x8f653d10_3;
                                                        }
                                                        // 0x8f653d08
                                                        v247 = v12 + 1;
                                                        v12 = v247;
                                                        v43 = v247;
                                                        v44 = v2;
                                                        v45 = str5 + 128;
                                                        // branch -> 0x8f653d10
                                                        goto lab_0x8f653d10_3;
                                                    }
                                                }
                                            } else {
                                                int32_t v291 = v78 + 1; // 0x8f653f30
                                                v78 = v291;
                                                if (v291 >= v80) {
                                                    // break -> 0x8f653d08
                                                    break;
                                                }
                                                v255 = v256;
                                                // continue -> 0x8f653f10
                                                continue;
                                            }
                                            // 0x8f653d08
                                            v247 = v12 + 1;
                                            v12 = v247;
                                            v43 = v247;
                                            v44 = v2;
                                            v45 = str5 + 128;
                                            // branch -> 0x8f653d10
                                            goto lab_0x8f653d10_3;
                                        }
                                      lab_0x8f653d08_3:
                                        // 0x8f653d08
                                        v12++;
                                        // branch -> 0x8f653d10
                                        break;
                                    }
                                } else {
                                  lab_0x8f653f54:;
                                    char * v292 = get_partition_by_name(v23, v244, 37, (int32_t)&g29, v46, v50, v49, v48, v47, 0, 0); // 0x8f653f58
                                    v79 = v23;
                                    if (v292 == NULL) {
                                        goto lab_0x8f653d08_3;
                                    }
                                    // 0x8f653f64
                                    if (memcmp((char *)&str6, (char *)str5, 72) != 0) {
                                        goto lab_0x8f653d08_3;
                                    }
                                    int32_t v293 = v81; // 0x8f653f7c
                                    char v294 = *(char *)(v293 + 33); // 0x8f653f7c
                                    char v295 = *(char *)(v293 + 32); // 0x8f653f80
                                    char v296 = *(char *)(v293 + 34); // 0x8f653f8c
                                    char v297 = *(char *)(v293 + 35); // 0x8f653f98
                                    char v298 = *(char *)(v293 + 37); // 0x8f653fa8
                                    char v299 = *(char *)(v293 + 36); // 0x8f653fac
                                    char v300 = *(char *)(v293 + 38); // 0x8f653fbc
                                    char v301 = *(char *)(v293 + 39); // 0x8f653fc4
                                    v76 = v33;
                                    if ((0x1000000 * (int32_t)v297 || 0x10000 * (int32_t)v296 || (int32_t)v295 || 256 * (int32_t)v294) == v28 && (0x1000000 * (int32_t)v301 || 0x10000 * (int32_t)v300 || (int32_t)v299 || 256 * (int32_t)v298) == v33) {
                                        char v302 = *(char *)(v293 + 41); // 0x8f653ff8
                                        char v303 = *(char *)(v293 + 40); // 0x8f653ffc
                                        char v304 = *(char *)(v293 + 42); // 0x8f654008
                                        char v305 = *(char *)(v293 + 43); // 0x8f654014
                                        char v306 = *(char *)(v293 + 45); // 0x8f654024
                                        char v307 = *(char *)(v293 + 44); // 0x8f654028
                                        char v308 = *(char *)(v293 + 46); // 0x8f654038
                                        char v309 = *(char *)(v293 + 47); // 0x8f654040
                                        v76 = v42;
                                        if ((0x1000000 * (int32_t)v305 || 0x10000 * (int32_t)v304 || (int32_t)v303 || 256 * (int32_t)v302) == v37 && (0x1000000 * (int32_t)v309 || 0x10000 * (int32_t)v308 || (int32_t)v307 || 256 * (int32_t)v306) == v42) {
                                            goto lab_0x8f653d08_3;
                                        }
                                        // 0x8f654074
                                        v75 = (int32_t)"Found mismatched partition %s in GPT\n";
                                        v249 = v42;
                                        v248 = (int32_t)"Found mismatched partition %s in GPT\n";
                                        // branch -> 0x8f65407c
                                        goto lab_0x8f65407c_2;
                                    }
                                    // 0x8f654074
                                    v75 = (int32_t)"Found mismatched partition %s in GPT\n";
                                    v249 = v33;
                                    v248 = (int32_t)"Found mismatched partition %s in GPT\n";
                                    // branch -> 0x8f65407c
                                    goto lab_0x8f65407c_2;
                                }
                                // 0x8f653d08
                                v12++;
                                // branch -> 0x8f653d10
                                break;
                            } else {
                                int32_t v310 = v77 + 4; // 0x8f653cfc
                                v77 = v310;
                                if (v310 == 28) {
                                    // break -> 0x8f653d08
                                    break;
                                }
                                v246 = v310;
                                // continue -> 0x8f653ee0
                                continue;
                            }
                            int32_t v311 = v12; // 0x8f653d08
                            v247 = v311 + 1;
                            v12 = v247;
                            int32_t v312 = str5; // 0x8f653d0c
                            int32_t v313 = v312 + 128; // 0x8f653d0c
                            int32_t v314 = v2;
                            v43 = v247;
                            v44 = v314;
                            v45 = v313;
                            int32_t v315; // 0x8f65488054
                            v46 = v315;
                            int32_t v316; // 0x8f65485044
                            v83 = v316;
                            int32_t v317; // 0x8f65487434
                            v47 = v317;
                            int32_t v318; // 0x8f65487429
                            v48 = v318;
                            int32_t v319; // 0x8f65488027
                            v49 = v319;
                            int32_t v320; // 0x8f65488022
                            v50 = v320;
                            // branch -> 0x8f653d10
                            break;
                        }
                        // 0x8f653d08
                        v247 = v12 + 1;
                        v12 = v247;
                        v43 = v247;
                        v44 = v2;
                        v45 = str5 + 128;
                        // branch -> 0x8f653d10
                        continue;
                    }
                    // 0x8f653e68
                    memset((char *)&str3, 0, 37);
                    v244 = utf_to_str_constprop_3(str5, v23, 37, 0);
                    v245 = g29;
                    v78 = v245;
                    if (v245 == 0) {
                        goto lab_0x8f653e94;
                    }
                    goto lab_0x8f653f54;
                }
                // 0x8f654668
                // branch -> 0x8f65489c
                // 0x8f65489c
                if (v1 != g35) {
                    // 0x8f6548b0
                    __stack_chk_fail();
                    // branch -> 0x8f6548b4
                }
                // 0x8f6548b4
                return -1;
            }
            // 0x8f654254
            v79 = 0;
            v77 = 1;
            *(char *)(v56 + 528) = 0;
            *(char *)(v2 + 529) = (char)v79;
            v78 = 34;
            int32_t v321 = *(int32_t *)(*(int32_t *)(int32_t)&g36 + 20); // 0x8f65426c
            v116 = v79;
            *(char *)(v2 + 530) = (char)v116;
            v88 = v321;
            v90 = v88 - 1;
            v3 = v90;
            v76 = v88 - 34;
            *(char *)(v2 + 531) = (char)v79;
            *(char *)(v2 + 537) = (char)v79;
            *(char *)(v2 + 538) = (char)v79;
            *(char *)(v2 + 539) = (char)v79;
            *(char *)(v2 + 540) = (char)v79;
            *(char *)(v2 + 541) = (char)v79;
            *(char *)(v2 + 542) = (char)v79;
            *(char *)(v2 + 543) = (char)v79;
            *(char *)(v2 + 544) = (char)v3;
            *(char *)(v2 + 545) = (char)(v90 / 256);
            *(char *)(v2 + 548) = (char)v79;
            *(char *)(v2 + 546) = (char)(v3 / 0x10000);
            *(char *)(v2 + 547) = (char)(v3 / 0x1000000);
            *(char *)(v2 + 549) = (char)v79;
            *(char *)(v2 + 550) = (char)v79;
            *(char *)(v2 + 551) = (char)v79;
            *(char *)(v2 + 553) = (char)v79;
            *(char *)(v2 + 554) = (char)v79;
            *(char *)(v2 + 555) = (char)v79;
            *(char *)(v2 + 556) = (char)v79;
            *(char *)(v2 + 557) = (char)v79;
            *(char *)(v2 + 558) = (char)v79;
            *(char *)(v2 + 559) = (char)v79;
            *(char *)(v2 + 560) = (char)v76;
            *(char *)(v2 + 561) = (char)(v76 / 256);
            *(char *)(v2 + 536) = (char)v77;
            *(char *)(v2 + 562) = (char)(v76 / 0x10000);
            *(char *)(v2 + 552) = (char)v78;
            *(char *)(v2 + 563) = (char)(v76 / 0x1000000);
            v92 = v2;
            v118 = *(char *)(v92 + 597);
            *(char *)(v92 + 584) = 2;
            v93 = v2;
            v119 = *(char *)(v93 + 596);
            v120 = *(char *)(v93 + 593);
            v121 = *(char *)(v93 + 598);
            *(char *)(v93 + 564) = (char)v79;
            *(char *)(v2 + 565) = (char)v79;
            v94 = v2;
            v122 = *(char *)(v94 + 599);
            *(char *)(v94 + 566) = (char)v79;
            *(char *)(v2 + 567) = (char)v79;
            v95 = v2;
            v123 = *(char *)(v95 + 592);
            *(char *)(v95 + 585) = (char)v79;
            v96 = v2;
            v124 = *(char *)(v96 + 594);
            *(char *)(v96 + 586) = (char)v79;
            *(char *)(v2 + 587) = (char)v79;
            v97 = v2;
            v125 = *(char *)(v97 + 595);
            *(char *)(v97 + 588) = (char)v79;
            *(char *)(v2 + 589) = (char)v79;
            *(char *)(v2 + 590) = (char)v79;
            *(char *)(v2 + 591) = (char)v79;
            v85 = (char *)v11;
            v66 = crc32(v116, v85, (0x1000000 * (int32_t)v125 | 0x10000 * (int32_t)v124 | (int32_t)v123 | 256 * (int32_t)v120) * (0x1000000 * (int32_t)v122 | 0x10000 * (int32_t)v121 | (int32_t)v119 | 256 * (int32_t)v118));
            v98 = v2;
            v126 = *(char *)(v98 + 525);
            *(char *)(v98 + 601) = (char)(v66 / 256);
            *(char *)(v2 + 602) = (char)(v66 / 0x10000);
            v99 = v2;
            v127 = *(char *)(v99 + 524);
            *(char *)(v99 + 600) = (char)v66;
            v100 = v2;
            v128 = *(char *)(v100 + 526);
            *(char *)(v100 + 603) = (char)(v66 / 0x1000000);
            v129 = *(char *)(v2 + 527);
            v67 = crc32(v79, str, 0x1000000 * (int32_t)v129 | 0x10000 * (int32_t)v128 | (int32_t)v127 | 256 * (int32_t)v126);
            v75 = 0;
            v3 = a1;
            *(char *)(v2 + 528) = (char)v67;
            *(char *)(v2 + 529) = (char)(v67 / 256);
            *(char *)(v2 + 530) = (char)(v67 / 0x10000);
            *(char *)(v2 + 531) = (char)(v67 / 0x1000000);
            v76 = 0;
            v130 = v2;
            v68 = generic_mmc_write_logical(0, v75, v3, 0, v130, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
            v79 = v68;
            if (v68 == 0) {
                // 0x8f654410
                notify_user((int32_t)"Flashing backup GPT image...", v75, v3, v76, v130, v50, v49);
                *(char *)(v2 + 528) = (char)v79;
                v117 = v79;
                *(char *)(v2 + 529) = (char)v117;
                *(char *)(v2 + 530) = (char)v79;
                *(char *)(v2 + 531) = (char)v79;
                v76 = *(int32_t *)(g36 + 20);
                *(char *)(v2 + 540) = (char)v79;
                v91 = v76 - 1;
                v3 = v91;
                *(char *)(v2 + 536) = (char)v91;
                *(char *)(v2 + 537) = (char)(v3 / 256);
                v160 = v3;
                *(char *)(v2 + 539) = (char)(v160 / 0x1000000);
                v89 = v76;
                v3 = v89 - 34;
                v76 = v89 - 33;
                *(char *)(v2 + 538) = (char)(v160 / 0x10000);
                *(char *)(v2 + 560) = (char)v3;
                *(char *)(v2 + 541) = (char)v79;
                *(char *)(v2 + 561) = (char)(v3 / 256);
                *(char *)(v2 + 542) = (char)v79;
                *(char *)(v2 + 562) = (char)(v3 / 0x10000);
                *(char *)(v2 + 543) = (char)v79;
                *(char *)(v2 + 544) = (char)v77;
                *(char *)(v2 + 545) = (char)v79;
                *(char *)(v2 + 546) = (char)v79;
                *(char *)(v2 + 547) = (char)v79;
                *(char *)(v2 + 548) = (char)v79;
                *(char *)(v2 + 549) = (char)v79;
                *(char *)(v2 + 550) = (char)v79;
                *(char *)(v2 + 551) = (char)v79;
                *(char *)(v2 + 552) = (char)v78;
                *(char *)(v2 + 553) = (char)v79;
                *(char *)(v2 + 554) = (char)v79;
                *(char *)(v2 + 555) = (char)v79;
                *(char *)(v2 + 556) = (char)v79;
                *(char *)(v2 + 557) = (char)v79;
                *(char *)(v2 + 558) = (char)v79;
                *(char *)(v2 + 559) = (char)v79;
                *(char *)(v2 + 563) = (char)(v3 / 0x1000000);
                *(char *)(v2 + 585) = (char)(v76 / 256);
                *(char *)(v2 + 586) = (char)(v76 / 0x10000);
                v101 = v2;
                v131 = *(char *)(v101 + 597);
                *(char *)(v101 + 584) = (char)v76;
                *(char *)(v2 + 587) = (char)(v76 / 0x1000000);
                v102 = v2;
                v132 = *(char *)(v102 + 596);
                v133 = *(char *)(v102 + 593);
                v134 = *(char *)(v102 + 598);
                *(char *)(v102 + 564) = (char)v79;
                *(char *)(v2 + 565) = (char)v79;
                v103 = v2;
                v135 = *(char *)(v103 + 599);
                *(char *)(v103 + 566) = (char)v79;
                *(char *)(v2 + 567) = (char)v79;
                v104 = v2;
                v136 = *(char *)(v104 + 592);
                *(char *)(v104 + 588) = (char)v79;
                v105 = v2;
                v137 = *(char *)(v105 + 594);
                *(char *)(v105 + 589) = (char)v79;
                *(char *)(v2 + 590) = (char)v79;
                v106 = v2;
                v138 = *(char *)(v106 + 595);
                *(char *)(v106 + 591) = (char)v79;
                v69 = crc32(v117, v85, (0x1000000 * (int32_t)v138 | 0x10000 * (int32_t)v137 | (int32_t)v136 | 256 * (int32_t)v133) * (0x1000000 * (int32_t)v135 | 0x10000 * (int32_t)v134 | (int32_t)v132 | 256 * (int32_t)v131));
                v107 = v2;
                v139 = *(char *)(v107 + 525);
                *(char *)(v107 + 601) = (char)(v69 / 256);
                *(char *)(v2 + 602) = (char)(v69 / 0x10000);
                v108 = v2;
                v140 = *(char *)(v108 + 524);
                *(char *)(v108 + 600) = (char)v69;
                v109 = v2;
                v141 = *(char *)(v109 + 526);
                *(char *)(v109 + 603) = (char)(v69 / 0x1000000);
                v142 = *(char *)(v2 + 527);
                v70 = crc32(v79, str, 0x1000000 * (int32_t)v142 | 0x10000 * (int32_t)v141 | (int32_t)v140 | 256 * (int32_t)v139);
                v110 = v2;
                v143 = *(char *)(v110 + 537);
                v144 = *(char *)(v110 + 541);
                *(char *)(v110 + 529) = (char)(v70 / 256);
                *(char *)(v2 + 530) = (char)(v70 / 0x10000);
                v111 = v2;
                v145 = *(char *)(v111 + 536);
                *(char *)(v111 + 528) = (char)v70;
                v112 = v2;
                v146 = *(char *)(v112 + 538);
                *(char *)(v112 + 531) = (char)(v70 / 0x1000000);
                v158 = 0x10000 * (int32_t)v146 | (int32_t)v145 | 256 * (int32_t)v143;
                v113 = v2;
                v147 = *(char *)(v113 + 539);
                v148 = *(char *)(v113 + 540);
                v149 = *(char *)(v113 + 542);
                v161 = 512 * (0x10000 * (int32_t)v149 | (int32_t)v148 | 256 * (int32_t)v144) | (0x1000000 * (int32_t)v147 | v158) / 0x800000;
                v71 = generic_mmc_write_logical(512 * v158, v161, 512, 0, v10, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
                if (v71 != 0) {
                    // if_8f654600_0_true
                    // branch -> 0x8f654664
                    // 0x8f654664
                    notify_user((int32_t)"Failed to write EFI backup GPT header.\n", v161, 512, 0, v10, v50, v49);
                    // branch -> 0x8f654668
                    // 0x8f654668
                    // branch -> 0x8f65489c
                    // 0x8f65489c
                    if (v1 != g35) {
                        // 0x8f6548b0
                        __stack_chk_fail();
                        // branch -> 0x8f6548b4
                    }
                    // 0x8f6548b4
                    return -1;
                }
                // 0x8f654608
                v114 = v2;
                v150 = *(char *)(v114 + 585);
                v151 = *(char *)(v114 + 584);
                v152 = *(char *)(v114 + 589);
                v153 = *(char *)(v114 + 586);
                v159 = 0x10000 * (int32_t)v153 | (int32_t)v151 | 256 * (int32_t)v150;
                v154 = *(char *)(v114 + 587);
                v155 = *(char *)(v114 + 588);
                v156 = *(char *)(v114 + 590);
                v3 = 0x4000;
                v162 = 512 * (0x10000 * (int32_t)v156 | (int32_t)v155 | 256 * (int32_t)v152) | (0x1000000 * (int32_t)v154 | v159) / 0x800000;
                v75 = v162;
                v76 = 0;
                v72 = generic_mmc_write_logical(512 * v159, v162, 0x4000, 0, v11, v50, v49, v48, v47, 0, 0, v57, v13, v84, v10, v11, v83, a1, str2, 0x54524150, 0, str3, 0, 0, 0, 0, 0, 0);
                if (v72 == 0) {
                    // 0x8f654670
                    init_gpt(0, v75, v3, v76, v11, v50, v49, v48, v47, 0, 0);
                    v86 = g33;
                    v87 = (int32_t)v86;
                    if (v86 != (char *)&g32) {
                        // 0x8f654694
                        v80 = v87;
                        v115 = v87;
                        v60 = v50;
                        v61 = v49;
                        v62 = v48;
                        v63 = v47;
                        v58 = v13;
                        v59 = v11;
                        // branch -> 0x8f654694
                        while (true) {
                            // 0x8f654694
                            v64 = (int32_t *)v115;
                            v163 = *(int32_t *)(v115 + 4);
                            v81 = *(int32_t *)(v115 + 8);
                            v2 = *(int32_t *)(v115 + 12);
                            *(int32_t *)v163 = *v64;
                            v157 = *(int32_t *)v80;
                            *(int32_t *)(v157 + 4) = v163;
                            *(int32_t *)(v80 + 4) = 0;
                            v79 = v115 + 16;
                            *v64 = 0;
                            v73 = get_partition_by_name(v79, 0, v157, v163, v59, v60, v61, v62, v63, 0, 0);
                            v65 = (int32_t)v73;
                            notify_user((int32_t)"restoring %s", v79, v157, v65, v59, v60, v61);
                            v76 = v65;
                            if (v73 == NULL) {
                                goto lab_0x8f6546e4;
                            }
                            goto lab_0x8f6546fc;
                        }
                    }
                    // 0x8f654890
                    v74 = 0;
                    *(char *)&g28 = 0;
                    v82 = 0;
                    // branch -> 0x8f65489c
                } else {
                    // 0x8f654660
                    // branch -> 0x8f654664
                    // 0x8f654664
                    notify_user((int32_t)"Failed to write EFI backup GPT entries.\n", v75, v3, v76, v11, v50, v49);
                    // branch -> 0x8f654668
                    // 0x8f654668
                    v74 = -1;
                    v82 = -1;
                    // branch -> 0x8f65489c
                }
                // 0x8f65489c
                if (v1 != g35) {
                    // 0x8f6548b0
                    __stack_chk_fail();
                    result = v74;
                    // branch -> 0x8f6548b4
                } else {
                    result = v82;
                }
                // 0x8f6548b4
                return result;
            }
            // if_8f654408_0_true
            // branch -> 0x8f654664
            // 0x8f654664
            notify_user((int32_t)"Failed to write primary GPT.\n", v75, v3, v76, v130, v50, v49);
            // branch -> 0x8f654668
        }
    } else {
        // 0x8f653cf0
        print_log(0, (int32_t)"Invalid number of partitions: %d\n", v22, v21, v9, v8, v7, v16, v15, 0, 0, v14, v13);
        // branch -> 0x8f654668
    }
    // 0x8f654668
    // branch -> 0x8f65489c
    // 0x8f65489c
    if (v1 != g35) {
        // 0x8f6548b0
        __stack_chk_fail();
        // branch -> 0x8f6548b4
    }
    // 0x8f6548b4
    return -1;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// uLong crc32(uLong crc, const Bytef * buf, uInt len);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:00:15
