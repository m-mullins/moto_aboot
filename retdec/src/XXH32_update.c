//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t fboot_cmd_flash_name_mangle(int32_t a1, int32_t a2);
int32_t fdt_get_alias_namelen(char * a1, int32_t a2, int32_t a3);
int32_t fdt_getprop(int32_t a1, int32_t a2, char * str);
int32_t fdt_next_tag(int32_t a1, int32_t a2, int32_t * a3);
int32_t font_draw_char_moto_horizontal(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t font_set_type(char * str, int32_t a2, int32_t a3);
int32_t get_code128_checksum(char * str, int32_t a2, int32_t a3);
int32_t get_num_of_sims(char * a1, int32_t a2, int32_t a3);
int32_t get_sku(char * a1, int32_t a2);
int32_t get_termination_code128(int32_t a1, int32_t a2, int32_t a3);
int32_t gpio_set_value(uint32_t a1, int32_t a2, int32_t a3);
int32_t gpio_status(int32_t a1, int32_t a2, int32_t a3);
int32_t is_fastboot_screen(int32_t a1, int32_t a2, int32_t a3);
int32_t lines(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_multi_multiply(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_multi_shift_left(int32_t * a1, int32_t a2, uint32_t a3);
int32_t nexus_usbpidvid(int32_t a1, int32_t a2);
int32_t pmic_get_extra_reset_info(int32_t a1, int32_t a2);
int32_t secure_allow_console(int32_t a1, int32_t a2);
int32_t set_flash_fail(void);
int32_t set_show_battery_fn(char * a1, int32_t a2, int32_t a3);
int32_t show_fastboot_menu(int32_t a1, int32_t a2);
void thread_become_idle(int32_t a1, int32_t a2, int32_t a3);
int32_t timer_cancel(int32_t result, int32_t a2);
int32_t timer_set_periodic(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t type_atoi_11(char * str, int32_t a2, int32_t a3);
int32_t wait_queue_init(int32_t * a1, int32_t a2);
int32_t XXH32_init(char * a1, int32_t a2);
int32_t XXH32_update(char * a1, char * a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g15 = 0; // R2
int32_t g16 = 0; // R4
int32_t g17 = 0; // R5
int32_t g18 = 0; // R6
int32_t g19 = 0; // R7
int32_t g20 = 0; // R8
int32_t g21 = 0; // R9
int32_t g1 = -0x16d2bfc9; // 0x8f638578
int32_t g2 = 0; // 0x8f69eef0
int32_t g3 = 0x66c06cc; // 0x8f6a28d8
char * g4 = "\x01"; // 0x8f6a3f48
int32_t g6 = 0x10100; // 0x8f6a9f58
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = -1; // 0x8f6ac214
int32_t g9 = 0; // 0x8f6e0850
int32_t g10 = 0; // 0x8f6e09b0
int32_t g11 = 0; // 0x8f6e09b4
int32_t g12 = 0; // 0x8f7112f4
int32_t g13 = 0; // 0x8f7114a8
int32_t g14 = 0; // 0x8f7114ac
int32_t * g5 = &g2; // 0x8f6a9eec

// ------------------------ Functions -------------------------

// Address range: 0x8f658c74 - 0x8f65912b
int32_t XXH32_update(char * a1, char * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1; // 0x8f658c74_0
    int32_t v2 = (int32_t)a2;
    int32_t v3 = g12;
    int32_t v4 = v2; // R9
    int32_t v5 = v2 + a3; // R10
    int32_t * v6 = (int32_t *)(v1 + 4); // 0x8f658c94_1
    uint32_t v7 = *(int32_t *)a1 + a3; // 0x8f658cb0
    *(int32_t *)a1 = v7;
    *v6 = *v6 + (a3 >> 31) + (int32_t)(v7 < a3);
    int32_t v8 = *(int32_t *)(v1 + 28); // 0x8f658cbc
    int32_t v9 = v8 + a3; // 0x8f658cbc
    int32_t * v10; // 0x8f658ebc_0
    int32_t v11; // R0
    int32_t v12; // R12
    int32_t v13; // R1
    int32_t v14; // R2
    int32_t v15; // R3
    int32_t v16; // 0x8f658dbc
    int32_t v17; // 0x8f6590e8
    int32_t v18; // 0x8f6590e0
    if (*(char *)&g4 == 1) {
        // 0x8f658cac
        if (v9 < 16) {
            // 0x8f658eb0
            memcpy((char *)(v8 + 32 + v1), a2, a3);
            v10 = (int32_t *)(v1 + 28);
            *v10 = a3 + *v10;
            // branch -> 0x8f6590f8
            // 0x8f6590f8
            if (v3 != g12) {
                // 0x8f659110
                __stack_chk_fail();
                // branch -> 0x8f659114
            }
            // 0x8f659114
            return 0;
        }
        // 0x8f658cc8
        if (v8 != 0) {
            // 0x8f658cd0
            memcpy((char *)(v8 + 32 + v1), a2, 16 - v8);
            char v19 = *(char *)(v1 + 33); // 0x8f658ce0
            char v20 = *(char *)(v1 + 32); // 0x8f658ce4
            v14 = -0x7a143589;
            char v21 = *(char *)(v1 + 34); // 0x8f658cf0
            char v22 = *(char *)(v1 + 37); // 0x8f658cf4
            char v23 = *(char *)(v1 + 35); // 0x8f658cfc
            int32_t * v24 = (int32_t *)(v1 + 12); // 0x8f658d04_0
            int32_t v25 = *v24; // 0x8f658d04
            uint32_t v26 = v25 + -0x7a143589 * (0x1000000 * (int32_t)v23 | 0x10000 * (int32_t)v21 | (int32_t)v20 | 256 * (int32_t)v19); // 0x8f658d0824
            v15 = -0x61c8864f;
            *v24 = -0x61c8864f * (0x2000 * v26 | v26 / 0x80000);
            char v27 = *(char *)(v1 + 36); // 0x8f658d1c
            char v28 = *(char *)(v1 + 38); // 0x8f658d24
            char v29 = *(char *)(v1 + 39); // 0x8f658d2c
            int32_t * v30 = (int32_t *)(v1 + 16); // 0x8f658d34_0
            int32_t v31 = *v30; // 0x8f658d34
            uint32_t v32 = (0x1000000 * (int32_t)v29 | 0x10000 * (int32_t)v28 | (int32_t)v27 | 256 * (int32_t)v22) * v14 + v31; // 0x8f658d38
            char v33 = *(char *)(v1 + 41); // 0x8f658d3c
            *v30 = (0x2000 * v32 | v32 / 0x80000) * v15;
            char v34 = *(char *)(v1 + 40); // 0x8f658d4c
            char v35 = *(char *)(v1 + 42); // 0x8f658d54
            char v36 = *(char *)(v1 + 43); // 0x8f658d5c
            int32_t * v37 = (int32_t *)(v1 + 20); // 0x8f658d64_0
            int32_t v38 = *v37; // 0x8f658d64
            uint32_t v39 = (0x1000000 * (int32_t)v36 | 0x10000 * (int32_t)v35 | (int32_t)v34 | 256 * (int32_t)v33) * v14 + v38; // 0x8f658d68
            char v40 = *(char *)(v1 + 45); // 0x8f658d6c
            *v37 = (0x2000 * v39 | v39 / 0x80000) * v15;
            char v41 = *(char *)(v1 + 44); // 0x8f658d7c
            char v42 = *(char *)(v1 + 46); // 0x8f658d84
            char v43 = *(char *)(v1 + 47); // 0x8f658d8c
            int32_t * v44 = (int32_t *)(v1 + 24); // 0x8f658d94_0
            int32_t v45 = *v44; // 0x8f658d94
            uint32_t v46 = (0x1000000 * (int32_t)v43 | 0x10000 * (int32_t)v42 | (int32_t)v41 | 256 * (int32_t)v40) * v14 + v45; // 0x8f658d98
            *v44 = (0x2000 * v46 | v46 / 0x80000) * v15;
            int32_t * v47 = (int32_t *)(v1 + 28); // 0x8f658da8_0
            v4 += 16 - *v47;
            *v47 = 0;
            // branch -> 0x8f658dbc
        }
        // 0x8f658dbc
        v16 = v5;
        int32_t v48 = v16 - 16; // 0x8f658dbc
        v17 = v4;
        if (v4 <= v48) {
            // 0x8f658dc8
            v12 = *(int32_t *)(v1 + 20);
            v11 = *(int32_t *)(v1 + 24);
            v13 = -0x7a143589;
            v14 = -0x61c8864f;
            int32_t v49 = *(int32_t *)(v1 + 16); // 0x8f658e30
            int32_t v50 = *(int32_t *)(v1 + 12); // 0x8f658e08
            int32_t v51 = -0x7a143589; // 0x8f658e30
            int32_t v52 = v4; // 0x8f658de4
            char v53 = *(char *)(v52 + 1); // 0x8f658de4
            char v54 = *(char *)v52; // 0x8f658dec
            char v55 = *(char *)(v52 + 2); // 0x8f658df4
            char v56 = *(char *)(v52 + 3); // 0x8f658dfc
            char v57 = *(char *)(v52 + 5); // 0x8f658e04
            uint32_t v58 = (0x1000000 * (int32_t)v56 | 0x10000 * (int32_t)v55 | (int32_t)v54 | 256 * (int32_t)v53) * v51 + v50; // 0x8f658e08
            char v59 = *(char *)(v52 + 4); // 0x8f658e0c
            char v60 = *(char *)(v52 + 6); // 0x8f658e14
            char v61 = *(char *)(v52 + 7); // 0x8f658e1c
            char v62 = *(char *)(v52 + 9); // 0x8f658e28
            int32_t v63 = -0x61c8864f * (0x2000 * v58 | v58 / 0x80000); // 0x8f658e2c
            uint32_t v64 = (0x1000000 * (int32_t)v61 | 0x10000 * (int32_t)v60 | (int32_t)v59 | 256 * (int32_t)v57) * v51 + v49; // 0x8f658e30
            char v65 = *(char *)(v52 + 8); // 0x8f658e34
            char v66 = *(char *)(v52 + 10); // 0x8f658e3c
            char v67 = *(char *)(v52 + 11); // 0x8f658e44
            char v68 = *(char *)(v52 + 13); // 0x8f658e50
            int32_t v69 = (0x2000 * v64 | v64 / 0x80000) * v14; // 0x8f658e54
            uint32_t v70 = v12 + v13 * (0x1000000 * (int32_t)v67 | 0x10000 * (int32_t)v66 | (int32_t)v65 | 256 * (int32_t)v62); // 0x8f658e58
            int32_t v71 = v52 + 16; // 0x8f658e5c
            char v72 = *(char *)(v71 - 4); // 0x8f658e5c
            char v73 = *(char *)(v71 - 2); // 0x8f658e64
            char v74 = *(char *)(v71 - 1); // 0x8f658e6c
            v12 = (0x2000 * v70 | v70 / 0x80000) * v14;
            uint32_t v75 = (0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v72 | 256 * (int32_t)v68) * v13 + v11; // 0x8f658e80
            v11 = (0x2000 * v75 | v75 / 0x80000) * v14;
            // branch -> 0x8f658de4
            while (v71 <= v48) {
                // 0x8f658de4
                v51 = v13;
                v52 = v71;
                v53 = *(char *)(v52 + 1);
                v54 = *(char *)v52;
                v55 = *(char *)(v52 + 2);
                v56 = *(char *)(v52 + 3);
                v57 = *(char *)(v52 + 5);
                v58 = (0x1000000 * (int32_t)v56 | 0x10000 * (int32_t)v55 | (int32_t)v54 | 256 * (int32_t)v53) * v51 + v63;
                v59 = *(char *)(v52 + 4);
                v60 = *(char *)(v52 + 6);
                v61 = *(char *)(v52 + 7);
                v62 = *(char *)(v52 + 9);
                v63 = (0x2000 * v58 | v58 / 0x80000) * v14;
                v64 = (0x1000000 * (int32_t)v61 | 0x10000 * (int32_t)v60 | (int32_t)v59 | 256 * (int32_t)v57) * v51 + v69;
                v65 = *(char *)(v52 + 8);
                v66 = *(char *)(v52 + 10);
                v67 = *(char *)(v52 + 11);
                v68 = *(char *)(v52 + 13);
                v69 = (0x2000 * v64 | v64 / 0x80000) * v14;
                v70 = v12 + v13 * (0x1000000 * (int32_t)v67 | 0x10000 * (int32_t)v66 | (int32_t)v65 | 256 * (int32_t)v62);
                v71 = v52 + 16;
                v72 = *(char *)(v71 - 4);
                v73 = *(char *)(v71 - 2);
                v74 = *(char *)(v71 - 1);
                v12 = (0x2000 * v70 | v70 / 0x80000) * v14;
                v75 = (0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v72 | 256 * (int32_t)v68) * v13 + v11;
                v11 = (0x2000 * v75 | v75 / 0x80000) * v14;
                // continue -> 0x8f658de4
            }
            // 0x8f6590b4
            *(int32_t *)(v1 + 12) = v63;
            *(int32_t *)(v1 + 16) = v69;
            *(int32_t *)(v1 + 20) = v12;
            *(int32_t *)(v1 + 24) = v11;
            v17 = v4 + (v5 - v4 & -16);
            v16 = v5;
            // branch -> 0x8f6590d8
        }
        // 0x8f6590d8
        if (v16 <= v17) {
            // 0x8f6590e0
            v18 = v16 - v17;
            memcpy((char *)(v1 + 32), (char *)v17, v18);
            *(int32_t *)(v1 + 28) = v18;
            // branch -> 0x8f6590f8
        }
        // 0x8f6590f8
        if (v3 != g12) {
            // 0x8f659110
            __stack_chk_fail();
            // branch -> 0x8f659114
        }
        // 0x8f659114
        return 0;
    }
    // 0x8f658e94
    if (v9 > 15) {
        // 0x8f658ecc
        if (v8 != 0) {
            // 0x8f658ed4
            memcpy((char *)(v8 + 32 + v1), a2, 16 - v8);
            char v76 = *(char *)(v1 + 33); // 0x8f658ee4
            char v77 = *(char *)(v1 + 32); // 0x8f658ee8
            v14 = -0x7a143589;
            char v78 = *(char *)(v1 + 34); // 0x8f658ef4
            char v79 = *(char *)(v1 + 37); // 0x8f658ef8
            char v80 = *(char *)(v1 + 35); // 0x8f658f00
            int32_t * v81 = (int32_t *)(v1 + 12); // 0x8f658f08_0
            int32_t v82 = *v81; // 0x8f658f08
            uint32_t v83 = v82 + -0x7a143589 * llvm_bswap_i32(0x1000000 * (int32_t)v80 | 0x10000 * (int32_t)v78 | (int32_t)v77 | 256 * (int32_t)v76); // 0x8f658f1025
            v15 = -0x61c8864f;
            *v81 = -0x61c8864f * (0x2000 * v83 | v83 / 0x80000);
            char v84 = *(char *)(v1 + 36); // 0x8f658f24
            char v85 = *(char *)(v1 + 38); // 0x8f658f2c
            char v86 = *(char *)(v1 + 39); // 0x8f658f34
            int32_t * v87 = (int32_t *)(v1 + 16); // 0x8f658f3c_0
            int32_t v88 = *v87; // 0x8f658f3c
            uint32_t v89 = v14 * llvm_bswap_i32(0x1000000 * (int32_t)v86 | 0x10000 * (int32_t)v85 | (int32_t)v84 | 256 * (int32_t)v79) + v88; // 0x8f658f44
            char v90 = *(char *)(v1 + 41); // 0x8f658f48
            *v87 = (0x2000 * v89 | v89 / 0x80000) * v15;
            char v91 = *(char *)(v1 + 40); // 0x8f658f58
            char v92 = *(char *)(v1 + 42); // 0x8f658f60
            char v93 = *(char *)(v1 + 43); // 0x8f658f68
            int32_t * v94 = (int32_t *)(v1 + 20); // 0x8f658f70_0
            int32_t v95 = *v94; // 0x8f658f70
            uint32_t v96 = v14 * llvm_bswap_i32(0x1000000 * (int32_t)v93 | 0x10000 * (int32_t)v92 | (int32_t)v91 | 256 * (int32_t)v90) + v95; // 0x8f658f78
            char v97 = *(char *)(v1 + 45); // 0x8f658f7c
            *v94 = (0x2000 * v96 | v96 / 0x80000) * v15;
            char v98 = *(char *)(v1 + 44); // 0x8f658f8c
            char v99 = *(char *)(v1 + 46); // 0x8f658f94
            char v100 = *(char *)(v1 + 47); // 0x8f658f9c
            int32_t * v101 = (int32_t *)(v1 + 24); // 0x8f658fa4_0
            int32_t v102 = *v101; // 0x8f658fa4
            uint32_t v103 = v14 * llvm_bswap_i32(0x1000000 * (int32_t)v100 | 0x10000 * (int32_t)v99 | (int32_t)v98 | 256 * (int32_t)v97) + v102; // 0x8f658fac
            *v101 = (0x2000 * v103 | v103 / 0x80000) * v15;
            int32_t * v104 = (int32_t *)(v1 + 28); // 0x8f658fbc_0
            v4 += 16 - *v104;
            *v104 = 0;
            // branch -> 0x8f658fd0
        }
        int32_t v105 = v5 - 16; // 0x8f658fd0
        v17 = v4;
        v16 = v5;
        if (v4 <= v105) {
            // 0x8f658fdc
            v12 = *(int32_t *)(v1 + 20);
            v11 = *(int32_t *)(v1 + 24);
            v13 = -0x7a143589;
            v14 = -0x61c8864f;
            int32_t v106 = *(int32_t *)(v1 + 16); // 0x8f65904c
            int32_t v107 = *(int32_t *)(v1 + 12); // 0x8f659020
            int32_t v108 = -0x7a143589; // 0x8f65904c
            int32_t v109 = v4; // 0x8f658ff8
            char v110 = *(char *)(v109 + 1); // 0x8f658ff8
            char v111 = *(char *)v109; // 0x8f659000
            char v112 = *(char *)(v109 + 2); // 0x8f659008
            char v113 = *(char *)(v109 + 3); // 0x8f659010
            char v114 = *(char *)(v109 + 5); // 0x8f659018
            uint32_t v115 = llvm_bswap_i32(0x1000000 * (int32_t)v113 | 0x10000 * (int32_t)v112 | (int32_t)v111 | 256 * (int32_t)v110) * v108 + v107; // 0x8f659020
            char v116 = *(char *)(v109 + 4); // 0x8f659024
            char v117 = *(char *)(v109 + 6); // 0x8f65902c
            char v118 = *(char *)(v109 + 7); // 0x8f659034
            char v119 = *(char *)(v109 + 9); // 0x8f659040
            int32_t v120 = -0x61c8864f * (0x2000 * v115 | v115 / 0x80000); // 0x8f659048
            uint32_t v121 = llvm_bswap_i32(0x1000000 * (int32_t)v118 | 0x10000 * (int32_t)v117 | (int32_t)v116 | 256 * (int32_t)v114) * v108 + v106; // 0x8f65904c
            char v122 = *(char *)(v109 + 8); // 0x8f659050
            char v123 = *(char *)(v109 + 10); // 0x8f659058
            char v124 = *(char *)(v109 + 11); // 0x8f659060
            char v125 = *(char *)(v109 + 13); // 0x8f65906c
            int32_t v126 = v14 * (0x2000 * v121 | v121 / 0x80000); // 0x8f659074
            uint32_t v127 = v12 + v13 * llvm_bswap_i32(0x1000000 * (int32_t)v124 | 0x10000 * (int32_t)v123 | (int32_t)v122 | 256 * (int32_t)v119); // 0x8f659078
            int32_t v128 = v109 + 16; // 0x8f65907c
            char v129 = *(char *)(v128 - 4); // 0x8f65907c
            char v130 = *(char *)(v128 - 2); // 0x8f659084
            char v131 = *(char *)(v128 - 1); // 0x8f65908c
            v12 = (0x2000 * v127 | v127 / 0x80000) * v14;
            uint32_t v132 = v11 + llvm_bswap_i32(0x1000000 * (int32_t)v131 | 0x10000 * (int32_t)v130 | (int32_t)v129 | 256 * (int32_t)v125) * v13; // 0x8f6590a4
            v11 = (0x2000 * v132 | v132 / 0x80000) * v14;
            // branch -> 0x8f658ff8
            while (v128 <= v105) {
                // 0x8f658ff8
                v108 = v13;
                v109 = v128;
                v110 = *(char *)(v109 + 1);
                v111 = *(char *)v109;
                v112 = *(char *)(v109 + 2);
                v113 = *(char *)(v109 + 3);
                v114 = *(char *)(v109 + 5);
                v115 = llvm_bswap_i32(0x1000000 * (int32_t)v113 | 0x10000 * (int32_t)v112 | (int32_t)v111 | 256 * (int32_t)v110) * v108 + v120;
                v116 = *(char *)(v109 + 4);
                v117 = *(char *)(v109 + 6);
                v118 = *(char *)(v109 + 7);
                v119 = *(char *)(v109 + 9);
                v120 = (0x2000 * v115 | v115 / 0x80000) * v14;
                v121 = llvm_bswap_i32(0x1000000 * (int32_t)v118 | 0x10000 * (int32_t)v117 | (int32_t)v116 | 256 * (int32_t)v114) * v108 + v126;
                v122 = *(char *)(v109 + 8);
                v123 = *(char *)(v109 + 10);
                v124 = *(char *)(v109 + 11);
                v125 = *(char *)(v109 + 13);
                v126 = v14 * (0x2000 * v121 | v121 / 0x80000);
                v127 = v12 + v13 * llvm_bswap_i32(0x1000000 * (int32_t)v124 | 0x10000 * (int32_t)v123 | (int32_t)v122 | 256 * (int32_t)v119);
                v128 = v109 + 16;
                v129 = *(char *)(v128 - 4);
                v130 = *(char *)(v128 - 2);
                v131 = *(char *)(v128 - 1);
                v12 = (0x2000 * v127 | v127 / 0x80000) * v14;
                v132 = v11 + llvm_bswap_i32(0x1000000 * (int32_t)v131 | 0x10000 * (int32_t)v130 | (int32_t)v129 | 256 * (int32_t)v125) * v13;
                v11 = (0x2000 * v132 | v132 / 0x80000) * v14;
                // continue -> 0x8f658ff8
            }
            // 0x8f6590b4
            *(int32_t *)(v1 + 12) = v120;
            *(int32_t *)(v1 + 16) = v126;
            *(int32_t *)(v1 + 20) = v12;
            *(int32_t *)(v1 + 24) = v11;
            v17 = v4 + (v5 - v4 & -16);
            v16 = v5;
            // branch -> 0x8f6590d8
        }
        // 0x8f6590d8
        if (v16 <= v17) {
            // 0x8f6590e0
            v18 = v16 - v17;
            memcpy((char *)(v1 + 32), (char *)v17, v18);
            *(int32_t *)(v1 + 28) = v18;
            // branch -> 0x8f6590f8
        }
        // 0x8f6590f8
        if (v3 != g12) {
            // 0x8f659110
            __stack_chk_fail();
            // branch -> 0x8f659114
        }
        // 0x8f659114
        return 0;
    }
    // 0x8f658eb0
    memcpy((char *)(v8 + 32 + v1), a2, a3);
    v10 = (int32_t *)(v1 + 28);
    *v10 = a3 + *v10;
    // branch -> 0x8f6590f8
    // 0x8f6590f8
    if (v3 != g12) {
        // 0x8f659110
        __stack_chk_fail();
        // branch -> 0x8f659114
    }
    // 0x8f659114
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:10:18
