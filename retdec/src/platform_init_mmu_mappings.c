//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __aeabi_unwind_cpp_pr0(int32_t a1, int32_t a2, int32_t a3);
int32_t backlight_turn_off(int32_t a1, int32_t a2, int32_t a3);
int32_t clock_lib2_branch_clk_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t cxo_clk_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t display_turn_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t fastboot_init(int32_t a1, int32_t a2);
void function_8f64a048(void);
void function_8f64a088(int32_t a1, int32_t a2, int32_t a3);
void function_8f64ac04(void);
void function_8f64afa0(void);
void function_8f64b000(char * a1, uint32_t a2, int32_t a3);
void function_8f64b470(void);
void function_8f64b4dc(int32_t a1, int32_t a2, int32_t a3);
int32_t get_security_code(void);
int32_t handle_fboot_command_reboot_bl(int32_t a1, int32_t a2);
int32_t is_factory_product(int32_t a1, int32_t a2);
int32_t mcs_habp_rsa_large_window(int32_t a1);
int32_t mcs_habp_rsa_med_window(int32_t a1);
int32_t mcs_X509Certificate_finalize(int32_t a1, int32_t a2);
int32_t mcs_X509Certificate_getSignature(int32_t a1, int32_t * a2);
int32_t mcs_X509Certificate_getSignedData(int32_t a1, int32_t * a2);
int32_t mipi_init(int32_t a1, int32_t a2);
int32_t mipi_uninit(int32_t a1);
int32_t mutex_acquire(int32_t a1, int32_t a2);
int32_t mutex_init(int32_t * a1, int32_t a2, int32_t a3);
int32_t platform_init_mmu_mappings(void);
int32_t platform_use_identity_mmu_mappings(int32_t a1);
int32_t smb1359_config_for_fact_cbl(void);
int32_t smb1359_drop_usbin_rate(void);

// --------------------- Global Variables ---------------------

int32_t g15 = 0; // LR
int32_t g16 = 0; // R0
int32_t g17 = 0; // R1
int32_t g18 = 0; // R2
int32_t g19 = 0; // R3
int32_t g20 = 0; // R4
int32_t g21 = 0; // R5
int32_t g22 = 0; // R6
char * g1; // 0x8f610c40
int32_t g2 = -0x1a60cd88; // 0x8f621660
int32_t g3 = 8; // 0x8f67c624
int32_t g4 = 1; // 0x8f6ac0f0
char * g5; // 0x8f6ac1b8
int32_t g6 = 2; // 0x8f6afe0c
int32_t g7 = 2; // 0x8f6afe14
int32_t g8 = 0; // 0x8f6c0398
int32_t g9 = 0; // 0x8f6c03d8
int32_t g10 = 0; // 0x8f6e0c3c
int32_t g11 = 0; // 0x8f7112f4
int32_t g12 = 0; // 0x8f7114ac
char * g13; // 0x8f7114fc
int32_t g14 = 0; // 0x8f711500

// ------------------------ Functions -------------------------

// Address range: 0x8f601b84 - 0x8f601d17
int32_t platform_init_mmu_mappings(void) {
    int32_t v1 = g11;
    int32_t v2 = v1; // R3
    int32_t v3;
    int32_t v4 = smem_ram_ptable_init_v1(g16, g17, g18, v1, v3, 0); // 0x8f601b9c
    int32_t v5 = v4; // 0x8f601bc4
    if (v4 == 0) {
        // 0x8f601ba8
        g18 = (int32_t)"platform/msm8916/platform.c";
        v2 = 174;
        v5 = _panic(g15, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm8916/platform.c", 174, (int32_t)"smem_ram_ptable_init_v1()", 0, 0);
        // branch -> 0x8f601bc4
    }
    int32_t v6 = smem_get_ram_ptable_len(v5, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", g18, v2); // 0x8f601bc4
    g16 = v6;
    int32_t v7 = 0xfffff; // R4
    int32_t v8 = 0; // R6
    int32_t v9 = 0; // R5
    int32_t v10 = v6; // R9
    int32_t v11 = 0; // bp+230
    int32_t v12; // bp+228
    int32_t v13; // bp+229
    int32_t v14; // 0x8f601cbc
    int32_t v15; // 0x8f601c98
    int32_t v16; // 0x8f601cb8
    int32_t v17; // 0x8f601cd8
    int32_t v18; // 0x8f601cd825
    int32_t v19; // 0x8f601c98
    if (v6 != 0) {
        // 0x8f601be0
        int32_t v20;
        int32_t v21 = &v20; // 0x8f601be0_0
        int32_t v22;
        uint32_t v23;
        int32_t v24 = 0x1000 * v22 | v23 / 0x100000; // 0x8f601c4c
        int32_t v25 = v24 + 4095; // 0x8f601c54
        int32_t v26;
        int32_t v27 = v26 & -0x10000 | 3096; // 0x8f601c74
        int32_t v28 = 0; // 0x8f601be4
        // branch -> 0x8f601be0
        int32_t v29; // bp+231
        while (true) {
            int32_t v30 = (int32_t)smem_get_ram_ptable_entry(v21, v28, g18, v2); // 0x8f601be8_5
            g16 = v30;
            int32_t v31; // 0x8f601be815
            int32_t v32;
            int32_t v33; // 0x8f601c88
            if (v32 == 1) {
                // 0x8f601bf8
                v29 = v30;
                int32_t v34;
                v31 = v34;
                int32_t v35; // bp+233
                int32_t v36;
                int32_t v37; // 0x8f601c10
                switch (v34) {
                    case 14: {
                        // 0x8f601c08
                        v37 = v7 & v26;
                        g18 = v37;
                        v35 = v30;
                        if (v37 != (v9 & v36)) {
                          lab_0x8f601c20:
                            // 0x8f601c20
                            g18 = (int32_t)"platform/msm8916/platform.c";
                            int32_t v38 = _panic(g15, (int32_t)"ASSERT FAILED at (%s:%d): %s\n", (int32_t)"platform/msm8916/platform.c", 189, (int32_t)"(ptn_entry.start & (MB-1)) == 0", 0, 0); // 0x8f601c38
                            g16 = v38;
                            v35 = v38;
                            // branch -> 0x8f601c3c
                        }
                      lab_0x8f601c3c:
                        // 0x8f601c3c
                        if (v24 != 0) {
                            int32_t v39 = 0; // 0x8f601c60
                            while (true) {
                                int32_t v40 = 0x100000 * (v25 - v39) + v26; // 0x8f601c70
                                g18 = v27;
                                int32_t v41 = arm_mmu_map_section(v40, v40, v27, v25); // 0x8f601c7c
                                g16 = v41;
                                int32_t v42 = v39 + 1; // 0x8f601c58
                                if (v24 == v42) {
                                    v29 = v41;
                                    v31 = v25;
                                    // break (via goto) -> 0x8f601c88
                                    goto lab_0x8f601c88;
                                }
                                v39 = v42;
                                // continue -> 0x8f601c60
                            }
                            int32_t v43 = v8; // 0x8f601c88
                            v33 = v43 + 1;
                            v8 = v33;
                            int32_t v44 = v10; // 0x8f601bd8
                            if (v33 == v44) {
                                v11 = v29;
                                // break (via goto) -> 0x8f601c90
                                goto lab_0x8f601c90_2;
                            }
                            v2 = v31;
                            v28 = v33;
                            // continue -> 0x8f601be0
                            continue;
                        } else {
                            v29 = v35;
                            v31 = v25;
                        }
                        break;
                    }
                    case 5: {
                        // 0x8f601c08
                        v37 = v7 & v26;
                        g18 = v37;
                        if (v37 == (v9 & v36)) {
                            v35 = v30;
                            goto lab_0x8f601c3c;
                        }
                        goto lab_0x8f601c20;
                    }
                }
                // 0x8f601c88
                v33 = v8 + 1;
                v8 = v33;
                if (v33 == v10) {
                    v11 = v29;
                    // break (via goto) -> 0x8f601c90
                    goto lab_0x8f601c90_2;
                }
                v2 = v31;
                v28 = v33;
                // continue -> 0x8f601be0
                continue;
            } else {
                v29 = v30;
                v31 = v32;
              lab_0x8f601c88:
                // 0x8f601c88
                v33 = v8 + 1;
                v8 = v33;
                if (v33 == v10) {
                    // break -> 0x8f601c90
                    break;
                }
                v2 = v31;
                v28 = v33;
                // continue -> 0x8f601be0
                continue;
            }
        }
        // 0x8f601c90
        v7 = &g3;
        v13 = v29;
        v18 = (int32_t)"_init()\n";
        v15 = &g3;
        // branch -> 0x8f601c98
        int32_t result; // 0x8f601cf8_2
        while (true) {
            // 0x8f601c98
            v19 = *(int32_t *)v15;
            v12 = v13;
            v17 = v18;
            int32_t v45; // 0x8f601cd4
            if (v19 != 0) {
                v16 = v15;
                v14 = 0;
              lab_0x8f601cb0:
                while (true) {
                    int32_t v46 = *(int32_t *)(v16 - 8); // 0x8f601cb4
                    int32_t v47 = *(int32_t *)(v16 - 4); // 0x8f601cb4
                    int32_t v48 = *(int32_t *)(v16 + 4); // 0x8f601cb8
                    int32_t v49 = 0x100000 * (v19 + 4095 - v14); // 0x8f601cc0
                    int32_t v50 = arm_mmu_map_section(v49 + v46, v47 + v49, v48, v49); // 0x8f601ccc
                    g16 = v50;
                    int32_t v51 = v14 + 1; // 0x8f601ca8
                    if (v51 == v19) {
                        // 0x8f601ca8
                        v12 = v50;
                        v17 = (int32_t)"_init()\n";
                        // branch -> 0x8f601cd4
                        // 0x8f601cd4
                        v45 = v7 + 16;
                        v7 = v45;
                        if (v45 == v17) {
                            // break (via goto) -> 0x8f601ce0
                            goto lab_0x8f601ce0;
                        }
                        v13 = v12;
                        v18 = v17;
                        v15 = v45;
                        // continue (via goto) -> 0x8f601c98
                        goto lab_0x8f601c98;
                    } else {
                        // 0x8f601cb0
                        v16 = v7;
                        v14 = v51;
                        // branch -> 0x8f601cb0
                        continue;
                    }
                }
                int32_t v52 = g11;
                if (v1 != v52) {
                    // 0x8f601cf0
                    __stack_chk_fail();
                    int32_t v53 = g16;
                    result = v53;
                    // branch -> 0x8f601cf4
                } else {
                    result = v12;
                }
                // 0x8f601cf4
                return result;
            }
          lab_0x8f601cd4:
            // 0x8f601cd4
            v45 = v15 + 16;
            v7 = v45;
            if (v45 == v17) {
                // break -> 0x8f601ce0
                break;
            }
            v13 = v12;
            v18 = v17;
            v15 = v45;
            // continue -> 0x8f601c98
        }
      lab_0x8f601ce0:
        // 0x8f601ce0
        if (v1 != g11) {
            // 0x8f601cf0
            __stack_chk_fail();
            result = g16;
            // branch -> 0x8f601cf4
        } else {
            result = v12;
        }
        // 0x8f601cf4
        return result;
    }
  lab_0x8f601c90_2:
    // 0x8f601c90
    v7 = &g3;
    v13 = v11;
    v18 = (int32_t)"_init()\n";
    v15 = &g3;
    // branch -> 0x8f601c98
  lab_0x8f601c98:
    while (true) {
        // 0x8f601c98
        v19 = *(int32_t *)v15;
        if (v19 == 0) {
            v12 = v13;
            v17 = v18;
            goto lab_0x8f601cd4;
        }
        v16 = v15;
        v14 = 0;
        goto lab_0x8f601cb0;
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * memset(void * s, int c, size_t n);
// int tolower(int c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:12:28
