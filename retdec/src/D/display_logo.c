//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t connect_to_key(int32_t a1);
int32_t display_logo(int32_t a1, int32_t a2);
int32_t fan54046_get_ibuslim(int32_t a1);
int32_t fan540xx_get_ic_info_pn(void);
int32_t fboot_cmd_erase_validate(int32_t a1, int32_t a2, int32_t a3);
int32_t fboot_cmd_flash_permission_validate(int32_t a1, int32_t a2);
int32_t free_sparse_image(int32_t a1, int32_t a2, int32_t a3);
int32_t get_gpio_setting(int32_t a1, int32_t * a2, int32_t a3);
int32_t get_pmic_gpio_setting(int32_t a1, int32_t * a2, int32_t a3);
int32_t heap_init(int32_t a1, int32_t a2);
int32_t heap_realloc(char * a1);
int32_t initial_thread_func(int32_t a1, int32_t a2, int32_t a3);
int32_t keys_get_state(uint32_t a1);
int32_t mcs_bytes_to_mpint(int32_t a1);
int32_t mcs_mpint_to_bytes(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_multi_add(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_multi_convert_from_multi_digit_byte_len(int32_t * a1, int32_t a2, uint32_t a3);
int32_t mdp_clk_gating_ctrl(int32_t a1, int32_t a2);
int32_t mdp_get_revision(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_set_revision(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_intf_tg_setup(int32_t * a1);
int32_t oem_utag(int32_t a1, int32_t * a2);
int32_t ondraw(int32_t a1, int32_t a2, int32_t a3);
int32_t parse_sparse_image(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t platform_get_sclk_count(int32_t a1, int32_t a2, int32_t a3);
int32_t platform_uninit(char * a1, int32_t a2, int32_t a3);
int32_t target_mot_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t target_set_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t utag_parent_exists(int32_t a1);

// --------------------- Global Variables ---------------------

bool g41 = false; // LR
int32_t g42 = 0; // R1
int32_t g43 = 0; // R2
int32_t g44 = 0; // R3
int32_t g45 = 0; // R4
int32_t g46 = 0; // R5
int32_t g47 = 0; // R6
int32_t g48 = 0; // R7
int32_t g1 = -0x16d2bf8d; // 0x8f624998
int32_t g2 = -0x16d2bf10; // 0x8f6287bc
int32_t g3 = -0x1a60cfd4; // 0x8f6760e8
int32_t g4 = -0x1a60cfd4; // 0x8f676120
int32_t g5 = -0x1a60cfa8; // 0x8f676158
int32_t g6 = -0x1a60cf9c; // 0x8f6761bc
int32_t g7 = -0x1a60cf9c; // 0x8f67622c
int32_t g8 = -0x1a60cfa8; // 0x8f67629c
int32_t g9 = -0x1a60cfd0; // 0x8f676300
int32_t g10 = -0x1a60cf70; // 0x8f6763ac
int32_t g11 = 0x7325002c; // 0x8f682749
int32_t g12 = 0x402d2b00; // 0x8f686e33
char g13[2] = "/"; // 0x8f686fbc
int32_t g14 = 0x746e6300; // 0x8f6a4e20
int32_t g15 = 0x70750020; // 0x8f6a4f1e
char * g16 = "\xff\xff\xff\xff\xff\xff\xff\xff\xe8\xc0\x6a\x8f\xe8\xc0\x6a\x8f\x01"; // 0x8f6ac0e0
int32_t g17 = 1; // 0x8f6ac0f0
int32_t g18 = 6; // 0x8f6acab0
int32_t g19 = 0; // 0x8f6b8af8
char * g20; // 0x8f6e08d4
char * g21; // 0x8f6e08f8
char * g22; // 0x8f6e08f9
int32_t g23 = 0; // 0x8f6e091c
char * g24; // 0x8f6e0938
char * g25; // 0x8f6e0aac
int32_t g26 = 0; // 0x8f6e0af4
char * g27; // 0x8f6e0b34
int32_t g28 = 0; // 0x8f6e0be8
int32_t g29 = 0; // 0x8f6e0bec
int32_t g30 = 0; // 0x8f6e0bf0
int32_t g31 = 0; // 0x8f6e0bf4
int32_t g32 = 0; // 0x8f7112f4
int32_t g33 = 0; // 0x8f7114ac
char * g34; // 0x8f711580
char * g35; // 0x8f711588
char * g36; // 0x8f711589
int16_t g37 = 0; // 0x8f711592
int32_t g38 = 0; // 0x8f7125b8
int32_t g39 = 0; // 0x8f7125bc
int32_t g40 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f63968c - 0x8f639c0f
int32_t display_logo(int32_t a1, int32_t a2) {
    int32_t v1 = g45; // 0x8f63968c
    int32_t v2 = g47; // 0x8f63968c
    int32_t v3 = 0; // 0x8f63968c
    int32_t v4 = 0; // 0x8f63968c
    int32_t v5 = 0; // 0x8f63968c
    int32_t v6 = 0; // 0x8f63968c
    int32_t v7 = g41 ? -0x709e6520 : 0; // 0x8f63968c
    g47 = a1;
    int32_t v8 = g32;
    g45 = &g32;
    int32_t v9 = display_get_image_location(a1); // 0x8f6396a8
    int32_t result5 = v9; // R0
    int32_t v10 = v9; // R8
    int32_t result; // 0x8f639a0c
    if (v9 == -1) {
        // 0x8f6396b8
        if (v8 == g32) {
            // if_8f6396c4_0_true
            // branch -> 0x8f639a04
            // 0x8f639a04
            g45 = v1;
            g47 = v2;
            result = print_log(-1, (int32_t)"display is not initialized, skip displaying logo!\n", v8, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
            return result;
        }
    } else {
        int32_t v11 = (int32_t)&g21; // R3
        if (g47 == 0) {
            char v12 = *(char *)&g21; // 0x8f6396dc
            if (v12 != 0) {
                // 0x8f6396e8
                return display_get_screen_width(v9, a2, (int32_t)v12, (int32_t)g37);
            }
        }
        // 0x8f6397fc
        *(char *)&g21 = 0;
        int32_t v13 = display_get_logo_size(v9, a2, 0, (int32_t)&g21, v1, g46, v2, g48); // 0x8f639804
        int32_t v14 = partition_get_index((int32_t)"logo", a2, 0, v11, v1, g46); // 0x8f639810
        result5 = v14;
        int32_t result2; // 0x8f639870
        if (v14 == -1) {
            // after_if_8f639818_0.thread
            // branch -> 0x8f639824
        } else {
            // after_if_8f639818_0
            if (v13 != 0) {
                int32_t result3 = get_partition_by_index(v14, a2, 0, v11); // 0x8f639840
                if (result3 == 0) {
                    // 0x8f63984c
                    if (v8 == g32) {
                        // 0x8f639864
                        // branch -> 0x8f639868
                        // 0x8f639868
                        g45 = v1;
                        g47 = v2;
                        result2 = print_log(-1, (int32_t)"%s: No valid logo entry\n", (int32_t)"display_logo", v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                        return result2;
                    }
                    // 0x8f639b9c
                    __stack_chk_fail();
                    // branch -> 0x8f639ba0
                    // 0x8f639ba0
                    g45 = v1;
                    g47 = v2;
                    return result3;
                }
                int32_t str = (int32_t)&g34; // R7
                uint32_t v15 = partition_get_offset(v14, a2, 0); // 0x8f63987c
                int32_t v16 = a2; // 0x8f63988c
                int32_t v17;
                int32_t v18;
                int32_t v19;
                int32_t result4 = generic_mmc_read_logical(v15, v16, 0x1000, 0, str, v19, 0, v18, v15, v16, 0, v8, 0, v1, g46, v2, g48, v3, v4, v5, v6, v7, v17); // 0x8f639890
                if (result4 != 0) {
                    // 0x8f63989c
                    if (v8 == g32) {
                        // 0x8f6398ac
                        g45 = v1;
                        g47 = v2;
                        return print_log(-1, (int32_t)"%s: failed in reading %s image header\n", (int32_t)"display_logo", (int32_t)"logo", v1, g46, v2, g48, v3, v4, v5, v6, v7);
                    }
                    // 0x8f639b9c
                    __stack_chk_fail();
                    // branch -> 0x8f639ba0
                    // 0x8f639ba0
                    g45 = v1;
                    g47 = v2;
                    return result4;
                }
                // 0x8f6398c8
                memcpy((char *)&g35, (char *)&g36, 4087);
                g35 = (char *)((int32_t)g35 - 1);
                int32_t len = strlen("MotoLogo"); // 0x8f6398e8
                if (strncmp((char *)str, "MotoLogo", len) != 0) {
                    // 0x8f639918
                    a2 = v10;
                    int32_t v20 = load_partition_by_name((int32_t)"logo", v10, 0, 0, v13, 0, 0, v18, v15, v16, 0, v8, 0, v1, g46, v2, g48, v3, v4, v5, v6); // 0x8f639934
                    result5 = v20;
                    if (v20 == 0) {
                        int32_t v21 = get_current_panel(0, a2, 0, 0, v13, 0, 0, v18, v15, v16, 0); // 0x8f639a10
                        int32_t v22 = *(int32_t *)(v21 + 504); // 0x8f639a14
                        g47 = *(int32_t *)(v22 + 4);
                        int32_t v23 = get_current_panel(v21, a2, 0, v22, v13, 0, 0, v18, v15, v16, 0); // 0x8f639a1c
                        result5 = v23;
                        if (v8 == g32) {
                            int32_t v24 = g47; // 0x8f639a34
                            int32_t v25 = *(int32_t *)(*(int32_t *)(v23 + 504) + 4); // 0x8f639a3c
                            g45 = v1;
                            g47 = v2;
                            return display_draw_logo(v10, v24, v25, v20, v1, g46, v2, g48, v3, v4, v5, v6, v7, v17, 0, 0, 0, 0, 0, 0);
                        }
                    } else {
                        // 0x8f639940
                        if (v8 == g32) {
                            // if_8f63994c_0_true
                            // branch -> 0x8f639a04
                            // 0x8f639a04
                            g45 = v1;
                            g47 = v2;
                            result = print_log(1, (int32_t)"failed to load logo partition", v8, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                            return result;
                        }
                    }
                    // 0x8f639b9c
                    __stack_chk_fail();
                    // branch -> 0x8f639ba0
                    // 0x8f639ba0
                    g45 = v1;
                    g47 = v2;
                    return result5;
                }
                // 0x8f639904
                v13 = g47;
                int32_t str3 = 0; // R5
                int32_t v26 = g47; // 0x8f639978
                switch (g47) {
                    case 0: {
                      lab_0x8f639a58:
                        // 0x8f639a58
                        str3 = (int32_t)"logo_boot";
                        // branch -> 0x8f639980
                        break;
                    }
                    case 2: {
                        // 0x8f639a60
                        str3 = (int32_t)"logo_battery";
                        // branch -> 0x8f639980
                        break;
                    }
                    case 1: {
                        // 0x8f639a68
                        str3 = (int32_t)"logo_unlocked";
                        // branch -> 0x8f639980
                        break;
                    }
                    case 3: {
                        // 0x8f639a70
                        str3 = (int32_t)"logo_lowpower";
                        // branch -> 0x8f639980
                        break;
                    }
                }
                // 0x8f639974
                if (v26 == 4) {
                  lab_if_8f63997c_0_true:
                    // if_8f63997c_0_true
                    str3 = (int32_t)"logo_charge";
                    // branch -> 0x8f639980
                }
              lab_0x8f639980:;
                int32_t v27 = (int32_t)g35;
                int32_t v28 = 12; // R10
                int32_t v29 = 0; // R11
                int32_t v30 = 12; // 0x8f639990
                // branch -> 0x8f63998c
                int32_t v31; // 0x8f639b44
                while (true) {
                    int32_t str2 = str + v30; // 0x8f639990
                    result5 = str2;
                    if (v30 < v27) {
                        int32_t strncmp_rc = strncmp((char *)str2, (char *)str3, 24); // 0x8f6399a4
                        result5 = strncmp_rc;
                        int32_t v32 = v29 + 1; // 0x8f6399a8
                        v29 = v32;
                        if (strncmp_rc != 0) {
                            int32_t v33 = v28 + 32; // 0x8f639a7c
                            v28 = v33;
                            if (v32 == 6) {
                                // break (via goto) -> 0x8f639b44
                                goto lab_0x8f639b44;
                            }
                            v30 = v33;
                            // continue -> 0x8f63998c
                            continue;
                        }
                        int32_t v34 = 32 * v32; // 0x8f6399bc
                        uint32_t v35 = *(int32_t *)(v34 + (int32_t)&g34 + 4); // 0x8f6399c4
                        if (v35 % *(int32_t *)(g40 + 8) != 0) {
                            // 0x8f6399e0
                            result5 = print_log(1, (int32_t)"the start address not sector alignment\n", 24, g40, str, v19, 0, v27, v15, v16, 0, v8, 0);
                            if (v8 == g32) {
                                // if_8f6399f8_0_true
                                // branch -> 0x8f639a04
                                // 0x8f639a04
                                g45 = v1;
                                g47 = v2;
                                result = print_log(1, (int32_t)"load logo fail!\n", v8, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                                return result;
                            }
                            // 0x8f639b9c
                            __stack_chk_fail();
                            // branch -> 0x8f639ba0
                            // 0x8f639ba0
                            g45 = v1;
                            g47 = v2;
                            return result5;
                        }
                        int32_t v36 = *(int32_t *)(v34 + (int32_t)&g34 + 8); // 0x8f639a90
                        uint32_t v37 = v35 + v15; // 0x8f639a94
                        int32_t v38 = (int32_t)(v37 < v15) + v16; // 0x8f639a9c
                        a2 = v38;
                        int32_t result6 = generic_mmc_read_logical(v37, v38, v36, 0, v10, v19, 0, v27, v15, v16, 0, v8, 0, v1, g46, v2, g48, v3, v4, v5, v6, v7, v17); // 0x8f639aa0
                        if (result6 != 0) {
                            // 0x8f639aac
                            if (v8 == g32) {
                                // if_8f639ab8_0_true
                                // branch -> 0x8f639a04
                                // 0x8f639a04
                                g45 = v1;
                                g47 = v2;
                                result = print_log(2, (int32_t)"read logo from emmc failed\n", v8, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                                return result;
                            }
                            // 0x8f639b9c
                            __stack_chk_fail();
                            // branch -> 0x8f639ba0
                            // 0x8f639ba0
                            g45 = v1;
                            g47 = v2;
                            return result6;
                        }
                        int32_t v39 = get_current_panel(0, a2, v36, 0, v10, v19, 0, v27, v15, v16, 0); // 0x8f639ac8
                        int32_t v40 = *(int32_t *)(v39 + 504); // 0x8f639acc
                        int32_t v41 = *(int32_t *)(v40 + 4); // 0x8f639ad0
                        int32_t v42 = get_current_panel(v39, a2, v36, v40, v10, v19, 0, v27, v15, v16, 0); // 0x8f639ad4
                        int32_t v43 = *(int32_t *)(*(int32_t *)(v42 + 504) + 4); // 0x8f639ae4
                        int32_t result7 = get_db_cid(display_draw_logo(v10, v41, v43, result6, v10, v19, 0, v27, v15, v16, 0, v8, 0, v1, g46, v2, g48, v3, v4, v5)); // 0x8f639af0
                        result5 = result7;
                        if (result7 == 222 && g47 == 1) {
                            // 0x8f639b04
                            if (*(char *)&g20 != 0) {
                                // 0x8f639b14
                                if (v8 == g32) {
                                    // 0x8f639b24
                                    g45 = v1;
                                    g47 = v2;
                                    return display_image((int32_t)"ic_unlocked_bootloader", g38, g39, 4, v1, g46, v2, g48, v3, v4, v5, v6, v7, v17, 0, 0, 0, 0, 0, 0);
                                }
                                // 0x8f639b9c
                                __stack_chk_fail();
                                // branch -> 0x8f639ba0
                                // 0x8f639ba0
                                g45 = v1;
                                g47 = v2;
                                return result5;
                            }
                        }
                        // 0x8f639b8c
                        if (v8 != g32) {
                            // 0x8f639b9c
                            __stack_chk_fail();
                            // branch -> 0x8f639ba0
                            // 0x8f639ba0
                            g45 = v1;
                            g47 = v2;
                            return result5;
                        }
                        // 0x8f639ba0
                        g45 = v1;
                        g47 = v2;
                        return result7;
                    }
                    // 0x8f639b44
                    v31 = v13;
                    if (v31 == 0) {
                        // 0x8f639b6c
                        if (v8 == g32) {
                            // if_8f639b78_0_true
                            // branch -> 0x8f639868
                            // 0x8f639868
                            g45 = v1;
                            g47 = v2;
                            result2 = print_log(0, (int32_t)"not found logo %s\n", str3, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                            return result2;
                        }
                        // 0x8f639b9c
                        __stack_chk_fail();
                        // branch -> 0x8f639ba0
                        // 0x8f639ba0
                        g45 = v1;
                        g47 = v2;
                        return result5;
                    }
                  lab_0x8f639b4c:
                    // 0x8f639b4c
                    if (v31 == 3) {
                        // 0x8f639b58
                        print_log(0, (int32_t)"Not found logo %s, loading LOGO_CHARGE\n", str3, v27, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                        v13 = 4;
                        v26 = 4;
                        // branch -> 0x8f639974
                        // 0x8f639974
                        if (v26 == 4) {
                            goto lab_if_8f63997c_0_true;
                        }
                        goto lab_0x8f639980;
                    } else {
                        // 0x8f639a48
                        int32_t v44;
                        print_log(0, (int32_t)"Not found logo %s, loading LOGO_BOOT\n", str3, v27, v17, 0, 0, 0, 0, 0, 0, v44, 0);
                        v13 = 0;
                        // branch -> 0x8f639a58
                        goto lab_0x8f639a58;
                    }
                    char * v45 = g35;
                    v27 = (int32_t)v45;
                    v28 = 12;
                    v29 = 0;
                    v30 = 12;
                    // branch -> 0x8f63998c
                }
              lab_0x8f639b44:
                // 0x8f639b44
                v31 = v13;
                if (v31 != 0) {
                    goto lab_0x8f639b4c;
                }
                // 0x8f639b6c
                if (v8 == g32) {
                    // if_8f639b78_0_true
                    // branch -> 0x8f639868
                    // 0x8f639868
                    g45 = v1;
                    g47 = v2;
                    result2 = print_log(0, (int32_t)"not found logo %s\n", str3, v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
                    return result2;
                }
                // 0x8f639b9c
                __stack_chk_fail();
                // branch -> 0x8f639ba0
                // 0x8f639ba0
                g45 = v1;
                g47 = v2;
                return result5;
            }
        }
        // 0x8f639824
        if (v8 == g32) {
            // 0x8f639864
            // branch -> 0x8f639868
            // 0x8f639868
            g45 = v1;
            g47 = v2;
            result2 = print_log(-1, (int32_t)"%s: No valid logo\n", (int32_t)"display_logo", v8, v1, g46, v2, g48, v3, v4, v5, v6, v7);
            return result2;
        }
    }
    // 0x8f639b9c
    __stack_chk_fail();
    // branch -> 0x8f639ba0
    // 0x8f639ba0
    g45 = v1;
    g47 = v2;
    return result5;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strstr(char * haystack, const char * needle);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:25:51
