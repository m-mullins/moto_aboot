//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;

// ------------------- Function Prototypes --------------------

int32_t confession_get_buffer(int32_t a1, int32_t a2, int32_t a3);
int32_t confession_get_chars(int32_t a1, int32_t a2, int32_t a3);
int32_t decode_hw_type(char * a1, int32_t a2, int32_t a3);
int32_t display_clear_screen(void);
int32_t display_draw_image(char * str, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t display_draw_image_center(char * str, uint32_t a2, uint32_t a3, int32_t a4);
int32_t display_draw_image_scr_center(char * str, uint32_t a2, uint32_t a3);
void function_8f64aacc(void);
void function_8f64ab04(int32_t a1, int32_t a2, int32_t a3);
int32_t get_hw_rev(int32_t a1, int32_t a2, int32_t a3);
int32_t get_hw_sku(int32_t a1, int32_t a2, int32_t a3);
int32_t get_last_kmsg(int32_t * a1, int32_t a2);
int32_t gfx_create_surface_from_display(int32_t * a1);
int32_t gfx_surface_destroy(char * a1, int32_t a2, int32_t a3, int32_t a4);
char * hwrev_from_utag(void);
int32_t load_and_validate_oem_image(void);
char * lz4_decode(char * a1, uint32_t a2, int32_t a3, uint32_t a4);
int32_t mcs_DER_decodeBoolean(char * a1, int16_t a2, int32_t a3);
int32_t mcs_DER_fieldLengths(int32_t a1, int16_t * a2);
int32_t mcs_memcmp(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_memset(char * a1, char a2, int32_t a3);
char * md5_process(int32_t a1, char * a2);
int32_t mdp_dma_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdp_dsi_cmd_off(int32_t a1, int32_t a2);
int32_t SecAESEncrypt(char * a1, int32_t a2, int32_t a3);
int32_t SecGetRndData(char * a1, unsigned char a2);
int32_t shutdown_modem(char * a1, int32_t a2, int32_t a3);
int32_t target_display_panel_node(char * a1, int32_t a2, int32_t a3);
int32_t type_atoi_105(char * str, int32_t a2, int32_t a3);
int32_t validate_boot_objects(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g16 = 0; // LR
int32_t g17 = 0; // R0
int32_t g18 = 0; // R1
int32_t g19 = 0; // R10
int32_t g20 = 0; // R11
int32_t g21 = 0; // R2
int32_t g22 = 0; // R3
int32_t g23 = 0; // R4
int32_t g24 = 0; // R5
int32_t g25 = 0; // R6
int32_t g26 = 0; // R7
int32_t g27 = 0; // R8
int32_t g28 = 0; // R9
int32_t g1 = -0x16d2b010; // 0x8f658270
char * g2 = "\x01"; // 0x8f6a4214
char * g3 = "\x01"; // 0x8f6a4258
int32_t g4 = -1; // 0x8f6ac1f4
int32_t g5 = 2; // 0x8f6afe0c
char * g6; // 0x8f6b7990
char * g7; // 0x8f6b79a0
int32_t g8 = 0; // 0x8f6b7c38
int32_t g9 = 0; // 0x8f6e0c34
int32_t g10 = 0; // 0x8f6e0c38
int32_t g11 = 0; // 0x8f6e0c3c
char * g12; // 0x8f6e0c40
int32_t g13 = 0; // 0x8f6e12ec
int32_t g14 = 0; // 0x8f6e12f0
int32_t g15 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f64e71c - 0x8f64e997
int32_t display_draw_image_scr_center(char * str, uint32_t a2, uint32_t a3) {
    // 0x8f64e71c
    int32_t v1;
    char * v2 = (char *)v1;
    int32_t v3 = a3; // R5
    int32_t v4 = (int32_t)str; // R4
    int32_t v5 = a2; // R6
    int32_t v6 = g15;
    if (g5 != 0) {
        // 0x8f64e944
        if (v6 == g15) {
            // 0x8f64e960
            return 0;
        }
        __stack_chk_fail();
        while (v6 != g15) {
            // 0x8f64e954
            __stack_chk_fail();
            // continue -> 0x8f64e954
        }
        // 0x8f64e960
        return 0;
    }
    int32_t v7 = g10; // R7
    if (g10 != 0) {
        uint32_t v8 = *(int32_t *)(g10 + 20); // 0x8f64e75c
        int32_t v9 = v8; // R9
        int32_t v10;
        int32_t v11;
        int32_t v12;
        int32_t v13;
        if (v8 >= a3) {
            uint32_t v14 = *(int32_t *)(g10 + 16); // 0x8f64e768
            if (v14 >= a2) {
                char v15 = *(char *)&g12; // 0x8f64e790
                int32_t v16 = v15; // 0x8f64e790
                int32_t v17; // 0x8f64e93c
                int32_t v18; // 0x8f64e93c2
                int32_t v19; // 0x8f64e93c3
                int32_t v20; // 0x8f64e9244
                int32_t v21; // 0x8f64e924
                int32_t v22; // 0x8f64e938
                int32_t v23; // R2
                int32_t v24;
                int32_t v25;
                int32_t v26;
                if (v15 != 0) {
                    // 0x8f64e8f8
                    v23 = (int32_t)"draw_image_scr_center_in_landscape";
                    print_log(-1, (int32_t)"%s: unsupported feature!\n", (int32_t)"draw_image_scr_center_in_landscape", g22, v1, v13, v12, 0, v11, v10, 0, v6, 0);
                    v20 = v11;
                    v19 = v12;
                    v18 = v13;
                    // branch -> 0x8f64e908
                    // 0x8f64e908
                    v24 = (int32_t)v2;
                    v25 = (int32_t)(char *)v10;
                    print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                    gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                    v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                    v26 = g11;
                    v17 = v21;
                    if (v26 != 0) {
                        // 0x8f64e938
                        v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                        v17 = v22;
                        // branch -> 0x8f64e93c
                    }
                    // 0x8f64e93c
                    display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                    // branch -> 0x8f64e944
                    // 0x8f64e944
                    if (v6 == g15) {
                        // 0x8f64e960
                        return 1;
                    }
                    __stack_chk_fail();
                    while (v6 != g15) {
                        // 0x8f64e954
                        __stack_chk_fail();
                        // continue -> 0x8f64e954
                    }
                    // 0x8f64e960
                    return 0;
                }
                int32_t v27 = g22; // 0x8f64e7a4
                char * v28 = (char *)v16;
                g22 = v27;
                int32_t v29; // 0x8f64e878
                int32_t v30; // 0x8f64e878
                int32_t v31;
                int32_t v32;
                int32_t result;
                int32_t v33; // 0x8f64e89c
                int32_t v34; // 0x8f64e8d4
                int32_t v35; // 0x8f64e8ac
                int32_t v36; // 0x8f64e7f0
                uint32_t v37; // 0x8f64e828
                uint32_t v38; // 0x8f64e840
                int32_t v39; // 0x8f64e890
                int32_t v40; // 0x8f64e898
                int32_t v41; // 0x8f64e8a0
                int32_t v42; // 0x8f64e8c0
                int32_t v43; // 0x8f64e8ec
                int32_t v44; // 0x8f64e820
                uint32_t v45; // 0x8f64e828
                uint32_t v46; // 0x8f64e840
                int32_t v47; // 0x8f64e8a4
                int32_t v48; // 0x8f64e8e4
                int32_t v49; // 0x8f64e8d0
                int32_t v50; // 0x8f64e8d8
                int32_t v51; // 0x8f64e870
                int32_t v52; // 0x8f64e870
                if (memcmp(str, "MotoRun", 8) != 0) {
                    // 0x8f64e818
                    v36 = v7;
                    v41 = v16;
                    // branch -> 0x8f64e81c
                    // 0x8f64e81c
                    v23 = v41;
                    v44 = *(int32_t *)(v36 + 28);
                    if (v41 == 0) {
                        // 0x8f64e888
                        if (v27 == 0) {
                            // 0x8f64e8e0
                            v48 = *(int32_t *)v36;
                            v43 = v5 * v3 * v44;
                            v23 = v43;
                            memcpy((char *)v48, (char *)v4, v43);
                            v20 = 0;
                            v19 = v12;
                            v18 = v13;
                            // branch -> 0x8f64e908
                        } else {
                            // 0x8f64e890
                            v39 = v14 * v44;
                            v40 = v5 * v44;
                            v33 = v3;
                            v47 = (v33 - 1) * v39 + *(int32_t *)v36;
                            v35 = v40 + 3 & -4;
                            g22 = v35;
                            if (v33 != 0) {
                                // 0x8f64e8b8
                                v42 = v40;
                                // branch -> 0x8f64e8b8
                                while (true) {
                                    // 0x8f64e8b8
                                    v23 = v42;
                                    memcpy((char *)v47, (char *)v4, v42);
                                    g22 = v35;
                                    v49 = v47 - v39;
                                    v9 = v49;
                                    v34 = 1;
                                    v7 = v34;
                                    v50 = v4 + v35;
                                    v4 = v50;
                                    if (v34 != v3) {
                                        goto lab_0x8f64e8b8;
                                    }
                                    v20 = v35;
                                    v19 = v12;
                                    v18 = v13;
                                    // 0x8f64e908
                                    v24 = (int32_t)v2;
                                    v25 = (int32_t)v28;
                                    print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                                    gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                                    v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                                    v26 = g11;
                                    v17 = v21;
                                    if (v26 != 0) {
                                        // 0x8f64e938
                                        v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                                        v17 = v22;
                                        // branch -> 0x8f64e93c
                                    }
                                    // 0x8f64e93c
                                    display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                                    // branch -> 0x8f64e944
                                    // 0x8f64e944
                                    if (v6 == g15) {
                                        // 0x8f64e960
                                        return 1;
                                    }
                                    __stack_chk_fail();
                                    while (v6 != g15) {
                                        // 0x8f64e954
                                        __stack_chk_fail();
                                        // continue -> 0x8f64e954
                                    }
                                    // 0x8f64e960
                                    return 0;
                                }
                            } else {
                                v20 = v27;
                                v19 = v12;
                                v18 = v13;
                            }
                        }
                        // 0x8f64e908
                        v24 = (int32_t)v2;
                        v25 = (int32_t)v28;
                        print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                        gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                        v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                        v26 = g11;
                        v17 = v21;
                        if (v26 != 0) {
                            // 0x8f64e938
                            v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                            v17 = v22;
                            // branch -> 0x8f64e93c
                        }
                        // 0x8f64e93c
                        display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                        result = 1;
                        // branch -> 0x8f64e944
                    } else {
                        // 0x8f64e828
                        v37 = v5;
                        v45 = v14;
                        if (v45 > v37) {
                            // if_8f64e83c_0_true
                            v29 = (v45 - v37) / 2;
                            // branch -> after_if_8f64e83c_0
                        } else {
                            // if_8f64e838_0_true
                            v29 = 0;
                            // branch -> after_if_8f64e83c_0
                        }
                        // after_if_8f64e83c_0
                        g22 = v29;
                        v38 = v3;
                        v46 = v9;
                        v51 = 0;
                        if (v46 > v38) {
                            // if_8f64e844_0_true
                            v51 = (v46 - v38) / 2;
                            // branch -> after_if_8f64e84c_0
                        }
                        // after_if_8f64e84c_0
                        v52 = 0;
                        if (v37 > v45) {
                            // if_8f64e854_0_true
                            v52 = (v37 - v45) / 2;
                            // branch -> after_if_8f64e85c_0
                        }
                        // after_if_8f64e85c_0
                        v32 = 0;
                        if (v38 > v46) {
                            // if_8f64e864_0_true
                            v32 = (v38 - v46) / 2;
                            // branch -> after_if_8f64e86c_0
                        }
                        // after_if_8f64e86c_0
                        v23 = v38;
                        v30 = draw_runlength_image(v4, v37, v38, v29, v51, v52, v32, 0, v27, v16, 0, v6, 0, g23, g24, g25, g26, g27, g28, g19, g20, g16, v31);
                        if (v30 != 0) {
                            v20 = v27;
                            v19 = v32;
                            v18 = v52;
                            // 0x8f64e908
                            v24 = (int32_t)(char *)v51;
                            v25 = (int32_t)v28;
                            print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                            gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                            v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                            v26 = g11;
                            v17 = v21;
                            if (v26 != 0) {
                                // 0x8f64e938
                                v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                                v17 = v22;
                                // branch -> 0x8f64e93c
                            }
                            // 0x8f64e93c
                            display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                            result = 1;
                            // branch -> 0x8f64e944
                        } else {
                            result = 0;
                        }
                    }
                    // 0x8f64e944
                    if (v6 == g15) {
                        // 0x8f64e960
                        return result;
                    }
                    __stack_chk_fail();
                    while (v6 != g15) {
                        // 0x8f64e954
                        __stack_chk_fail();
                        // continue -> 0x8f64e954
                    }
                    // 0x8f64e960
                    return 0;
                }
                int32_t v53 = v4; // 0x8f64e7c0
                int32_t v54 = (int32_t)*(char *)(v53 + 11); // 0x8f64e7c0
                int32_t v55 = (int32_t)*(char *)(v53 + 9); // 0x8f64e7c8
                int32_t v56 = 256 * (int32_t)*(char *)(v53 + 10); // 0x8f64e7d0
                v3 = v56 | v54;
                int32_t v57 = 256 * (int32_t)*(char *)(v53 + 8); // 0x8f64e7dc
                v5 = v57 | v55;
                if (v55 == v57) {
                    // after_if_8f64e7e4_0.thread
                    // branch -> 0x8f64e944
                } else {
                    // after_if_8f64e7e4_0
                    if (v54 != v56) {
                        // 0x8f64e7f0
                        v36 = v7;
                        int32_t v58 = *(int32_t *)(v36 + 28); // 0x8f64e7f0
                        if (v58 != 3) {
                            // 0x8f64e804
                            print_log(-1, (int32_t)"Invalid logo pixel format %d\n", 8 * v58, v27, v1, v13, v12, 0, v27, v16, 0, v6, 0);
                            // branch -> 0x8f64e944
                            // 0x8f64e944
                            if (v6 == g15) {
                                // 0x8f64e960
                                return 0;
                            }
                            __stack_chk_fail();
                            while (v6 != g15) {
                                // 0x8f64e954
                                __stack_chk_fail();
                                // continue -> 0x8f64e954
                            }
                            // 0x8f64e960
                            return 0;
                        }
                        // if_8f64e7f8_0_true
                        v4 = v53 + 12;
                        v41 = 1;
                        // branch -> 0x8f64e81c
                        // 0x8f64e81c
                        v23 = v41;
                        v44 = *(int32_t *)(v36 + 28);
                        if (v41 == 0) {
                            // 0x8f64e888
                            if (v27 == 0) {
                                // 0x8f64e8e0
                                v48 = *(int32_t *)v36;
                                v43 = v5 * v3 * v44;
                                v23 = v43;
                                memcpy((char *)v48, (char *)v4, v43);
                                v20 = 0;
                                v19 = v12;
                                v18 = v13;
                                // branch -> 0x8f64e908
                            } else {
                                // 0x8f64e890
                                v39 = v14 * v44;
                                v40 = v5 * v44;
                                v33 = v3;
                                v7 = 0;
                                v47 = (v33 - 1) * v39 + *(int32_t *)v36;
                                v9 = v47;
                                v35 = v40 + 3 & -4;
                                g22 = v35;
                                if (v33 != 0) {
                                    // 0x8f64e8b8
                                    v42 = v40;
                                    int32_t v59 = v4; // 0x8f64e8bc
                                    int32_t v60 = v47; // 0x8f64e8b8
                                    // branch -> 0x8f64e8b8
                                    while (true) {
                                        // 0x8f64e8b8
                                        v23 = v42;
                                        memcpy((char *)v60, (char *)v59, v42);
                                        g22 = v35;
                                        v49 = v9 - v39;
                                        v9 = v49;
                                        v34 = v7 + 1;
                                        v7 = v34;
                                        v50 = v4 + v35;
                                        v4 = v50;
                                        if (v34 != v3) {
                                          lab_0x8f64e8b8:
                                            // 0x8f64e8b8
                                            v42 = v40;
                                            v59 = v50;
                                            v60 = v49;
                                            // branch -> 0x8f64e8b8
                                            continue;
                                        } else {
                                            v20 = v35;
                                            v19 = v12;
                                            v18 = v13;
                                        }
                                    }
                                } else {
                                    v20 = v27;
                                    v19 = v12;
                                    v18 = v13;
                                }
                            }
                            // 0x8f64e908
                            v24 = (int32_t)v2;
                            v25 = (int32_t)v28;
                            print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                            gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                            v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                            v26 = g11;
                            v17 = v21;
                            if (v26 != 0) {
                                // 0x8f64e938
                                v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                                v17 = v22;
                                // branch -> 0x8f64e93c
                            }
                            // 0x8f64e93c
                            display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                            result = 1;
                            // branch -> 0x8f64e944
                        } else {
                            // 0x8f64e828
                            v37 = v5;
                            v45 = v14;
                            if (v45 > v37) {
                                // if_8f64e83c_0_true
                                v29 = (v45 - v37) / 2;
                                // branch -> after_if_8f64e83c_0
                            } else {
                                // if_8f64e838_0_true
                                v29 = 0;
                                // branch -> after_if_8f64e83c_0
                            }
                            // after_if_8f64e83c_0
                            g22 = v29;
                            v38 = v3;
                            v46 = v9;
                            v51 = 0;
                            if (v46 > v38) {
                                // if_8f64e844_0_true
                                v51 = (v46 - v38) / 2;
                                // branch -> after_if_8f64e84c_0
                            }
                            // after_if_8f64e84c_0
                            v52 = 0;
                            if (v37 > v45) {
                                // if_8f64e854_0_true
                                v52 = (v37 - v45) / 2;
                                // branch -> after_if_8f64e85c_0
                            }
                            // after_if_8f64e85c_0
                            v32 = 0;
                            if (v38 > v46) {
                                // if_8f64e864_0_true
                                v32 = (v38 - v46) / 2;
                                // branch -> after_if_8f64e86c_0
                            }
                            // after_if_8f64e86c_0
                            v23 = v38;
                            v30 = draw_runlength_image(v4, v37, v38, v29, v51, v52, v32, 0, v27, v16, 0, v6, 0, g23, g24, g25, g26, g27, g28, g19, g20, g16, v31);
                            if (v30 != 0) {
                                v20 = v27;
                                v19 = v32;
                                v18 = v52;
                                // 0x8f64e908
                                v24 = (int32_t)(char *)v51;
                                v25 = (int32_t)v28;
                                print_log(2, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                                gfx_flush(g10, (int32_t)"flush surface...\n", v23, g22, v24, v18, v19);
                                v21 = print_log(2, (int32_t)"flush surface end\n", v23, g22, v24, v18, v19, 0, v20, v25, 0, v6, 0);
                                v26 = g11;
                                v17 = v21;
                                if (v26 != 0) {
                                    // 0x8f64e938
                                    v22 = mipi_cmd_trigger(v21, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19, 0);
                                    v17 = v22;
                                    // branch -> 0x8f64e93c
                                }
                                // 0x8f64e93c
                                display_render_done(v17, (int32_t)"flush surface end\n", v23, v26, v24, v18, v19);
                                result = 1;
                                // branch -> 0x8f64e944
                            } else {
                                result = 0;
                            }
                        }
                        // 0x8f64e944
                        if (v6 == g15) {
                            // 0x8f64e960
                            return result;
                        }
                        __stack_chk_fail();
                        while (v6 != g15) {
                            // 0x8f64e954
                            __stack_chk_fail();
                            // continue -> 0x8f64e954
                        }
                        // 0x8f64e960
                        return 0;
                    }
                }
                // 0x8f64e944
                if (v6 == g15) {
                    // 0x8f64e960
                    return 0;
                }
                __stack_chk_fail();
                while (v6 != g15) {
                    // 0x8f64e954
                    __stack_chk_fail();
                    // continue -> 0x8f64e954
                }
                // 0x8f64e960
                return 0;
            }
        }
        // 0x8f64e774
        print_log(-1, (int32_t)"Image (%d x %d) is too large for screen\n", a2, a3, v1, v13, v12, 0, v11, v10, 0, v6, 0);
        // branch -> 0x8f64e944
    }
    // 0x8f64e944
    if (v6 == g15) {
        // 0x8f64e960
        return 0;
    }
    __stack_chk_fail();
    while (v6 != g15) {
        // 0x8f64e954
        __stack_chk_fail();
        // continue -> 0x8f64e954
    }
    // 0x8f64e960
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void free(void * ptr);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);

// --------------- Instruction-Idiom Functions ----------------

// float32_t fabsf(float32_t a1);
// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:12:15
