//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <regex.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int32_t charging_timer_func(int32_t a1, int32_t a2);
int32_t clock_lib2_rcg_enable(int32_t a1, int32_t a2, int32_t a3);
int32_t clock_lib2_rcg_set_rate(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t dbval_db_validate_gen_hdr(char * a1, char a2, char * a3);
int32_t dbval_debug_print2(int32_t a1, int32_t a2);
int32_t dbval_read_flash_uid(char * a1, int32_t * a2);
int32_t dbval_read_processor_uid(char * a1, int32_t * a2);
int32_t display_draw_logo(char * str, uint32_t a2, uint32_t a3, int32_t a4);
int32_t display_set_bg_color(int32_t a1, int32_t a2);
int32_t fastboot_handler(int32_t a1, int32_t a2);
void function_8f64b354(void);
void function_8f64b39c(char * a1, int32_t a2, int32_t a3);
void function_8f65db8c(void);
int32_t get_bs_info_addr(void);
int32_t get_last_powerup_reason(char * a1, int32_t a2, int32_t a3);
int32_t handle_fboot_command_reboot(int32_t a1, int32_t a2);
int32_t is_skip_sparse_preflash_validation(int32_t a1, int32_t a2);
int32_t is_skip_validation(int32_t a1);
int32_t is_warm_reset(int32_t a1);
int32_t platform_use_identity_mmu_mappings(int32_t a1);
int32_t qtimer_disable(int32_t result);
int32_t qtimer_set_physical_timer(int32_t a1, int32_t a2, int32_t a3);
int32_t request_warm_reset(char a1, int32_t a2, int32_t a3);
int32_t sdhci_send_command(char * a1, int16_t * a2);
int32_t sdhci_set_bus_width(int32_t * a1, int32_t a2);
int32_t smb1359_get_power_source(void);
int32_t smb1359_power_source_detected(int32_t a1);
char * smem_get_ram_ptable_entry(char * a1, int32_t a2, int32_t a3);
int32_t smem_get_ram_ptable_len(int32_t a1, int32_t a2, int32_t a3);
int32_t sstep(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);

// --------------------- Global Variables ---------------------

int32_t g46 = 0; // LR
int32_t g47 = 0; // R0
int32_t g48 = 0; // R1
int32_t g49 = 0; // R10
int32_t g50 = 0; // R11
int32_t g51 = 0; // R2
int32_t g52 = 0; // R3
int32_t g53 = 0; // R4
int32_t g54 = 0; // R5
int32_t g55 = 0; // R6
int32_t g56 = 0; // R7
int32_t g57 = 0; // R8
int32_t g58 = 0; // R9
bool g1 = false; // flagc
int32_t g2 = -0x1a60cf90; // 0x8f60c6d8
int32_t g3 = -0x16d2bf10; // 0x8f621a7c
int32_t g4 = -0x16d2b801; // 0x8f621dcc
int32_t g5 = -0x16d2bf09; // 0x8f622f94
int32_t g6 = -0x16d2bc10; // 0x8f623c30
int32_t g7 = -0x16d2bf8d; // 0x8f623db0
int32_t g8 = -0x16d2b010; // 0x8f62d370
int32_t g9 = -0x16d2bfed; // 0x8f638714
int32_t g10 = -0x16d2bc09; // 0x8f638ab0
int32_t g12 = 0x65440030; // 0x8f69c66f
int32_t g13 = 0x746e6300; // 0x8f6a4e20
int32_t g14 = 1; // 0x8f6ac0f0
int32_t g15 = -0x709c73f8; // 0x8f6ac374
int32_t g16 = 2; // 0x8f6afe0c
int32_t g17 = 0; // 0x8f6b50a8
char g18 = 0; // 0x8f6b50b8
char g19 = 0; // 0x8f6b50b9
char g20 = 0; // 0x8f6b50ba
char g21 = 0; // 0x8f6b50bb
int32_t g22 = 0; // 0x8f6b8ac0
int32_t g23 = 0; // 0x8f6b8ac4
int32_t g24 = 0; // 0x8f6b8ac8
int32_t g25 = 0; // 0x8f6b8acc
char * g26; // 0x8f6c02dd
int32_t g27 = 0; // 0x8f6c0390
int32_t g28 = 0; // 0x8f6c0398
int32_t g29 = 0; // 0x8f6c03d0
int32_t g30 = 0; // 0x8f6e07a8
char * g31; // 0x8f6e07c8
int32_t g32 = 0; // 0x8f6e07ec
int32_t g33 = 0; // 0x8f6e0bd4
int32_t g34 = 0; // 0x8f6e0c34
int32_t g35 = 0; // 0x8f6e0c38
int32_t g36 = 0; // 0x8f6e0c3c
char * g37; // 0x8f6e0c40
int32_t g38 = 0; // 0x8f7112f4
int32_t g39 = 0; // 0x8f7114f4
int32_t g40 = 0; // 0x8f7114f8
int32_t g41 = 0; // 0x8f7114fc
int32_t g42 = 0; // 0x8f711508
int32_t g43 = 0; // 0x8f71150c
int32_t g44 = 0; // 0x8f711510
int32_t g45 = 0; // 0x8f711534
char * g11[13] = {
    "download",
    (char *)&g3,
    "flash",
    (char *)&g5,
    "multiflash",
    (char *)&g6,
    "getvar",
    (char *)&g8,
    "erase",
    (char *)&g7,
    "boot",
    (char *)&g4,
    "reboot"
}; // 0x8f68422c

// ------------------------ Functions -------------------------

// Address range: 0x8f64de4c - 0x8f64e32f
int32_t display_draw_logo(char * str, uint32_t a2, uint32_t a3, int32_t a4) {
    // 0x8f64de4c
    int32_t v1;
    char * v2 = (char *)v1;
    int32_t v3;
    char * v4 = (char *)v3;
    int32_t result = (int32_t)str;
    int32_t v5 = a3; // R6
    int32_t v6 = a2; // R5
    int32_t v7 = g38;
    if (g16 != 0) {
        // 0x8f64e2e4
        // branch -> 0x8f64e2f8
        // 0x8f64e2f8
        return result;
    }
    int32_t v8 = g35;
    if (v8 == 0) {
        // 0x8f64e2e4
        // branch -> 0x8f64e2f8
        // 0x8f64e2f8
        return result;
    }
    uint32_t v9 = *(int32_t *)(v8 + 20); // 0x8f64de90
    int32_t result2; // 0x8f64decc
    if (v9 < a3) {
        // 0x8f64debc
        result2 = print_log(1, (int32_t)"Image is too large for screen\n", (int32_t)&g38, v7, g53, g54, g55, g56, g57, g58, g49, g50, g46);
        return result2;
    }
    uint32_t v10 = *(int32_t *)(v8 + 16); // 0x8f64de9c
    if (v10 < a2) {
        // 0x8f64debc
        result2 = print_log(1, (int32_t)"Image is too large for screen\n", (int32_t)&g38, v7, g53, g54, g55, g56, g57, g58, g49, g50, g46);
        return result2;
    }
    char v11 = *(char *)&g37; // 0x8f64ded4
    int32_t v12; // 0x8f64e2ac4
    int32_t result4; // 0x8f64e2ac
    int32_t result3; // 0x8f64e2c0
    int32_t v13; // R2
    int32_t v14;
    int32_t v15;
    int32_t v16;
    int32_t v17;
    int32_t v18;
    if (v11 != 0) {
        // 0x8f64e27c
        v13 = (int32_t)"draw_logo_in_landscape";
        int32_t v19;
        print_log(-1, (int32_t)"%s: unsupported feature!\n", (int32_t)"draw_logo_in_landscape", v9, v1, v3, v19, v10, a4, v14, 0, v7, 0);
        v12 = v14;
        // branch -> 0x8f64e28c
        // 0x8f64e28c
        v15 = (int32_t)v2;
        v16 = (int32_t)v4;
        v17 = (int32_t)(char *)v19;
        print_log(2, (int32_t)"flush surface...\n", v13, v9, v15, v16, v17, v10, a4, v12, 0, v7, 0);
        gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
        result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
        v18 = g36;
        if (v18 != 0) {
            // 0x8f64e2c0
            result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
            return result3;
        }
        // 0x8f64e2c4
        if (v7 == g38) {
            // 0x8f64e2d8
            return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
        }
        // 0x8f64e2f4
        __stack_chk_fail();
        // branch -> 0x8f64e2f8
        // 0x8f64e2f8
        return result4;
    }
    char * v20 = (char *)v9;
    int32_t v21 = v9; // R3
    int32_t v22; // R10
    int32_t v23; // R4
    int32_t v24; // R7
    int32_t v25; // R8
    int32_t v26; // R9
    int32_t v27;
    char * v28;
    char * v29;
    char * v30;
    int32_t v31;
    char * v32;
    char * v33;
    char * v34;
    int32_t v35;
    int32_t v36;
    int32_t v37;
    int32_t v38;
    int32_t v39;
    int32_t v40; // 0x8f64e0a026
    int32_t v41; // 0x8f64e18444
    int32_t v42; // 0x8f64e204
    int32_t v43; // 0x8f64e1fc
    int32_t v44; // 0x8f64e248
    int32_t v45; // 0x8f64df40
    int32_t v46; // 0x8f64e1ac
    int32_t v47; // 0x8f64e05c
    int32_t v48; // 0x8f64e0a8
    int32_t v49; // 0x8f64e0f841
    int32_t v50; // 0x8f64e1ac
    int32_t v51; // 0x8f64e1b0
    int32_t v52; // 0x8f64e1ec
    int32_t v53; // 0x8f64e238
    int32_t v54; // 0x8f64e23c
    int32_t v55; // 0x8f64e244
    int32_t v56; // 0x8f64e270
    int32_t v57; // 0x8f64df9c
    int32_t v58; // 0x8f64dfa8
    int32_t v59; // 0x8f64dfb8
    char v60; // 0x8f64dfc4
    char v61; // 0x8f64dfc8
    char v62; // 0x8f64dfd4
    int32_t v63; // 0x8f64dff8
    int32_t v64; // 0x8f64e010
    int32_t v65; // 0x8f64e014
    int32_t v66; // 0x8f64e08c
    int32_t v67; // 0x8f64e094
    int32_t v68; // 0x8f64e098
    int32_t v69; // 0x8f64e09c
    int32_t v70; // 0x8f64e190
    int32_t v71; // 0x8f64e1c0
    int32_t v72; // 0x8f64e1c8
    int32_t v73; // 0x8f64e1cc
    int32_t v74; // 0x8f64e1f0
    int32_t v75; // 0x8f64e214
    int32_t v76; // 0x8f64e21c
    int32_t v77; // 0x8f64e220
    int32_t v78; // 0x8f64e23c
    int32_t v79; // 0x8f64e25c
    int32_t v80; // 0x8f64e260
    int32_t v81; // 0x8f64df80
    uint32_t v82; // 0x8f64dfa0
    int32_t v83; // 0x8f64dfd8
    int32_t v84; // 0x8f64e004
    int32_t v85; // 0x8f64e068
    int32_t v86; // 0x8f64e1f8
    int32_t v87; // 0x8f64e244
    int32_t v88; // 0x8f64dfe8
    int32_t v89; // 0x8f64e018
    int32_t v90; // 0x8f64e06c
    int32_t v91; // 0x8f64e03c
    if (memcmp(str, "MotoRun", 8) != 0) {
        // 0x8f64df88
        v23 = result;
        int32_t v92 = v11; // 0x8f64df8c
        v81 = v92;
        v63 = v92;
        v45 = v8;
        // branch -> 0x8f64df94
        // 0x8f64df94
        v22 = v81;
        v57 = *(int32_t *)(v45 + 28);
        v82 = v10 - v6;
        v58 = (v9 - v5) / 2;
        v26 = v58;
        v59 = v82 / 2;
        v25 = v59;
        v88 = v81;
        if (((v63 ^ 1) & -1 - a4) % 2 != 0) {
            // 0x8f64dfc4
            v60 = *(char *)(result + 1);
            v61 = *(char *)result;
            v62 = *(char *)(result + 2);
            v83 = 0x10000 * (int32_t)v61 | 256 * (int32_t)v60 | (int32_t)v62;
            v22 = v83;
            v88 = v83;
            // branch -> 0x8f64dfdc
        }
        // 0x8f64dfdc
        v91 = v58;
        v28 = v2;
        v29 = v20;
        v30 = v4;
        if (v82 >= 2) {
            // 0x8f64dfe4
            gfx_fillrect(v45, 0, 0, v59, v9, v88, v63, v10, a4, v57, 0, v7, 0, g53);
            v84 = v25 + v6;
            v27 = g35;
            v64 = *(int32_t *)(v27 + 20);
            v65 = *(int32_t *)(v27 + 16);
            v89 = v22;
            gfx_fillrect(v27, v84, 0, v65 - v84, v64, v89, v63, v10, a4, v57, 0, v7, 0, g53);
            v91 = v26;
            v28 = (char *)v64;
            v29 = (char *)v63;
            v30 = (char *)v89;
            // branch -> 0x8f64e02c
        }
        // 0x8f64e02c
        v32 = v28;
        v33 = v29;
        v34 = v30;
        if (v91 != 0) {
            // 0x8f64e034
            gfx_fillrect(g35, v25, 0, v6, v91, v22, v63, v10, a4, v57, 0, v7, 0, g53);
            v31 = g35;
            v47 = v5 + v91;
            v85 = *(int32_t *)(v31 + 20) - v47;
            v90 = v22;
            gfx_fillrect(v31, v25, v47, v6, v85, v90, v63, v10, a4, v57, 0, v7, 0, g53);
            v32 = (char *)v85;
            v33 = (char *)v63;
            v34 = (char *)v90;
            // branch -> 0x8f64e07c
        }
        // 0x8f64e07c
        if (v63 != 0) {
            // 0x8f64e088
            v35 = g35;
            v66 = *(int32_t *)(v35 + 16);
            v13 = v66;
            v67 = *(int32_t *)(v35 + 28);
            v68 = *(int32_t *)v35;
            v69 = v68 + v67 * (v25 + v26 * v66);
            v25 = v69;
            v40 = v5;
            if (v40 != 0) {
                // 0x8f64e0a8
                v41 = v40;
                v49 = v69;
                v48 = v6;
                // branch -> 0x8f64e0a8
                while (true) {
                    // 0x8f64e0a8
                    if (v48 == 0) {
                        v70 = 0;
                        v36 = v35;
                        goto lab_0x8f64e180;
                    }
                    goto lab_0x8f64e0b4;
                }
            } else {
                v12 = v57;
            }
            // 0x8f64e28c
            v15 = (int32_t)v32;
            v16 = (int32_t)v34;
            v17 = (int32_t)v33;
            print_log(2, (int32_t)"flush surface...\n", v13, v68, v15, v16, v17, v10, a4, v12, 0, v7, 0);
            gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
            result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
            v18 = g36;
            if (v18 != 0) {
                // 0x8f64e2c0
                result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                return result3;
            }
            // 0x8f64e2c4
            if (v7 == g38) {
                // 0x8f64e2d8
                return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
            }
            // 0x8f64e2f4
            __stack_chk_fail();
            // branch -> 0x8f64e2f8
            // 0x8f64e2f8
            return result4;
        }
        // 0x8f64e19c
        v46 = v6;
        v50 = v46 * v57;
        v22 = v50;
        v51 = v57 * v10;
        v24 = v51;
        if (a4 != 0) {
            // 0x8f64e1b8
            v37 = g35;
            v71 = *(int32_t *)(v37 + 16);
            v13 = v71;
            v72 = *(int32_t *)(v37 + 28);
            v73 = *(int32_t *)v37;
            v21 = v73;
            if (v5 != 0) {
                // 0x8f64e1e4
                v52 = v50;
                v74 = v73 + v72 * (v25 + v26 * v71);
                // branch -> 0x8f64e1e4
                while (true) {
                    // 0x8f64e1e4
                    v13 = v52;
                    memcpy((char *)v74, (char *)v23, v52);
                    v86 = v23 + (v50 + 3 & -4);
                    v23 = v86;
                    v43 = 1;
                    v6 = v43;
                    if (v43 != v5) {
                        goto lab_0x8f64e1e4;
                    }
                    v12 = v57;
                    // 0x8f64e28c
                    v15 = (int32_t)v32;
                    v16 = (int32_t)v34;
                    v17 = (int32_t)v33;
                    print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                    gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                    result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                    v18 = g36;
                    if (v18 != 0) {
                        // 0x8f64e2c0
                        result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                        return result3;
                    }
                    // 0x8f64e2c4
                    if (v7 == g38) {
                        // 0x8f64e2d8
                        return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                    }
                    // 0x8f64e2f4
                    __stack_chk_fail();
                    // branch -> 0x8f64e2f8
                    // 0x8f64e2f8
                    return result4;
                }
            } else {
                v12 = v57;
            }
            // 0x8f64e28c
            v15 = (int32_t)v32;
            v16 = (int32_t)v34;
            v17 = (int32_t)v33;
            print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
            gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
            result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
            v18 = g36;
            if (v18 != 0) {
                // 0x8f64e2c0
                result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                return result3;
            }
            // 0x8f64e2c4
            if (v7 == g38) {
                // 0x8f64e2d8
                return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
            }
            // 0x8f64e2f4
            __stack_chk_fail();
            // branch -> 0x8f64e2f8
            // 0x8f64e2f8
            return result4;
        }
        // 0x8f64e204
        v42 = v25;
        if (v42 == 0) {
            // 0x8f64e250
            v39 = g35;
            v79 = *(int32_t *)(v39 + 28);
            v21 = v79;
            v80 = *(int32_t *)v39;
            v56 = v5 * v46 * v79;
            v13 = v56;
            memcpy((char *)(v79 * v46 * v26 + v80), (char *)v23, v56);
            v12 = v57;
            // branch -> 0x8f64e28c
        } else {
            // 0x8f64e20c
            v38 = g35;
            v75 = *(int32_t *)(v38 + 16);
            v13 = v75;
            v76 = *(int32_t *)(v38 + 28);
            v77 = *(int32_t *)v38;
            v21 = v77;
            if (v5 != 0) {
                // 0x8f64e230
                v54 = v51;
                v53 = v50;
                v78 = (v26 * v75 + v42) * v76 + v77;
                // branch -> 0x8f64e230
                while (true) {
                    // 0x8f64e230
                    v13 = v53;
                    memcpy((char *)v78, (char *)v23, v53);
                    v55 = v22;
                    v87 = v23 + v55;
                    v23 = v87;
                    v44 = 1;
                    v6 = v44;
                    if (v44 != v5) {
                        goto lab_0x8f64e230;
                    }
                    v12 = v57;
                    // 0x8f64e28c
                    v15 = (int32_t)v32;
                    v16 = (int32_t)v34;
                    v17 = (int32_t)v33;
                    print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                    gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                    result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                    v18 = g36;
                    if (v18 != 0) {
                        // 0x8f64e2c0
                        result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                        return result3;
                    }
                    // 0x8f64e2c4
                    if (v7 == g38) {
                        // 0x8f64e2d8
                        return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                    }
                    // 0x8f64e2f4
                    __stack_chk_fail();
                    // branch -> 0x8f64e2f8
                    // 0x8f64e2f8
                    return result4;
                }
            } else {
                v12 = v57;
            }
        }
        // 0x8f64e28c
        v15 = (int32_t)v32;
        v16 = (int32_t)v34;
        v17 = (int32_t)v33;
        print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
        gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
        result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
        v18 = g36;
        if (v18 != 0) {
            // 0x8f64e2c0
            result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
            return result3;
        }
        // 0x8f64e2c4
        if (v7 == g38) {
            // 0x8f64e2d8
            return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
        }
        // 0x8f64e2f4
        __stack_chk_fail();
        // branch -> 0x8f64e2f8
        // 0x8f64e2f8
        return result4;
    }
    int32_t v93 = (int32_t)*(char *)(result + 11); // 0x8f64defc
    int32_t v94 = (int32_t)*(char *)(result + 9); // 0x8f64df04
    int32_t v95 = 256 * (int32_t)*(char *)(result + 10); // 0x8f64df0c
    int32_t v96 = v95 | v93; // 0x8f64df0c
    v5 = v96;
    int32_t v97 = 256 * (int32_t)*(char *)(result + 8); // 0x8f64df18
    int32_t v98 = v97 | v94; // 0x8f64df18
    v6 = v98;
    if (v94 == v97) {
        // after_if_8f64df20_0.thread
        v13 = 1;
        v12 = v14;
        // branch -> 0x8f64e28c
    } else {
        // after_if_8f64df20_0
        v13 = v93 == v95;
        if (v93 != v95) {
            // 0x8f64df2c
            if (v98 <= v10) {
                // 0x8f64df38
                if (v96 <= v9) {
                    // 0x8f64df40
                    v45 = v8;
                    if (*(int32_t *)(v45 + 28) == 3) {
                        char v99 = *(char *)(result + 15); // 0x8f64df64
                        v23 = result + 12;
                        char v100 = *(char *)(result + 14); // 0x8f64df6c
                        char v101 = *(char *)(result + 16); // 0x8f64df7c
                        v81 = 0x10000 * (int32_t)v100 | 256 * (int32_t)v99 | (int32_t)v101;
                        v63 = 1;
                        // branch -> 0x8f64df94
                        // 0x8f64df94
                        v22 = v81;
                        v57 = *(int32_t *)(v45 + 28);
                        v82 = v10 - v98;
                        v58 = (v9 - v96) / 2;
                        v26 = v58;
                        v59 = v82 / 2;
                        v25 = v59;
                        v88 = v81;
                        if (((v63 ^ 1) & -1 - a4) % 2 != 0) {
                            // 0x8f64dfc4
                            v60 = *(char *)(result + 1);
                            v61 = *(char *)result;
                            v62 = *(char *)(result + 2);
                            v83 = 0x10000 * (int32_t)v61 | 256 * (int32_t)v60 | (int32_t)v62;
                            v22 = v83;
                            v88 = v83;
                            // branch -> 0x8f64dfdc
                        }
                        // 0x8f64dfdc
                        v91 = v58;
                        v28 = v2;
                        v29 = v20;
                        v30 = v4;
                        if (v82 >= 2) {
                            // 0x8f64dfe4
                            gfx_fillrect(v45, 0, 0, v59, v9, v88, v63, v10, a4, v57, 0, v7, 0, g53);
                            v84 = v25 + v6;
                            v27 = g35;
                            v64 = *(int32_t *)(v27 + 20);
                            v65 = *(int32_t *)(v27 + 16);
                            v89 = v22;
                            gfx_fillrect(v27, v84, 0, v65 - v84, v64, v89, v63, v10, a4, v57, 0, v7, 0, g53);
                            v91 = v26;
                            v28 = (char *)v64;
                            v29 = (char *)v63;
                            v30 = (char *)v89;
                            // branch -> 0x8f64e02c
                        }
                        // 0x8f64e02c
                        v32 = v28;
                        v33 = v29;
                        v34 = v30;
                        if (v91 != 0) {
                            // 0x8f64e034
                            gfx_fillrect(g35, v25, 0, v6, v91, v22, v63, v10, a4, v57, 0, v7, 0, g53);
                            v31 = g35;
                            v47 = v5 + v91;
                            v85 = *(int32_t *)(v31 + 20) - v47;
                            v90 = v22;
                            gfx_fillrect(v31, v25, v47, v6, v85, v90, v63, v10, a4, v57, 0, v7, 0, g53);
                            v32 = (char *)v85;
                            v33 = (char *)v63;
                            v34 = (char *)v90;
                            // branch -> 0x8f64e07c
                        }
                        // 0x8f64e07c
                        if (v63 == 0) {
                            // 0x8f64e19c
                            v46 = v6;
                            v50 = v46 * v57;
                            v22 = v50;
                            v51 = v57 * v10;
                            v24 = v51;
                            if (a4 != 0) {
                                // 0x8f64e1b8
                                v37 = g35;
                                v6 = 0;
                                v71 = *(int32_t *)(v37 + 16);
                                v13 = v71;
                                v72 = *(int32_t *)(v37 + 28);
                                v73 = *(int32_t *)v37;
                                if (v5 != 0) {
                                    int32_t v102 = v51; // 0x8f64e1f0
                                    v52 = v50;
                                    int32_t v103 = v23; // 0x8f64e1e8
                                    v74 = v73 + v72 * (v25 + v26 * v71);
                                    // branch -> 0x8f64e1e4
                                    while (true) {
                                        // 0x8f64e1e4
                                        v13 = v52;
                                        memcpy((char *)v74, (char *)v103, v52);
                                        v86 = v23 + (v50 + 3 & -4);
                                        v23 = v86;
                                        v43 = v6 + 1;
                                        v6 = v43;
                                        if (v43 != v5) {
                                          lab_0x8f64e1e4:;
                                            int32_t v104 = v74 + v102;
                                            v102 = v24;
                                            v52 = v22;
                                            v103 = v86;
                                            v74 = v104;
                                            // branch -> 0x8f64e1e4
                                            continue;
                                        } else {
                                            v12 = v57;
                                        }
                                    }
                                } else {
                                    v12 = v57;
                                }
                                // 0x8f64e28c
                                v15 = (int32_t)v32;
                                v16 = (int32_t)v34;
                                v17 = (int32_t)v33;
                                print_log(2, (int32_t)"flush surface...\n", v13, v73, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                                result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                v18 = g36;
                                if (v18 != 0) {
                                    // 0x8f64e2c0
                                    result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                                    return result3;
                                }
                                // 0x8f64e2c4
                                if (v7 == g38) {
                                    // 0x8f64e2d8
                                    return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                                }
                                // 0x8f64e2f4
                                __stack_chk_fail();
                                // branch -> 0x8f64e2f8
                                // 0x8f64e2f8
                                return result4;
                            }
                            // 0x8f64e204
                            v42 = v25;
                            if (v42 == 0) {
                                // 0x8f64e250
                                v39 = g35;
                                v79 = *(int32_t *)(v39 + 28);
                                v21 = v79;
                                v80 = *(int32_t *)v39;
                                v56 = v5 * v46 * v79;
                                v13 = v56;
                                memcpy((char *)(v79 * v46 * v26 + v80), (char *)v23, v56);
                                v12 = v57;
                                // branch -> 0x8f64e28c
                            } else {
                                // 0x8f64e20c
                                v38 = g35;
                                v6 = 0;
                                v75 = *(int32_t *)(v38 + 16);
                                v13 = v75;
                                v76 = *(int32_t *)(v38 + 28);
                                v77 = *(int32_t *)v38;
                                v21 = v77;
                                if (v5 != 0) {
                                    // 0x8f64e230
                                    v54 = v51;
                                    v53 = v50;
                                    int32_t v105 = v23; // 0x8f64e234
                                    v78 = (v26 * v75 + v42) * v76 + v77;
                                    // branch -> 0x8f64e230
                                    while (true) {
                                        // 0x8f64e230
                                        v13 = v53;
                                        memcpy((char *)v78, (char *)v105, v53);
                                        v55 = v22;
                                        v87 = v23 + v55;
                                        v23 = v87;
                                        v44 = v6 + 1;
                                        v6 = v44;
                                        if (v44 != v5) {
                                          lab_0x8f64e230:;
                                            int32_t v106 = v78 + v54;
                                            v54 = v24;
                                            v53 = v55;
                                            v105 = v87;
                                            v78 = v106;
                                            // branch -> 0x8f64e230
                                            continue;
                                        } else {
                                            v12 = v57;
                                        }
                                    }
                                } else {
                                    v12 = v57;
                                }
                            }
                            // 0x8f64e28c
                            v15 = (int32_t)v32;
                            v16 = (int32_t)v34;
                            v17 = (int32_t)v33;
                            print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                            gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                            result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                            v18 = g36;
                            if (v18 != 0) {
                                // 0x8f64e2c0
                                result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                                return result3;
                            }
                            // 0x8f64e2c4
                            if (v7 == g38) {
                                // 0x8f64e2d8
                                return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                            }
                            // 0x8f64e2f4
                            __stack_chk_fail();
                            // branch -> 0x8f64e2f8
                            // 0x8f64e2f8
                            return result4;
                        }
                        // 0x8f64e088
                        v35 = g35;
                        v66 = *(int32_t *)(v35 + 16);
                        v13 = v66;
                        v67 = *(int32_t *)(v35 + 28);
                        v68 = *(int32_t *)v35;
                        v21 = v68;
                        v69 = v68 + v67 * (v25 + v26 * v66);
                        v25 = v69;
                        v40 = v5;
                        if (v40 != 0) {
                            // 0x8f64e0a8
                            v41 = v40;
                            int32_t v107 = v35;
                            v49 = v69;
                            v48 = v6;
                            // branch -> 0x8f64e0a8
                            while (true) {
                                // 0x8f64e0a8
                                if (v48 == 0) {
                                    v70 = 0;
                                    v36 = v107;
                                  lab_0x8f64e180:;
                                    int32_t v108 = v41 - 1; // 0x8f64e184
                                    int32_t v109 = *(int32_t *)(v36 + 28); // 0x8f64e18c
                                    v21 = v109;
                                    int32_t v110 = *(int32_t *)(v36 + 16) - v70; // 0x8f64e190
                                    v13 = v110;
                                    int32_t v111 = v110 * v109 + v49; // 0x8f64e194
                                    v25 = v111;
                                    if (v108 == 0) {
                                        v12 = v57;
                                        // break -> 0x8f64e28c
                                        break;
                                    }
                                    v41 = v108;
                                    v107 = v36;
                                    v49 = v111;
                                    v48 = v70;
                                    // continue -> 0x8f64e0a8
                                    continue;
                                } else {
                                  lab_0x8f64e0b4:;
                                    int32_t v112 = v49; // 0x8f64e148
                                    uint32_t v113 = v48; // 0x8f64e14c
                                    int32_t v114 = v23; // 0x8f64e144
                                    // branch -> 0x8f64e0b4
                                    while (true) {
                                        char v115 = *(char *)(v114 + 1); // 0x8f64e0b8
                                        uint32_t v116 = (int32_t)v115 | 256 * (int32_t)*(char *)v114; // 0x8f64e0bc
                                        v26 = v116;
                                        int32_t v117; // 0x8f64e0b437
                                        int32_t v118; // 0x8f64e174
                                        if ((v116 & 0x8000) == 0) {
                                            int32_t v119 = v116 > 1 ? 0 : 1 - v116; // 0x8f64e128
                                            v21 = v119;
                                            if (v113 < v116) {
                                                // after_if_8f64e134_0.thread
                                                v21 = v119 | 1;
                                                v12 = v57;
                                                // branch -> 0x8f64e28c
                                            } else {
                                                // after_if_8f64e134_0
                                                if (v119 == 0) {
                                                    int32_t v120 = v114 + 2; // 0x8f64e144
                                                    v24 = v113 - v116;
                                                    int32_t v121 = *(int32_t *)(g35 + 28) * v116; // 0x8f64e15c
                                                    v13 = v121;
                                                    memcpy((char *)v112, (char *)v120, v121);
                                                    int32_t v122 = v26 * *(int32_t *)(g35 + 28); // 0x8f64e170
                                                    v118 = v25 + v122;
                                                    v25 = v118;
                                                    v117 = v120 + v122;
                                                    // branch -> 0x8f64e0ac
                                                  lab_0x8f64e0ac_2:;
                                                    int32_t v123 = v24;
                                                    if (v123 == 0) {
                                                        // break -> 0x8f64e0ac
                                                        break;
                                                    }
                                                    v112 = v118;
                                                    v113 = v123;
                                                    v114 = v117;
                                                    // continue -> 0x8f64e0b4
                                                    continue;
                                                } else {
                                                    v12 = v57;
                                                }
                                            }
                                            // 0x8f64e28c
                                            v15 = (int32_t)v32;
                                            v16 = (int32_t)v34;
                                            v17 = (int32_t)v33;
                                            print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                            gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                                            result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                            v18 = g36;
                                            if (v18 != 0) {
                                                // 0x8f64e2c0
                                                result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                                                return result3;
                                            }
                                            // 0x8f64e2c4
                                            if (v7 == g38) {
                                                // 0x8f64e2d8
                                                return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                                            }
                                            // 0x8f64e2f4
                                            __stack_chk_fail();
                                            // branch -> 0x8f64e2f8
                                            // 0x8f64e2f8
                                            return result4;
                                        }
                                        uint32_t v124 = v116 % 0x8000; // 0x8f64e0c8
                                        v26 = v124;
                                        int32_t v125 = v124 > 1 ? 0 : 1 - v124; // 0x8f64e0cc
                                        v21 = v125;
                                        if (v113 < v124) {
                                            // after_if_8f64e0d8_0.thread
                                            v21 = v125 | 1;
                                            v12 = v57;
                                            // branch -> 0x8f64e28c
                                        } else {
                                            // after_if_8f64e0d8_0
                                            if (v125 == 0) {
                                                char v126 = *(char *)(v114 + 2); // 0x8f64e0e4
                                                int32_t v127 = v126; // R0
                                                v24 = v113 - v124;
                                                int32_t v128 = (int32_t)*(char *)(v114 + 3); // R12
                                                int32_t v129 = v114 + 5; // 0x8f64e0f0
                                                int32_t v130 = (int32_t)*(char *)(v114 + 4); // LR
                                                v21 = v112;
                                                bool v131 = v124 != 0; // flagc
                                                v13 = v124 - 1;
                                                int32_t v132 = v112; // 0x8f64e120
                                                int32_t v133; // 0x8f64e120
                                                if (v124 != 0) {
                                                    // after_if_8f64e104_0.preheader
                                                    *(char *)v112 = v126;
                                                    int32_t v134;
                                                    if (v131) {
                                                        while (true) {
                                                            int32_t v135 = v21; // 0x8f64e108
                                                            v21 = v135 + 3;
                                                            *(char *)(v135 + 1) = (char)v128;
                                                            if (v131) {
                                                                // after_if_8f64e110_0
                                                                *(char *)(v21 - 1) = (char)v130;
                                                                if (v131) {
                                                                    int32_t v136 = v13;
                                                                    v131 = v136 != 0;
                                                                    v13 = v136 - 1;
                                                                    if (v136 != 0) {
                                                                        // 0x8f64e100
                                                                        *(char *)v21 = (char)v127;
                                                                        if (!v131) {
                                                                            // break -> 0x8f64e118
                                                                            break;
                                                                        }
                                                                        // continue -> after_if_8f64e10c_0
                                                                        continue;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        // 0x8f64e118
                                                        // branch -> 0x8f64e118
                                                      lab_0x8f64e118:
                                                        // 0x8f64e118
                                                        v133 = v25 + 3 * v134;
                                                        v25 = v133;
                                                        v118 = v133;
                                                        v117 = v129;
                                                        // branch -> 0x8f64e0ac
                                                        goto lab_0x8f64e0ac_2;
                                                    }
                                                    // 0x8f64e118
                                                    v134 = v26;
                                                    // branch -> 0x8f64e118
                                                    goto lab_0x8f64e118;
                                                }
                                                // 0x8f64e118
                                                v133 = v132;
                                                v25 = v133;
                                                v118 = v133;
                                                v117 = v129;
                                                // branch -> 0x8f64e0ac
                                                goto lab_0x8f64e0ac_2;
                                            } else {
                                                v12 = v57;
                                            }
                                        }
                                        // 0x8f64e28c
                                        v15 = (int32_t)v32;
                                        v16 = (int32_t)v34;
                                        v17 = (int32_t)v33;
                                        print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                        gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                                        result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                        v18 = g36;
                                        if (v18 != 0) {
                                            // 0x8f64e2c0
                                            result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                                            return result3;
                                        }
                                        // 0x8f64e2c4
                                        if (v7 == g38) {
                                            // 0x8f64e2d8
                                            return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                                        }
                                        // 0x8f64e2f4
                                        __stack_chk_fail();
                                        // branch -> 0x8f64e2f8
                                        // 0x8f64e2f8
                                        return result4;
                                    }
                                }
                                // 0x8f64e28c
                                char * v137;
                                v15 = (int32_t)v137;
                                char * v138;
                                v16 = (int32_t)v138;
                                char * v139;
                                v17 = (int32_t)v139;
                                print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                                result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                                v18 = g36;
                                if (v18 != 0) {
                                    // 0x8f64e2c0
                                    result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                                    return result3;
                                }
                                // 0x8f64e2c4
                                if (v7 == g38) {
                                    // 0x8f64e2d8
                                    return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                                }
                                // 0x8f64e2f4
                                __stack_chk_fail();
                                // branch -> 0x8f64e2f8
                                // 0x8f64e2f8
                                return result4;
                            }
                        } else {
                            v12 = v57;
                        }
                        // 0x8f64e28c
                        v15 = (int32_t)v32;
                        v16 = (int32_t)v34;
                        v17 = (int32_t)v33;
                        print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                        gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
                        result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
                        v18 = g36;
                        if (v18 != 0) {
                            // 0x8f64e2c0
                            result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
                            return result3;
                        }
                        // 0x8f64e2c4
                        if (v7 == g38) {
                            // 0x8f64e2d8
                            return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
                        }
                        // 0x8f64e2f4
                        __stack_chk_fail();
                        // branch -> 0x8f64e2f8
                        // 0x8f64e2f8
                        return result4;
                    }
                }
            }
            // 0x8f64df4c
            v13 = v98;
            v21 = v96;
            print_log(-1, (int32_t)"Invalid logo w %d, h %d\n", v98, v96, v1, v3, v9, v10, a4, v14, 0, v7, 0);
            v12 = v14;
            // branch -> 0x8f64e28c
        } else {
            v12 = v14;
        }
    }
    // 0x8f64e28c
    v15 = (int32_t)v2;
    v16 = (int32_t)v4;
    v17 = (int32_t)v20;
    print_log(2, (int32_t)"flush surface...\n", v13, v21, v15, v16, v17, v10, a4, v12, 0, v7, 0);
    gfx_flush(g35, (int32_t)"flush surface...\n", v13, (int32_t)&g35, v15, v16, v17);
    result4 = print_log(2, (int32_t)"flush surface end\n", v13, (int32_t)&g35, v15, v16, v17, v10, a4, v12, 0, v7, 0);
    v18 = g36;
    if (v18 != 0) {
        // 0x8f64e2c0
        result3 = mipi_cmd_trigger(result4, (int32_t)"flush surface end\n", v13, v18, v15, v16, v17, v10);
        return result3;
    }
    // 0x8f64e2c4
    if (v7 == g38) {
        // 0x8f64e2d8
        return display_render_done(result4, (int32_t)"flush surface end\n", v7, v7, g53, g54, g55);
    }
    // 0x8f64e2f4
    __stack_chk_fail();
    // branch -> 0x8f64e2f8
    // 0x8f64e2f8
    return result4;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// void * realloc(void * ptr, size_t size);
// void regfree(regex_t * preg);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:53:53
