//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t _dputs(int32_t a1, int32_t a2, int32_t a3);
int32_t _dvprintf(char * format);
int32_t clear_flash_fail(int32_t a1, int32_t a2);
char * display_sw_version(void);
int32_t flash_sparse_data(char * a1, int64_t a2, int32_t a3, int32_t a4, uint32_t a5, uint32_t a6);
void function_8f67b3c0(int32_t a1);
int32_t get_backup_partition(void);
int32_t get_line_number(char * a1, int32_t a2, int32_t a3);
int32_t get_panel_ver(int32_t a1, int32_t * a2);
int32_t gpio_62_irq_handler(int32_t (*a1)(), int32_t a2);
int32_t gpio_set_intr_cfg_type(int32_t a1, int32_t a2, int32_t a3);
int32_t handle_fboot_command_download(int32_t * a1);
int32_t is_always_on(char * a1, int32_t a2, int32_t a3);
int32_t load_partition_by_name(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t lp8556_read_reg(int32_t a1, int32_t a2);
int32_t lp8556_write_reg(int32_t a1, int32_t a2);
int32_t max17042_get_battery_temperature(void);
int32_t max17042_get_temp_thresholds(char * a1, int32_t a2, int32_t a3);
int32_t mcs_clear_rng_ctx(int32_t a1, int32_t a2);
int32_t mcs_mp_compare(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_mp_copy(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_return_rng_data(char * a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_identify(int32_t a1);
int32_t set_flash_fail(void);
int32_t set_logger_max_log_len(int32_t a1, int32_t a2);
int32_t set_logger_status(int32_t a1, char a2);
int32_t smb1359_config_aicl(int32_t a1);
int32_t smb1359_is_hvdcp(int32_t a1);
int32_t store_partition(int32_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t validate_gpt_partition(char * a1, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g30 = 0; // LR
int32_t g31 = 0; // R0
int32_t g32 = 0; // R1
int32_t g33 = 0; // R10
int32_t g34 = 0; // R11
int32_t g35 = 0; // R2
int32_t g36 = 0; // R3
int32_t g37 = 0; // R4
int32_t g38 = 0; // R5
int32_t g39 = 0; // R6
int32_t g40 = 0; // R7
int32_t g41 = 0; // R8
int32_t g42 = 0; // R9
int32_t g1 = 1; // 0x8f69c7cc
char * g2; // 0x8f6a4e20
int32_t g3; // 0x8f6afe74
char (*g4)[5] = "sbl1"; // 0x8f6affb4
int32_t g5 = 0; // 0x8f6e0a98
int32_t g6 = 0; // 0x8f6e0b38
int32_t g7 = 0; // 0x8f6e0b48
int32_t g8 = 0; // 0x8f70f7a5
int32_t g9 = 0; // 0x8f70f7c5
int32_t g10 = 0; // 0x8f70f7c6
int32_t g11 = 0; // 0x8f70f7c7
int32_t g12 = 0; // 0x8f70f7c8
int32_t g13 = 0; // 0x8f70f7c9
int32_t g14 = 0; // 0x8f70f7ca
int32_t g15 = 0; // 0x8f70f7cb
int32_t g16 = 0; // 0x8f70f7cc
int32_t g17 = 0; // 0x8f70f7cd
int32_t g18 = 0; // 0x8f70f7ce
int32_t g19 = 0; // 0x8f70f7cf
int32_t g20 = 0; // 0x8f70f7d0
int32_t g21 = 0; // 0x8f70f7d1
int32_t g22 = 0; // 0x8f70f7d2
int32_t g23 = 0; // 0x8f70f7d3
int32_t g24 = 0; // 0x8f70f7d4
char g25 = 0; // 0x8f70f7d5
char g26 = 0; // 0x8f70f7d6
char * g27; // 0x8f70f7dd
int32_t g28 = 0; // 0x8f7112f4
int32_t g29 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f67376c - 0x8f6739e7
int32_t validate_gpt_partition(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1; // 0x8f67376c_0
    g35 = a3;
    int32_t v2 = g37; // 0x8f67376c
    int32_t v3 = g38; // 0x8f67376c
    int32_t v4 = g39; // 0x8f67376c
    int32_t v5 = g40; // 0x8f67376c
    int32_t v6 = g41; // 0x8f67376c
    int32_t v7 = g42; // 0x8f67376c
    int32_t v8 = g33; // 0x8f67376c
    int32_t v9 = g30; // 0x8f67376c
    g41 = &g28;
    int32_t v10 = g28;
    g36 = v10;
    int32_t v11 = get_policy_executor((int32_t)"primary_gpt", a2, a3, v10, v1); // 0x8f673780
    g38 = v11;
    int32_t v12 = is_validation_enabled((char *)v11, a2, g35, g36); // 0x8f673788
    g40 = v12;
    if (v12 == 0) {
        // if_8f673790_0_true
        // branch -> 0x8f673990
        // 0x8f673990
        print_log(2, (int32_t)"engineer hw, skip gpt validation\n", g35, g36, (int32_t)a1, a2, a3, v10, v2, v3, v4, v5, v6);
        // branch -> 0x8f673994
        // 0x8f673994
        if (v10 != g28) {
            // 0x8f6739a8
            __stack_chk_fail();
            // branch -> 0x8f6739ac
        }
        // 0x8f6739ac
        return g40;
    }
    // 0x8f67379c
    if (g38 == 0) {
        // 0x8f6737a4
        print_log(0, (int32_t)"Failed to get policy executor for GPT\n", g35, g36, v1, a2, a3, v10, v2, v3, v4, v5, v6);
        // branch -> 0x8f6737b0
    }
    int32_t v13 = 0; // R1
    g35 = 0x8000;
    memset((char *)-0x70000000, 0, 0x8000);
    int32_t v14 = get_reset_gpt(-0x70000000, v13, g35, g36, v1, a2, a3, v10, v2, v3, v4, v5); // 0x8f6737c4
    g40 = v14;
    int32_t result; // 0x8f673998
    if (v14 == -1) {
        // if_8f6737d0_0_true
        // branch -> 0x8f673990
        // 0x8f673990
        print_log(0, (int32_t)"Failed to get reset GPT\n", g35, g36, (int32_t)a1, a2, a3, v10, v2, v3, v4, v5, v6);
        result = g40;
        // branch -> 0x8f673994
    } else {
        int32_t v15 = get_primary_gpt_partition(v14, v13, g35, g36, v1, a2); // 0x8f6737dc
        g39 = &g8;
        g42 = 1;
        *(char *)&g9 = 64;
        *(char *)&g17 = 127;
        g37 = 0;
        *(char *)&g10 = 0;
        g25 |= 4;
        *(char *)&g11 = 0;
        *(char *)&g12 = 0;
        g26 = (int32_t)g26 & -16 | 1;
        *(char *)&g13 = 0;
        *(char *)&g14 = 0;
        *(char *)&g15 = 0;
        *(char *)&g16 = 0;
        *(char *)&g18 = 0;
        *(char *)&g19 = 0;
        *(char *)&g20 = 0;
        *(char *)&g21 = 0;
        *(char *)&g22 = 0;
        *(char *)&g23 = 0;
        *(char *)&g24 = 0;
        g33 = v15;
        memcpy((char *)&g27, "backup_gpt", 72);
        int32_t v16 = g42; // 0x8f67386c
        int32_t v17;
        int32_t v18 = validate_partition(g33, -0x70000000, 0x8000, v16, v1, a2, a3, v10, v2, v3, v4, v5, v6, v7, v8, v9, v17, 0, 0, 0); // 0x8f673870
        g40 = v18;
        if (v18 != 0) {
            // 0x8f67387c
            print_log(g37, (int32_t)"Invalid primary GPT, validating backup GPT...\n", 0x8000, v16, v1, a2, a3, v10, v2, v3, v4, v5, v6);
            memset((char *)-0x70000000, g37, 0x8000);
            int32_t v19 = load_partition(g39, -0x70000000, 0, 0, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6, v7, v8, v9, v17, 0, 0, 0, 0); // 0x8f6738b4
            if (v19 != 0) {
                // if_8f6738bc_0_true
                // branch -> 0x8f673910
                // 0x8f673910
                print_log(-1, (int32_t)"failed to load backup GPT\n", 0, 0, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6);
                // branch -> 0x8f673994
                // 0x8f673994
                if (v10 != g28) {
                    // 0x8f6739a8
                    __stack_chk_fail();
                    // branch -> 0x8f6739ac
                }
                // 0x8f6739ac
                return -1;
            }
            int32_t v20 = 0x8000; // R2
            int32_t v21 = g42; // 0x8f6738d4
            if (validate_partition(g39, -0x70000000, 0x8000, v21, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6, v7, v8, v9, v17, 0, 0, 0) != 0) {
                // if_8f6738e0_0_true
                // branch -> 0x8f673910
                // 0x8f673910
                print_log(v19, (int32_t)"Invali backup GPT\n", v20, v21, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6);
                // branch -> 0x8f673994
                // 0x8f673994
                if (v10 != g28) {
                    // 0x8f6739a8
                    __stack_chk_fail();
                    // branch -> 0x8f6739ac
                }
                // 0x8f6739ac
                return -1;
            }
            // 0x8f6738ec
            if (write_gpt(0x8000, -0x70000000, v20, v21, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6, v7, v8, v9, v17, 0, 0, 0, 0, 0, 0, 0, 0) == 0) {
                // 0x8f673900
                result = 0;
                // branch -> 0x8f673994
            } else {
                // 0x8f673908
                // branch -> 0x8f673910
                // 0x8f673910
                print_log(-1, (int32_t)"Failed to restore primary GPT\n", v20, v21, 0x8000, 0, a3, v10, v2, v3, v4, v5, v6);
                result = -1;
                // branch -> 0x8f673994
            }
            // 0x8f673994
            if (v10 != g28) {
                // 0x8f6739a8
                __stack_chk_fail();
                // branch -> 0x8f6739ac
            }
            // 0x8f6739ac
            return result;
        }
        int32_t v22 = g38; // 0x8f67391c
        int32_t v23 = *(int32_t *)(v22 + 32); // 0x8f67391c
        g36 = v23;
        g31 = v22;
        int32_t v24 = g33; // 0x8f673924
        g32 = v24;
        int32_t v25 = g39; // 0x8f673928
        g35 = v25;
        g30 = -0x7098c6d0;
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v23)(v22, v24, v25, v23);
        if (g31 != 0) {
            // 0x8f673938
            g38 = 0;
            int32_t v26 = get_entry_name(g39, v24, v25, v23, v1, a2, a3, v10); // 0x8f673940
            int32_t v27 = get_entry_name(g33, v24, v25, v23, v1, a2, a3, v10); // 0x8f67394c
            g37 = 0x8000;
            print_log(g42, (int32_t)"try to update backup partition %s for %s\n", v26, v27, v1, a2, a3, v10, v2, v3, v4, v5, v6);
            if (store_partition(g39, -0x70000000, 0, 0, 0x8000, 0, a3, v10, v2) != 0) {
                // 0x8f673988
                // branch -> 0x8f673990
                // 0x8f673990
                print_log(-1, (int32_t)"Failed to update backup GPT\n", g35, g36, (int32_t)(char *)0x8000, 0, a3, v10, v2, v3, v4, v5, v6);
                // branch -> 0x8f673994
                // 0x8f673994
                if (v10 != g28) {
                    // 0x8f6739a8
                    __stack_chk_fail();
                    // branch -> 0x8f6739ac
                }
                // 0x8f6739ac
                return g40;
            }
        }
        // 0x8f673900
        result = 0;
        // branch -> 0x8f673994
    }
    // 0x8f673994
    if (v10 != g28) {
        // 0x8f6739a8
        __stack_chk_fail();
        // branch -> 0x8f6739ac
    }
    // 0x8f6739ac
    return result;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:18:51
