//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t connect_to_key(int32_t a1);
int32_t display_logo(int32_t a1, int32_t a2);
int32_t fan54046_get_ibuslim(int32_t a1);
int32_t fan540xx_get_ic_info_pn(void);
int32_t fboot_cmd_erase_validate(int32_t a1, int32_t a2, int32_t a3);
int32_t fboot_cmd_flash_permission_validate(int32_t a1, int32_t a2);
int32_t free_sparse_image(int32_t a1, int32_t a2, int32_t a3);
int32_t get_gpio_setting(int32_t a1, int32_t * a2, int32_t a3);
int32_t get_pmic_gpio_setting(int32_t a1, int32_t * a2, int32_t a3);
int32_t heap_init(int32_t a1, int32_t a2);
int32_t heap_realloc(char * a1);
int32_t initial_thread_func(int32_t a1, int32_t a2, int32_t a3);
int32_t keys_get_state(uint32_t a1);
int32_t mcs_bytes_to_mpint(int32_t a1);
int32_t mcs_mpint_to_bytes(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_multi_add(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_multi_convert_from_multi_digit_byte_len(int32_t * a1, int32_t a2, uint32_t a3);
int32_t mdp_clk_gating_ctrl(int32_t a1, int32_t a2);
int32_t mdp_get_revision(int32_t a1, int32_t a2, int32_t a3);
int32_t mdp_set_revision(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_intf_tg_setup(int32_t * a1);
int32_t oem_utag(int32_t a1, int32_t * a2);
int32_t ondraw(int32_t a1, int32_t a2, int32_t a3);
int32_t parse_sparse_image(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t platform_get_sclk_count(int32_t a1, int32_t a2, int32_t a3);
int32_t platform_uninit(char * a1, int32_t a2, int32_t a3);
int32_t target_mot_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t target_set_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t utag_parent_exists(int32_t a1);

// --------------------- Global Variables ---------------------

bool g41 = false; // LR
int32_t g42 = 0; // R1
int32_t g43 = 0; // R2
int32_t g44 = 0; // R3
int32_t g45 = 0; // R4
int32_t g46 = 0; // R5
int32_t g47 = 0; // R6
int32_t g48 = 0; // R7
int32_t g1 = -0x16d2bf8d; // 0x8f624998
int32_t g2 = -0x16d2bf10; // 0x8f6287bc
int32_t g3 = -0x1a60cfd4; // 0x8f6760e8
int32_t g4 = -0x1a60cfd4; // 0x8f676120
int32_t g5 = -0x1a60cfa8; // 0x8f676158
int32_t g6 = -0x1a60cf9c; // 0x8f6761bc
int32_t g7 = -0x1a60cf9c; // 0x8f67622c
int32_t g8 = -0x1a60cfa8; // 0x8f67629c
int32_t g9 = -0x1a60cfd0; // 0x8f676300
int32_t g10 = -0x1a60cf70; // 0x8f6763ac
int32_t g11 = 0x7325002c; // 0x8f682749
int32_t g12 = 0x402d2b00; // 0x8f686e33
char g13[2] = "/"; // 0x8f686fbc
int32_t g14 = 0x746e6300; // 0x8f6a4e20
int32_t g15 = 0x70750020; // 0x8f6a4f1e
char * g16 = "\xff\xff\xff\xff\xff\xff\xff\xff\xe8\xc0\x6a\x8f\xe8\xc0\x6a\x8f\x01"; // 0x8f6ac0e0
int32_t g17 = 1; // 0x8f6ac0f0
int32_t g18 = 6; // 0x8f6acab0
int32_t g19 = 0; // 0x8f6b8af8
char * g20; // 0x8f6e08d4
char * g21; // 0x8f6e08f8
char * g22; // 0x8f6e08f9
int32_t g23 = 0; // 0x8f6e091c
char * g24; // 0x8f6e0938
char * g25; // 0x8f6e0aac
int32_t g26 = 0; // 0x8f6e0af4
char * g27; // 0x8f6e0b34
int32_t g28 = 0; // 0x8f6e0be8
int32_t g29 = 0; // 0x8f6e0bec
int32_t g30 = 0; // 0x8f6e0bf0
int32_t g31 = 0; // 0x8f6e0bf4
int32_t g32 = 0; // 0x8f7112f4
int32_t g33 = 0; // 0x8f7114ac
char * g34; // 0x8f711580
char * g35; // 0x8f711588
char * g36; // 0x8f711589
int16_t g37 = 0; // 0x8f711592
int32_t g38 = 0; // 0x8f7125b8
int32_t g39 = 0; // 0x8f7125bc
int32_t g40 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f676500 - 0x8f6769a3
int32_t parse_sparse_image(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g45; // 0x8f676504
    int32_t v2 = g47; // 0x8f676504
    int32_t v3 = g32;
    int32_t v4 = (int32_t)a1; // R7
    char * mem = malloc(52); // 0x8f67651c
    int32_t v5 = (int32_t)mem; // 0x8f67651c_3
    g47 = v5;
    int32_t v6;
    int32_t v7;
    int32_t v8;
    int32_t v9;
    int32_t v10;
    int32_t v11;
    int32_t v12;
    int32_t v13;
    int32_t result2; // 0x8f676534
    if (mem == NULL) {
        // 0x8f676528
        print_log(-1, (int32_t)"Out of memory", a3, v3, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        result2 = g47;
        // branch -> 0x8f676908
    } else {
        int32_t v14 = 0; // R9
        *(int32_t *)(v5 + 4) = v5;
        int32_t v15 = v14; // R11
        *(int32_t *)(g47 + 20) = (int32_t)&g3;
        *(int32_t *)g47 = g47;
        *(int32_t *)(g47 + 24) = (int32_t)&g4;
        *(int32_t *)(g47 + 28) = (int32_t)&g5;
        *(int32_t *)(g47 + 32) = (int32_t)&g6;
        *(int32_t *)(g47 + 36) = (int32_t)&g7;
        *(int32_t *)(g47 + 40) = (int32_t)&g8;
        *(int32_t *)(g47 + 44) = (int32_t)&g9;
        *(int32_t *)(g47 + 48) = (int32_t)&g10;
        uint16_t v16 = *(int16_t *)(v4 + 8); // 0x8f676594
        int32_t v17 = v16; // 0x8f676594
        int32_t v18 = v17; // R3
        int32_t v19 = v17 + v4; // 0x8f67659c
        int32_t v20 = v19; // R8
        int32_t v21 = v17; // 0x8f6765a8
        if (v16 > 28) {
            int32_t v22 = v17 - 28; // 0x8f6765a0
            v18 = v22;
            v20 = v19 + v22;
            v21 = v22;
            // branch -> after_if_8f6765a4_0
        }
        // after_if_8f6765a4_0
        print_log(2, (int32_t)"=== Sparse Image Header ===\n", a3, v21, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        int32_t v23 = *(int32_t *)v4; // 0x8f6765b4
        print_log(2, (int32_t)"magic: 0x%x\n", v23, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        uint16_t v24 = *(int16_t *)(v4 + 4); // 0x8f6765c4
        print_log(2, (int32_t)"major_version: 0x%x\n", (int32_t)v24, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        uint16_t v25 = *(int16_t *)(v4 + 6); // 0x8f6765d4
        print_log(2, (int32_t)"minor_version: 0x%x\n", (int32_t)v25, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        uint16_t v26 = *(int16_t *)(v4 + 8); // 0x8f6765e4
        print_log(2, (int32_t)"file_hdr_sz: %d\n", (int32_t)v26, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        uint16_t v27 = *(int16_t *)(v4 + 10); // 0x8f6765f4
        print_log(2, (int32_t)"chunk_hdr_sz: %d\n", (int32_t)v27, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        int32_t v28 = *(int32_t *)(v4 + 12); // 0x8f676604
        print_log(2, (int32_t)"blk_sz: %d\n", v28, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        int32_t v29 = *(int32_t *)(v4 + 16); // 0x8f676614
        print_log(2, (int32_t)"total_blks: %d\n", v29, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        int32_t v30 = *(int32_t *)(v4 + 20); // 0x8f67661c
        print_log(2, (int32_t)"total_chunks: %d\n", v30, v18, v13, v12, v11, v10, v9, v8, v7, v6, 0);
        int32_t v31 = *(int32_t *)(v4 + 12); // 0x8f67662c
        int32_t v32 = *(int32_t *)(v4 + 16); // R2
        *(int32_t *)(g47 + 8) = v31;
        uint32_t v33 = v32; // 0x8f676638
        uint64_t v34 = (int64_t)v31 * (int64_t)v33; // 0x8f676638
        int32_t v35 = v34; // 0x8f676638
        int32_t v36 = v34 / 0x100000000; // 0x8f676638
        *(int32_t *)(g47 + 12) = v33;
        g45 = 0;
        int32_t v37 = *(int32_t *)(v4 + 20); // 0x8f676650295
        v18 = v37;
        int32_t v38; // 0x8f6768ec4
        int32_t v39; // 0x8f6768ec7
        int32_t v40; // R0
        int32_t result; // 0x8f676924_2
        int32_t v41; // 0x2179
        int32_t v42;
        int32_t v43;
        int32_t v44;
        int32_t v45;
        int32_t v46; // 0x8f6768f8
        int32_t v47; // 0x8f6768e8
        int32_t v48; // 0x8f6768e0
        int32_t v49; // 0x8f6768f0
        if (v15 < v37) {
            v45 = 0;
            v43 = 0;
            // 0x8f6768dc
            v48 = *(int32_t *)(v4 + 16);
            v47 = v14;
            v32 = v47;
            print_log(1, (int32_t)"Wrote %d blocks, expected to write %d blocks\n", v47, v48, v43, v45, v11, v10, v9, v8, v35, v36, 0);
            v49 = *(int32_t *)(v4 + 16);
            if (v14 == v49) {
                // if_8f6768f8_0_true
                v46 = g47 + 20;
                v40 = v46;
                v41 = v46;
                // branch -> 0x8f676908
            } else {
                // if_8f6768fc_0_true
                v44 = v45;
                v42 = v43;
                v39 = v10;
                v38 = v11;
                // branch -> 0x8f6768ac
                // 0x8f6768ac
                print_log(-1, (int32_t)"Sparse image block failure", v32, v49, v42, v44, v38, v39, v9, v8, v35, v36, 0);
                clear_sparse_data_list(g47, (int32_t)"Sparse image block failure", v32, v49, v42, v44, v38, v39);
                free((char *)g47);
                v40 = 0;
                v41 = 0;
                // branch -> 0x8f676908
            }
            // 0x8f676908
            if (v3 != g32) {
                // 0x8f67691c
                __stack_chk_fail();
                result = v40;
                // branch -> 0x8f676920
            } else {
                result = v41;
            }
            // 0x8f676920
            g45 = v1;
            g47 = v2;
            return result;
        }
        int64_t v50 = 0;
        int64_t v51 = 0;
        while (true) {
            int32_t v52 = v51;
            int32_t v53 = v50;
            print_log(2, (int32_t)"=== Chunk Header ===\n", v32, v37, v52, v53, v11, v10, v9, v8, v35, v36, 0);
            int32_t v54 = v20; // 0x8f676670
            int32_t v55 = v54 + 12; // R10
            uint16_t v56 = *(int16_t *)v54; // 0x8f676674
            print_log(2, (int32_t)"chunk_type: 0x%x\n", (int32_t)v56, v18, v52, v53, v11, v10, v9, v8, v35, v36, 0);
            int32_t v57 = *(int32_t *)(v20 + 4); // 0x8f676684
            print_log(2, (int32_t)"chunk_data_sz: 0x%llx\n", v57, v18, v52, v53, v11, v10, v9, v8, v35, v36, 0);
            int32_t v58 = *(int32_t *)(v20 + 8); // 0x8f676694
            print_log(2, (int32_t)"total_size: 0x%x\n", v58, v18, v52, v53, v11, v10, v9, v8, v35, v36, 0);
            int32_t v59 = v20; // 0x8f6766a0
            uint32_t v60 = *(int32_t *)(v59 + 4); // 0x8f6766a0
            uint16_t v61 = *(int16_t *)(v4 + 10); // 0x8f6766a4
            int32_t v62 = v61; // 0x8f6766a4
            int64_t v63 = v60; // 0x8f6766a8
            int64_t v64 = (int64_t)*(int32_t *)(v4 + 12); // 0x8f6766a8
            uint64_t v65 = v63 * v64; // 0x8f6766a8
            int32_t v66 = v65; // 0x8f6766a8
            int32_t v67 = v65 / 0x100000000; // 0x8f6766a8
            g45 = v66;
            if (v61 > 12) {
                // if_8f6766b0_0_true
                v18 = v62 - 12;
                // branch -> after_if_8f6766b0_0
            }
            int64_t v68 = 0x100000000 * v64; // 0x8f6766bc
            int64_t v69 = v63 * v51 + (v68 | v50); // 0x8f6766bc
            int32_t v70 = v69; // 0x8f6766bc
            int64_t v71 = v69 / 0x100000000; // 0x8f6766bc
            int32_t v72 = v71; // 0x8f6766bc
            g45 = v70;
            if (v61 > 12) {
                // if_8f6766c4_0_true
                v55 += v18;
                // branch -> after_if_8f6766c4_0
            }
            // after_if_8f6766c4_0
            v32 = v35;
            bool v73 = false; // 0x8f6766dc
            bool v74 = v72 >= v36; // 0x8f6766dc
            if (v72 == v36) {
                // if_8f6766d0_0_true
                v73 = v70 == v35;
                v74 = v70 >= v35;
                // branch -> after_if_8f6766d0_0
            }
            // after_if_8f6766d0_0
            if (v74 && v73 ^ true) {
                // after_if_8f6766d8_0.thread
                v44 = v53;
                v42 = v52;
                v39 = v67;
                v38 = v66;
                // branch -> 0x8f6768ac
                // 0x8f6768ac
                print_log(0, (int32_t)"Bogus chunk data: data size exceeds target image size\n", v32, v36, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                clear_sparse_data_list(g47, (int32_t)"Bogus chunk data: data size exceeds target image size\n", v32, v36, v42, v44, v38, v39);
                free((char *)g47);
                // branch -> 0x8f676908
                // 0x8f676908
                if (v3 != g32) {
                    // 0x8f67691c
                    __stack_chk_fail();
                    // branch -> 0x8f676920
                }
                // 0x8f676920
                g45 = v1;
                g47 = v2;
                return 0;
            }
            uint16_t v75 = *(int16_t *)v59; // 0x8f6766e0
            int32_t v76 = (int32_t)v75 - 0xcac1; // 0x8f6766e8
            v18 = v76;
            int32_t v77; // 0x8f676718
            int64_t v78;
            int64_t v79;
            int32_t v80; // 0x8f676710
            switch (v75) {
                default: {
                    // 0x8f6768a4
                    v44 = v53;
                    v42 = v52;
                    v39 = v67;
                    v38 = v66;
                    // branch -> 0x8f6768ac
                    // 0x8f6768ac
                    print_log(-1, (int32_t)"Unknown chunk type", v32, v76, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                    clear_sparse_data_list(g47, (int32_t)"Unknown chunk type", v32, v18, v42, v44, v38, v39);
                    free((char *)g47);
                    // branch -> 0x8f676908
                    // 0x8f676908
                    if (v3 != g32) {
                        // 0x8f67691c
                        __stack_chk_fail();
                        // branch -> 0x8f676920
                    }
                    // 0x8f676920
                    g45 = v1;
                    g47 = v2;
                    return 0;
                }
                case -0x353f: {
                    // 0x8f676708
                    g45 = v62;
                    v80 = *(int32_t *)(v59 + 8);
                    v32 = v80;
                    v18 = 0;
                    uint64_t v81 = (int64_t)v61 * v63 + v68; // 0x8f676718
                    v77 = v81;
                    g45 = v77;
                    if ((int32_t)(v81 / 0x100000000) != 0) {
                        // after_if_8f676728_0.thread38
                        v44 = v53;
                        v42 = v52;
                        v39 = v67;
                        v38 = v66;
                        // branch -> 0x8f6768ac
                        // 0x8f6768ac
                        print_log(-1, (int32_t)"Bogus chunk size for chunk type Raw", v32, 0, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                        clear_sparse_data_list(g47, (int32_t)"Bogus chunk size for chunk type Raw", v32, v18, v42, v44, v38, v39);
                        free((char *)g47);
                        // branch -> 0x8f676908
                        // 0x8f676908
                        if (v3 != g32) {
                            // 0x8f67691c
                            __stack_chk_fail();
                            // branch -> 0x8f676920
                        }
                        // 0x8f676920
                        g45 = v1;
                        g47 = v2;
                        return 0;
                    }
                    break;
                }
                case -0x353e: {
                    int32_t v82 = *(int32_t *)(v59 + 8); // 0x8f67679c
                    v18 = v82;
                    int32_t v83 = v62 + 4; // 0x8f6767a0
                    g45 = v83;
                    if (v82 != v83) {
                        // if_8f6767a8_0_true
                        v44 = v53;
                        v42 = v52;
                        v39 = v67;
                        v38 = v66;
                        // branch -> 0x8f6768ac
                        // 0x8f6768ac
                        print_log(-1, (int32_t)"Bogus chunk size for chunk type FILL", v32, v82, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                        clear_sparse_data_list(g47, (int32_t)"Bogus chunk size for chunk type FILL", v32, v18, v42, v44, v38, v39);
                        free((char *)g47);
                        // branch -> 0x8f676908
                        // 0x8f676908
                        if (v3 != g32) {
                            // 0x8f67691c
                            __stack_chk_fail();
                            // branch -> 0x8f676920
                        }
                        // 0x8f676920
                        g45 = v1;
                        g47 = v2;
                        return 0;
                    }
                    // 0x8f6767b4
                    g45 = *(int32_t *)v55;
                    char * mem2 = malloc(48); // 0x8f6767bc
                    int32_t v84 = (int32_t)mem2; // R5
                    if (mem2 == NULL) {
                        // 0x8f676740
                        v44 = v53;
                        v42 = v52;
                        v39 = v67;
                        v38 = v66;
                        // branch -> 0x8f6768ac
                        // 0x8f6768ac
                        print_log(-1, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                        clear_sparse_data_list(g47, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39);
                        free((char *)g47);
                        // branch -> 0x8f676908
                    } else {
                        // 0x8f6767c8
                        memset(mem2, 0, 48);
                        v18 = *(int32_t *)g47;
                        *(int32_t *)(v84 + 40) = v15;
                        v55 += 4;
                        int32_t v85 = v84; // 0x8f6767e4
                        *(int32_t *)v85 = v18;
                        *(int32_t *)(v85 + 4) = g47;
                        *(int32_t *)(v18 + 4) = v84;
                        *(char *)(v84 + 8) = 1;
                        v32 = v52;
                        *(int32_t *)g47 = v84;
                        int32_t v86 = v84; // 0x8f6767fc
                        *(int32_t *)(v86 + 24) = v66;
                        *(int32_t *)(v86 + 28) = v67;
                        int32_t v87 = v84; // 0x8f676800
                        *(int32_t *)(v87 + 16) = v32;
                        *(int32_t *)(v87 + 20) = v53;
                        *(char *)(v84 + 32) = 0;
                        *(int32_t *)(v84 + 36) = g45;
                        v14 += *(int32_t *)(v20 + 4);
                        v78 = v71;
                        v79 = v69;
                        // branch -> 0x8f6768c8
                      lab_0x8f6768c8_3:;
                        int32_t v88 = v79;
                        g45 = v88;
                        int32_t v89 = v78;
                        int32_t v90 = v15 + 1; // 0x8f6768cc
                        v15 = v90;
                        v20 = v55;
                        int32_t v91 = *(int32_t *)(v4 + 20); // 0x8f676650
                        v18 = v91;
                        if (v90 < v91) {
                            v8 = v89;
                            v45 = v89;
                            v11 = v66;
                            v10 = v67;
                            v9 = v88;
                            v43 = v88;
                            // break (via goto) -> 0x8f6768dc
                            goto lab_0x8f6768dc;
                        }
                        v37 = v91;
                        v50 = v78;
                        v11 = v66;
                        v10 = v67;
                        v9 = v88;
                        v8 = v89;
                        v51 = v79;
                        // continue -> 0x8f67665c
                        continue;
                    }
                    // 0x8f676908
                    if (v3 != g32) {
                        // 0x8f67691c
                        __stack_chk_fail();
                        // branch -> 0x8f676920
                    }
                    // 0x8f676920
                    g45 = v1;
                    g47 = v2;
                    return 0;
                }
                case -0x353d: {
                    char * mem3 = malloc(48); // 0x8f676820
                    g45 = (int32_t)mem3;
                    if (mem3 == NULL) {
                        // 0x8f676740
                        v44 = v53;
                        v42 = v52;
                        v39 = v67;
                        v38 = v66;
                        // branch -> 0x8f6768ac
                        // 0x8f6768ac
                        print_log(-1, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                        clear_sparse_data_list(g47, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39);
                        free((char *)g47);
                        // branch -> 0x8f676908
                    } else {
                        // 0x8f67682c
                        memset(mem3, 0, 48);
                        v18 = *(int32_t *)g47;
                        *(int32_t *)(g45 + 40) = v15;
                        int32_t v92 = g45; // 0x8f676844
                        *(int32_t *)v92 = v18;
                        *(int32_t *)(v92 + 4) = g47;
                        *(int32_t *)(v18 + 4) = g45;
                        *(char *)(g45 + 8) = 2;
                        v32 = v52;
                        *(int32_t *)g47 = g45;
                        int32_t v93 = g45; // 0x8f67685c
                        *(int32_t *)(v93 + 24) = v66;
                        *(int32_t *)(v93 + 28) = v67;
                        int32_t v94 = g45; // 0x8f676860
                        *(int32_t *)(v94 + 16) = v32;
                        *(int32_t *)(v94 + 20) = v53;
                        *(char *)(g45 + 32) = 0;
                        v14 += *(int32_t *)(v20 + 4);
                        v78 = v71;
                        v79 = v69;
                        // branch -> 0x8f6768c8
                        goto lab_0x8f6768c8_3;
                    }
                    // 0x8f676908
                    if (v3 != g32) {
                        // 0x8f67691c
                        __stack_chk_fail();
                        // branch -> 0x8f676920
                    }
                    // 0x8f676920
                    g45 = v1;
                    g47 = v2;
                    return 0;
                }
                case -0x353c: {
                    int32_t v95 = *(int32_t *)(v59 + 8); // 0x8f676878
                    v18 = v95;
                    if (v95 == v62) {
                        // 0x8f67688c
                        g45 = v52;
                        v14 += v60;
                        v55 += v66;
                        v78 = v50;
                        v79 = v51;
                        // branch -> 0x8f6768c8
                        goto lab_0x8f6768c8_3;
                    } else {
                        // if_8f676880_0_true
                        v44 = v53;
                        v42 = v52;
                        v39 = v67;
                        v38 = v66;
                        // branch -> 0x8f6768ac
                        // 0x8f6768ac
                        print_log(-1, (int32_t)"Bogus chunk size for chunk type Dont Care", v32, v95, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                        clear_sparse_data_list(g47, (int32_t)"Bogus chunk size for chunk type Dont Care", v32, v18, v42, v44, v38, v39);
                        free((char *)g47);
                        // branch -> 0x8f676908
                    }
                    // 0x8f676908
                    if (v3 != g32) {
                        // 0x8f67691c
                        __stack_chk_fail();
                        // branch -> 0x8f676920
                    }
                    // 0x8f676920
                    g45 = v1;
                    g47 = v2;
                    return 0;
                }
            }
            // after_if_8f676720_0
            if (v80 != v77) {
                // after_if_8f676728_0
                v44 = v53;
                v42 = v52;
                v39 = v67;
                v38 = v66;
                // branch -> 0x8f6768ac
                // 0x8f6768ac
                print_log(-1, (int32_t)"Bogus chunk size for chunk type Raw", v32, 0, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                clear_sparse_data_list(g47, (int32_t)"Bogus chunk size for chunk type Raw", v32, v18, v42, v44, v38, v39);
                free((char *)g47);
                // branch -> 0x8f676908
                // 0x8f676908
                if (v3 != g32) {
                    // 0x8f67691c
                    __stack_chk_fail();
                    // branch -> 0x8f676920
                }
                // 0x8f676920
                g45 = v1;
                g47 = v2;
                return 0;
            }
            char * mem4 = malloc(48); // 0x8f676734
            g45 = (int32_t)mem4;
            if (mem4 == NULL) {
                // 0x8f676740
                v44 = v53;
                v42 = v52;
                v39 = v67;
                v38 = v66;
                // branch -> 0x8f6768ac
                // 0x8f6768ac
                print_log(-1, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39, v70, v72, v35, v36, 0);
                clear_sparse_data_list(g47, (int32_t)"Out of memory!", v32, v18, v42, v44, v38, v39);
                free((char *)g47);
                // branch -> 0x8f676908
            } else {
                // 0x8f67674c
                v32 = 48;
                memset(mem4, 0, 48);
                v18 = *(int32_t *)g47;
                *(int32_t *)(g45 + 40) = v15;
                int32_t v96 = g45; // 0x8f676764
                *(int32_t *)v96 = v18;
                *(int32_t *)(v96 + 4) = g47;
                *(int32_t *)(v18 + 4) = g45;
                v18 = 0;
                int32_t v97 = g45; // 0x8f676770
                int32_t v98;
                *(int32_t *)(v97 + 16) = v98;
                int32_t v99;
                *(int32_t *)(v97 + 20) = v99;
                int32_t v100;
                v40 = v100;
                *(char *)(g45 + 8) = (char)v18;
                *(char *)(g45 + 32) = (char)v18;
                *(int32_t *)(g45 + 36) = v55;
                v55 += v40;
                *(int32_t *)g47 = g45;
                v14 += *(int32_t *)(v20 + 4);
                int32_t v101 = g45; // 0x8f676794
                *(int32_t *)(v101 + 24) = v40;
                int32_t v102;
                *(int32_t *)(v101 + 28) = v102;
                v78 = v71;
                v79 = v69;
                // branch -> 0x8f6768c8
                goto lab_0x8f6768c8_3;
            }
            // 0x8f676908
            if (v3 != g32) {
                // 0x8f67691c
                __stack_chk_fail();
                // branch -> 0x8f676920
            }
            // 0x8f676920
            g45 = v1;
            g47 = v2;
            return 0;
        }
      lab_0x8f6768dc:
        // 0x8f6768dc
        v48 = *(int32_t *)(v4 + 16);
        v47 = v14;
        v32 = v47;
        print_log(1, (int32_t)"Wrote %d blocks, expected to write %d blocks\n", v47, v48, v43, v45, v11, v10, v9, v8, v35, v36, 0);
        v49 = *(int32_t *)(v4 + 16);
        if (v14 == v49) {
            // if_8f6768f8_0_true
            v46 = g47 + 20;
            v40 = v46;
            v41 = v46;
            // branch -> 0x8f676908
        } else {
            // if_8f6768fc_0_true
            v44 = v45;
            v42 = v43;
            v39 = v10;
            v38 = v11;
            // branch -> 0x8f6768ac
            // 0x8f6768ac
            print_log(-1, (int32_t)"Sparse image block failure", v32, v49, v42, v44, v38, v39, v9, v8, v35, v36, 0);
            clear_sparse_data_list(g47, (int32_t)"Sparse image block failure", v32, v49, v42, v44, v38, v39);
            free((char *)g47);
            v40 = 0;
            v41 = 0;
            // branch -> 0x8f676908
        }
        // 0x8f676908
        if (v3 != g32) {
            // 0x8f67691c
            __stack_chk_fail();
            result = v40;
            // branch -> 0x8f676920
        } else {
            result = v41;
        }
        // 0x8f676920
        g45 = v1;
        g47 = v2;
        return result;
    }
    // 0x8f676908
    if (v3 != g32) {
        // 0x8f67691c
        __stack_chk_fail();
        // branch -> 0x8f676920
    }
    // 0x8f676920
    g45 = v1;
    g47 = v2;
    return result2;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strstr(char * haystack, const char * needle);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:25:51
