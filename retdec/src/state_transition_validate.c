//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t backup_needed(int32_t a1, int32_t a2, int32_t a3);
int32_t check_security_version(int32_t a1, uint32_t a2, uint32_t a3);
int32_t detect_current_secure_state(char * a1, int32_t a2);
int32_t get_block_size(int32_t a1, int32_t a2, int32_t a3);
int32_t get_current_secure_state(int32_t a1, int32_t a2);
int32_t get_hab_signature_offset(int32_t a1, int32_t a2);
int32_t get_hab_signature_size(int32_t a1, int32_t a2);
int32_t get_image_version(int32_t a1, int32_t a2, int32_t a3);
int32_t get_output_block_count(int32_t a1, int32_t a2, int32_t a3);
int32_t get_partition_version(int32_t a1);
int32_t get_unlock_data(int32_t * a1, int32_t a2);
int32_t hab_policy_init(void);
int32_t lock_phone(int32_t a1, int32_t a2);
int32_t locking_phone(int32_t a1, int32_t a2, int32_t a3);
int32_t move_to_verified(int32_t a1, int32_t a2, int32_t a3);
int32_t move_to_verified_validator(int32_t a1, int32_t a2, int32_t a3);
int32_t reset_current_secure_state(int32_t a1, int32_t result, int32_t a3);
int32_t state_transition_validate(int32_t a1);
int32_t transit_to_state(int32_t a1, int32_t a2, int32_t (*a3)(int32_t), int32_t a4);
int32_t validate_hab_sparse_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t verify_hab_image(int32_t a1, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g17 = 0; // LR
int32_t g18 = 0; // R0
int32_t g19 = 0; // R1
int32_t g20 = 0; // R10
int32_t g21 = 0; // R2
int32_t g22 = 0; // R3
int32_t g23 = 0; // R4
int32_t g24 = 0; // R5
int32_t g25 = 0; // R6
int32_t g26 = 0; // R7
int32_t g27 = 0; // R8
int32_t g28 = 0; // R9
int32_t g1 = 0; // 0x8f6b000c
int32_t g2 = 0; // 0x8f6b0048
int32_t g3 = 0; // 0x8f6b004c
int32_t g4 = 0; // 0x8f6b0074
int32_t g5 = 0; // 0x8f6b0078
char * g6; // 0x8f710a25
int32_t g7 = 0; // 0x8f710a26
char g8 = 0; // 0x8f710c22
char g9 = 0; // 0x8f710c23
char g10 = 0; // 0x8f710c24
char g11 = 0; // 0x8f710c25
int32_t g12 = 0; // 0x8f710c30
int32_t g13 = 0; // 0x8f710c34
int32_t g14 = 0; // 0x8f7112f4
int32_t g15 = 0; // 0x8f71302c
int32_t g16 = 0; // 0x8f713044

// ------------------------ Functions -------------------------

// Address range: 0x8f6750a4 - 0x8f67520b
int32_t state_transition_validate(int32_t a1) {
    int32_t v1 = g23; // 0x8f6750a4
    int32_t v2 = g24; // 0x8f6750a4
    int32_t v3 = g25; // 0x8f6750a4
    g24 = a1;
    g25 = &g14;
    int32_t v4 = g14;
    int32_t v5 = get_current_secure_state(a1, g19); // 0x8f6750b8
    uint32_t v6 = (v5 + 255) % 256; // 0x8f6750c4
    int32_t result; // 0x8f6751e8_2
    int32_t v7;
    int32_t v8;
    if (v6 <= 1) {
        // 0x8f6750d0
        g19 = (int32_t)"Transition is disallowed\n";
        print_log(0, (int32_t)"Transition is disallowed\n", g21, v6, a1, v4, v1, v2, v3, g17, v7, 0, 0);
        g18 = 12;
        // branch -> 0x8f6751d0
        // 0x8f6751d0
        g21 = v4;
        v8 = g14;
        g22 = v8;
        if (v4 != v8) {
            // 0x8f6751e0
            __stack_chk_fail();
            result = g18;
            // branch -> 0x8f6751e4
        } else {
            result = 12;
        }
        // 0x8f6751e4
        g23 = v1;
        g24 = v2;
        g25 = v3;
        return result;
    }
    int32_t v9 = g24 - 3; // 0x8f6750e4
    switch (g24) {
        default: {
            // 0x8f6751b8
            g19 = (int32_t)"Unsupported state transition from %d to %d\n";
            print_log(0, (int32_t)"Unsupported state transition from %d to %d\n", v5, g24, a1, v4, v1, v2, v3, g17, v7, 0, 0);
            // branch -> 0x8f6751cc
            // 0x8f6751cc
            g18 = 13;
            // branch -> 0x8f6751d0
            // 0x8f6751d0
            g21 = v4;
            v8 = g14;
            g22 = v8;
            if (v4 != v8) {
                // 0x8f6751e0
                __stack_chk_fail();
                result = g18;
                // branch -> 0x8f6751e4
            } else {
                result = 13;
            }
            // 0x8f6751e4
            g23 = v1;
            g24 = v2;
            g25 = v3;
            return result;
        }
        case 3: {
            // 0x8f675134
            if (v5 != 5) {
                // 0x8f67513c
                g19 = (int32_t)"Need pre-locking state for lock\n";
                print_log(0, (int32_t)"Need pre-locking state for lock\n", g21, v9, a1, v4, v1, v2, v3, g17, v7, 0, 0);
                g18 = 11;
                // branch -> 0x8f6751d0
                // 0x8f6751d0
                g21 = v4;
                v8 = g14;
                g22 = v8;
                if (v4 != v8) {
                    // 0x8f6751e0
                    __stack_chk_fail();
                    result = g18;
                    // branch -> 0x8f6751e4
                } else {
                    result = 11;
                }
                // 0x8f6751e4
                g23 = v1;
                g24 = v2;
                g25 = v3;
                return result;
            }
            break;
        }
        case 4: {
            // 0x8f675150
            if (v5 != 3) {
                // 0x8f675158
                if (is_verified_boot_flow(v5, g19, g21, v9) == 0 || v5 != 6) {
                    // 0x8f67516c
                    g19 = (int32_t)"Invalid pre-state %d to unlocked\n";
                    // branch -> 0x8f675174
                    // 0x8f675174
                    print_log(0, (int32_t)"Invalid pre-state %d to unlocked\n", v5, v9, a1, v4, v1, v2, v3, g17, v7, 0, 0);
                    g18 = 10;
                    // branch -> 0x8f6751d0
                    // 0x8f6751d0
                    g21 = v4;
                    v8 = g14;
                    g22 = v8;
                    if (v4 != v8) {
                        // 0x8f6751e0
                        __stack_chk_fail();
                        result = g18;
                        // branch -> 0x8f6751e4
                    } else {
                        result = 10;
                    }
                    // 0x8f6751e4
                    g23 = v1;
                    g24 = v2;
                    g25 = v3;
                    return result;
                }
            }
            break;
        }
        case 5: {
            // 0x8f675104
            if (v5 != 4) {
                // 0x8f675114
                if (is_verified_boot_flow(v5, g19, g21, v9) == 0 || v5 != 6) {
                    // 0x8f675128
                    g19 = (int32_t)"Invalid pre-state: %d to locking\n";
                    // branch -> 0x8f675174
                    // 0x8f675174
                    print_log(0, (int32_t)"Invalid pre-state: %d to locking\n", v5, v9, a1, v4, v1, v2, v3, g17, v7, 0, 0);
                    g18 = 10;
                    // branch -> 0x8f6751d0
                    // 0x8f6751d0
                    g21 = v4;
                    v8 = g14;
                    g22 = v8;
                    if (v4 != v8) {
                        // 0x8f6751e0
                        __stack_chk_fail();
                        result = g18;
                        // branch -> 0x8f6751e4
                    } else {
                        result = 10;
                    }
                    // 0x8f6751e4
                    g23 = v1;
                    g24 = v2;
                    g25 = v3;
                    return result;
                }
            }
            break;
        }
        case 6: {
            // 0x8f675184
            if (is_verified_boot_flow(v5, g19, g21, v9) == 0) {
                // 0x8f675190
                g19 = (int32_t)"Verified boot flow is not enabled\n";
                print_log(0, (int32_t)"Verified boot flow is not enabled\n", g21, v9, a1, v4, v1, v2, v3, g17, v7, 0, 0);
                // branch -> 0x8f6751cc
                // 0x8f6751cc
                g18 = 13;
                // branch -> 0x8f6751d0
                // 0x8f6751d0
                g21 = v4;
                v8 = g14;
                g22 = v8;
                if (v4 != v8) {
                    // 0x8f6751e0
                    __stack_chk_fail();
                    result = g18;
                    // branch -> 0x8f6751e4
                } else {
                    result = 13;
                }
                // 0x8f6751e4
                g23 = v1;
                g24 = v2;
                g25 = v3;
                return result;
            }
            uint32_t v10 = (v5 + 253) % 256; // 0x8f6751a0
            int32_t v11; // 0x8f6751e8_25
            if (v10 < 2) {
                // 0x8f67510c
                g18 = 0;
                v11 = 0;
                // branch -> 0x8f6751d0
            } else {
                // 0x8f6751ac
                g19 = (int32_t)"Invalid pre-state %d to verified\n";
                // branch -> 0x8f675174
                // 0x8f675174
                print_log(0, (int32_t)"Invalid pre-state %d to verified\n", v5, v10, a1, v4, v1, v2, v3, g17, v7, 0, 0);
                g18 = 10;
                v11 = 10;
                // branch -> 0x8f6751d0
            }
            // 0x8f6751d0
            g21 = v4;
            v8 = g14;
            g22 = v8;
            if (v4 != v8) {
                // 0x8f6751e0
                __stack_chk_fail();
                result = g18;
                // branch -> 0x8f6751e4
            } else {
                result = v11;
            }
            // 0x8f6751e4
            g23 = v1;
            g24 = v2;
            g25 = v3;
            return result;
        }
    }
    // 0x8f67510c
    g18 = 0;
    // branch -> 0x8f6751d0
    // 0x8f6751d0
    g21 = v4;
    v8 = g14;
    g22 = v8;
    if (v4 != v8) {
        // 0x8f6751e0
        __stack_chk_fail();
        result = g18;
        // branch -> 0x8f6751e4
    } else {
        result = 0;
    }
    // 0x8f6751e4
    g23 = v1;
    g24 = v2;
    g25 = v3;
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 21
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:53:40
