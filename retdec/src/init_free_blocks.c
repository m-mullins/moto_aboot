//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t allocate_sp_block(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t clear_sparse_data_list(int32_t a1, int32_t a2);
int32_t create_sp_block(int32_t a1, int32_t a2);
int32_t flush_sp_header(void);
int32_t free_sparse_data(char * a1, int32_t a2);
int32_t get_entry_index_by_name(char * str, int32_t a2, int32_t a3);
int32_t get_first_sparse_data(int32_t a1, int32_t a2, int32_t a3);
int32_t get_last_sparse_data(int32_t a1, int32_t a2, int32_t a3);
int32_t get_next_sparse_data(int32_t a1, int32_t a2, int32_t a3);
int32_t get_output_block_count(int32_t a1, int32_t a2, int32_t a3);
int32_t get_prev_sparse_data(int32_t a1, int32_t a2, int32_t a3);
int32_t init_free_blocks(void);
int32_t init_sp_partition(char * a1, int32_t a2);
int32_t is_sparse_image(int32_t * a1, int32_t a2, int32_t a3);
int32_t move_to_sparse_data(int32_t a1, int32_t result, int32_t a3);
int32_t remove_sparse_data(int32_t a1, int32_t a2);
int32_t speedo_find(void);
int32_t speedo_start(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g18 = 0; // R0
int32_t g19 = 0; // R1
int32_t g20 = 0; // R2
int32_t g21 = 0; // R3
int32_t g22 = 0; // R4
int32_t g23 = 0; // R5
int32_t g24 = 0; // R6
int32_t g25 = 0; // R7
int32_t g26 = 0; // R8
int32_t g1 = 1; // 0x8f6ac0f0
int32_t g2 = 0; // 0x8f710c38
int32_t g3 = 0; // 0x8f710c3c
int32_t g4 = 0; // 0x8f710c40
int32_t g5 = 0; // 0x8f710c44
char * g6; // 0x8f710c48
int32_t g7 = 0; // 0x8f710c50
int32_t g8 = 0; // 0x8f710c60
int32_t g9 = 0; // 0x8f710c64
int32_t g10 = 0; // 0x8f710c68
char * g11; // 0x8f710c70
int32_t g12 = 0; // 0x8f710e48
int32_t g13 = 0; // 0x8f710e78
int32_t g14 = 0; // 0x8f710e7c
int32_t g15 = 0; // 0x8f710e80
int32_t g16 = 0; // 0x8f710e84
int32_t g17 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f676db4 - 0x8f676f97
int32_t init_free_blocks(void) {
    // 0x8f676db4
    g25 = &g13;
    g24 = &g4;
    g23 = &g17;
    g22 = &g2;
    int32_t v1 = g17;
    g3 = &g2;
    g2 = &g2;
    int32_t v2 = create_sp_block(g13 - 1024, g4 + 1024); // 0x8f676dec
    int32_t v3 = (int32_t)&g6; // R11
    *(int32_t *)v2 = g2;
    *(int32_t *)(v2 + 4) = g22;
    *(int32_t *)g22 = v2;
    *(int32_t *)(g2 + 4) = v2;
    uint32_t v4 = g4;
    uint32_t v5 = g13;
    int32_t v6;
    int32_t v7;
    int32_t v8;
    int32_t v9;
    int32_t v10;
    int32_t v11;
    print_log(2, (int32_t)"add root block: block [0x%llx, 0x%llx]\n", v5 - 1024, g14 - (int32_t)(v5 < 1024), v4 + 1024, (int32_t)(v4 > 0xfffffbff) + g5, v11, v10, v9, v8, v7, v6, 0);
    int32_t v12 = g22; // 0x8f676e30
    int32_t v13 = v3; // 0x8f676e4c
    // branch -> 0x8f676e34
  lab_0x8f676e34:;
    int32_t v14; // 0x8f676f5c13
    int32_t v15; // 0x8f676f5c15
    int32_t v16; // 0x8f676f5c17
    int32_t v17; // 0x8f676f5c20
    int32_t v18; // 0x8f676f5c22
    int32_t v19; // 0x8f676f5c25
    int32_t v20; // 0x8f676f5c1
    int32_t v21; // 0x8f676f5c3
    int32_t v22; // 0x8f676f5c5
    int32_t v23; // 0x8f676f5c7
    int32_t v24; // 0x8f676f5c11
    int32_t v25; // 0x8f676f5c9
    while (true) {
        int32_t v26 = v13; // 0x8f676f20
        v19 = v6;
        v17 = v7;
        v15 = v8;
        v24 = v9;
        v23 = v10;
        v21 = v11;
        int32_t v27; // 0x8f676f20
        if (*(char *)(v13 + 40) != 0) {
            int32_t v28 = *(int32_t *)(v13 + 56); // 0x8f676e40
            g24 = v28;
            int32_t v29 = *(int32_t *)(v13 + 60); // 0x8f676e40
            g25 = v29;
            if (v28 != v29) {
                int32_t v30 = *(int32_t *)(v13 + 64); // 0x8f676e4c
                g22 = v30;
                int32_t v31 = *(int32_t *)(v13 + 68); // 0x8f676e4c
                g23 = v31;
                int32_t v32 = *(int32_t *)(v12 + 4); // 0x8f676e50
                int32_t v33 = v32; // R10
                uint32_t v34 = v30 + v28; // 0x8f676e54
                uint32_t v35 = v31 + v29 + (int32_t)(v34 < v30); // 0x8f676e58
                int32_t v36 = v29; // 0x8f676f58
                int32_t v37 = v28; // 0x8f676f54
                int32_t v38 = v31; // 0x8f676f4c
                int32_t v39 = v30; // 0x8f676f4c
                int32_t v40 = v6; // 0x8f676f5c23
                int32_t v41 = v7; // 0x8f676f5c18
                int32_t v42 = v8; // 0x8f676f5c14
                int32_t v43 = v9; // 0x8f676f5c10
                int32_t v44 = v10; // 0x8f676f5c6
                int32_t v45 = v11; // 0x8f676f5c2
                int32_t result; // 0x8f676f6c_2
                if (v32 != v12) {
                    while (true) {
                        int32_t v46 = *(int32_t *)(v32 + 16); // 0x8f676e68
                        int32_t v47 = *(int32_t *)(v32 + 20); // 0x8f676e68
                        bool v48 = false; // 0x8f676e9c54
                        bool v49 = v47 >= v31; // 0x8f676e9c52
                        if (v47 == v31) {
                            // if_8f676e70_0_true
                            v48 = v46 == v30;
                            v49 = v46 >= v30;
                            // branch -> after_if_8f676e70_0
                        }
                        // after_if_8f676e70_0
                        int32_t v50; // 0x8f676f14
                        if (!v49 || !((v48 ^ true))) {
                            uint32_t v51 = *(int32_t *)(v32 + 8); // 0x8f676e7c
                            uint32_t v52 = *(int32_t *)(v32 + 12); // 0x8f676e7c
                            if (v52 == v29) {
                                // if_8f676e84_0_true
                                if (v51 >= v28) {
                                  lab_0x8f676e8c:;
                                    uint32_t v53 = v51 + v46; // 0x8f676e8c
                                    uint32_t v54 = v52 + v47 + (int32_t)(v53 < v46); // 0x8f676e94
                                    if (v54 == v35) {
                                        // if_8f676e9c_0_true
                                        if (v53 >= v34) {
                                          lab_0x8f676ea4:
                                            // 0x8f676ea4
                                            g26 = v46;
                                            print_log(2, (int32_t)"got host block [0x%llx, 0x%llx] for new block [0x%llx, 0x%llx]\n", v51, v52, v46, v47, v28, v29, v30, v31, v46, v47, 0);
                                            if (allocate_sp_block((int32_t *)v33, (int32_t)"got host block [0x%llx, 0x%llx] for new block [0x%llx, 0x%llx]\n", g24, g25) == 0) {
                                                // 0x8f676ea4
                                                v19 = v47;
                                                v17 = v46;
                                                v15 = v31;
                                                v24 = v30;
                                                v23 = v29;
                                                v21 = v28;
                                                // branch -> 0x8f676f1c
                                                // 0x8f676f1c
                                                v27 = v3 + 32;
                                                v3 = v27;
                                                if (v27 == (int32_t)&g12) {
                                                    // break (via goto) -> 0x8f676f2c
                                                    goto lab_0x8f676f2c;
                                                }
                                                v13 = v27;
                                                v6 = v19;
                                                v7 = v17;
                                                v8 = v15;
                                                v9 = v24;
                                                v10 = v23;
                                                v11 = v21;
                                                // continue (via goto) -> 0x8f676e34
                                                goto lab_0x8f676e34;
                                            } else {
                                                int32_t v55 = *(int32_t *)(v33 + 8); // 0x8f676eec
                                                int32_t v56 = *(int32_t *)(v33 + 12); // 0x8f676eec
                                                int32_t v57 = *(int32_t *)(v33 + 16); // 0x8f676ef8
                                                int32_t v58 = *(int32_t *)(v33 + 20); // 0x8f676ef8
                                                print_log(0, (int32_t)"Failed to drill block [0x%llx, 0x%llx]in block [0x%llx, 0x%llx]\n", g24, g25, g22, g23, v55, v56, v57, v58, v46, v47, 0);
                                                v18 = v47;
                                                v16 = v46;
                                                v14 = v58;
                                                v25 = v57;
                                                v22 = v56;
                                                v20 = v55;
                                                result = -1;
                                                // branch -> 0x8f676f30
                                            }
                                          lab_0x8f676f30_3:
                                            // 0x8f676f30
                                            if (v1 == g17) {
                                                // 0x8f676f68
                                                return result;
                                            }
                                          lab_0x8f676f44:
                                            // 0x8f676f44
                                            __stack_chk_fail();
                                            v40 = v18;
                                            v41 = v16;
                                            v42 = v14;
                                            v43 = v25;
                                            v44 = v22;
                                            v45 = v20;
                                            // branch -> 0x8f676f48
                                            // 0x8f676f48
                                            print_log(0, (int32_t)"Invalid entry block [0x%llx, 0x%llx]\n", g24, g25, g22, g23, v45, v44, v43, v42, v41, v40, 0);
                                            v18 = v40;
                                            v16 = v41;
                                            v14 = v42;
                                            v25 = v43;
                                            v22 = v44;
                                            v20 = v45;
                                            result = -2;
                                            // branch -> 0x8f676f30
                                            goto lab_0x8f676f30_3;
                                        }
                                    } else {
                                        // after_if_8f676e9c_0
                                        if (v54 >= v35) {
                                            goto lab_0x8f676ea4;
                                        }
                                        // 0x8f676f14
                                        v50 = *(int32_t *)(v32 + 4);
                                        v33 = v50;
                                        if (v50 == v12) {
                                            v40 = v47;
                                            v41 = v46;
                                            v42 = v8;
                                            v43 = v9;
                                            v44 = v10;
                                            v45 = v11;
                                            // break -> 0x8f676f48
                                            break;
                                        }
                                        v32 = v50;
                                        // continue -> 0x8f676e68
                                        continue;
                                    }
                                  lab_0x8f676f14:
                                    // 0x8f676f14
                                    v50 = *(int32_t *)(v32 + 4);
                                    v33 = v50;
                                    if (v50 == v12) {
                                        v40 = v47;
                                        v41 = v46;
                                        v42 = v8;
                                        v43 = v9;
                                        v44 = v10;
                                        v45 = v11;
                                        // break -> 0x8f676f48
                                        break;
                                    }
                                    v32 = v50;
                                    // continue -> 0x8f676e68
                                    continue;
                                }
                            } else {
                                // after_if_8f676e84_0
                                if (v52 < v29) {
                                    goto lab_0x8f676f14;
                                }
                                goto lab_0x8f676e8c;
                            }
                            // 0x8f676f14
                            v50 = *(int32_t *)(v32 + 4);
                            v33 = v50;
                            if (v50 == v12) {
                                v40 = v47;
                                v41 = v46;
                                v42 = v8;
                                v43 = v9;
                                v44 = v10;
                                v45 = v11;
                                // break -> 0x8f676f48
                                break;
                            }
                            v32 = v50;
                            // continue -> 0x8f676e68
                            continue;
                        }
                        // 0x8f676f14
                        v50 = *(int32_t *)(v32 + 4);
                        v33 = v50;
                        if (v50 == v12) {
                            v40 = v47;
                            v41 = v46;
                            v42 = v8;
                            v43 = v9;
                            v44 = v10;
                            v45 = v11;
                            // break -> 0x8f676f48
                            break;
                        }
                        v32 = v50;
                        // continue -> 0x8f676e68
                    }
                    // 0x8f676f48
                    print_log(0, (int32_t)"Invalid entry block [0x%llx, 0x%llx]\n", v28, v29, v30, v31, v45, v44, v43, v42, v41, v40, 0);
                    v18 = v40;
                    v16 = v41;
                    v14 = v42;
                    v25 = v43;
                    v22 = v44;
                    v20 = v45;
                    result = -2;
                    // branch -> 0x8f676f30
                    goto lab_0x8f676f30_3;
                }
                // 0x8f676f48
                print_log(0, (int32_t)"Invalid entry block [0x%llx, 0x%llx]\n", v37, v36, v39, v38, v45, v44, v43, v42, v41, v40, 0);
                v18 = v40;
                v16 = v41;
                v14 = v42;
                v25 = v43;
                v22 = v44;
                v20 = v45;
                result = -2;
                // branch -> 0x8f676f30
                goto lab_0x8f676f30_3;
            } else {
                v19 = v6;
                v17 = v7;
                v15 = v8;
                v24 = v9;
                v23 = v10;
                v21 = v11;
            }
            // 0x8f676f1c
            v27 = v13 + 32;
            v3 = v27;
            if (v27 == (int32_t)&g12) {
                // break -> 0x8f676f2c
                break;
            }
            v13 = v27;
            v6 = v19;
            v7 = v17;
            v8 = v15;
            v9 = v24;
            v10 = v23;
            v11 = v21;
            // continue -> 0x8f676e34
            continue;
        }
        // 0x8f676f1c
        v27 = v26 + 32;
        v3 = v27;
        if (v27 == (int32_t)&g12) {
            // break -> 0x8f676f2c
            break;
        }
        v13 = v27;
        v6 = v19;
        v7 = v17;
        v8 = v15;
        v9 = v24;
        v10 = v23;
        v11 = v21;
        // continue -> 0x8f676e34
    }
  lab_0x8f676f2c:
    // 0x8f676f2c
    v18 = v19;
    v16 = v17;
    v14 = v15;
    v25 = v24;
    v22 = v23;
    v20 = v21;
    // branch -> 0x8f676f30
    // 0x8f676f30
    if (v1 != g17) {
        goto lab_0x8f676f44;
    }
    // 0x8f676f68
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// uLong crc32(uLong crc, const Bytef * buf, uInt len);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 18
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:53:38
