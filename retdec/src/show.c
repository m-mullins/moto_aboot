//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t arch_early_init(void);
int32_t boot_handler(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t boot_linux(int32_t (*a1)(int32_t, int32_t, int32_t), int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t disable_charger_gone_irq(int32_t a1, int32_t a2, int32_t a3);
int32_t enable_charger_gone_irq(int32_t a1, int32_t a2);
void function_8f64b730(void);
void function_8f64b7f0(char * str, char * delim, int32_t a3);
int32_t hab_policy_init(void);
int32_t init_barcodes(int32_t a1, int32_t a2, int32_t a3);
int32_t init_panels(void);
int32_t is_like_hab_signature(char * a1, int32_t a2, int32_t a3);
int32_t is_warranty_void(int32_t a1);
int32_t load_and_validate_logo(void);
int32_t LZ4_decompress_safe(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t LZ4_decompress_safe_withPrefix64k(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mcs_habp_rsa_crt_core(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mcs_habp_rsa_crt_med(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_get_manufacture_id(int32_t * a1, int32_t a2, int32_t a3);
int32_t mipi_mot_get_supplier_id(int32_t * a1, int32_t a2, int32_t a3);
char * mmc_sd_set_bus_width(char * a1, int32_t * a2, int32_t a3);
char * mmc_sd_set_hs(char * a1);
int32_t move_to_verified(int32_t a1, int32_t a2, int32_t a3);
int32_t qup_i2c_sec_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t qup_i2c_xfer(int32_t a1);
int32_t radio_from_utag(int32_t a1, int32_t a2, int32_t a3);
char * restore_secure_cfg(int32_t a1, int32_t a2);
int32_t scm_init(int32_t a1);
int32_t screen_manager_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t show(char * a1, int32_t a2, int32_t a3);
int32_t target_hwrev(void);

// --------------------- Global Variables ---------------------

int32_t g45 = 0; // LR
int32_t g46 = 0; // R0
int32_t g47 = 0; // R1
int32_t g48 = 0; // R11
int32_t g49 = 0; // R12
int32_t g50 = 0; // R2
int32_t g51 = 0; // R3
int32_t g52 = 0; // R4
int32_t g53 = 0; // R5
int32_t g54 = 0; // R6
int32_t g55 = 0; // R7
int32_t g56 = 0; // R8
int32_t g57 = 0; // R9
int32_t g1 = -0x15fffffa; // 0x8f600000
int32_t g2 = -0x1a60cef8; // 0x8f612228
int32_t g3 = -0x1a60ceec; // 0x8f6383f0
int32_t g4 = -0x16d2bfc9; // 0x8f6387c0
int32_t g5 = -0x16d2bc09; // 0x8f638ab0
int32_t g6 = -0x1a60ff98; // 0x8f638b94
int32_t g7 = -0x16d2bfc9; // 0x8f64587c
char * g8 = "\xff\xff\xff\xff\x6c\x6f\x61\x64\x5f\x61\x6e\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x65\x5f\x6b\x65\x72\x6e\x65\x6c\x5f\x69\x6d\x61\x67\x65"; // 0x8f6826be
int32_t g9 = 0x65440030; // 0x8f69c66f
int32_t g10 = 0; // 0x8f6a3f38
int32_t g11 = 1; // 0x8f6ac0f0
int32_t g12 = -0x709c73f8; // 0x8f6ac374
int32_t g13 = 0xffff; // 0x8f6acae4
int32_t g14 = 4; // 0x8f6acaf4
int32_t g15 = 0xffff; // 0x8f6acb2c
int32_t g16 = 4; // 0x8f6acb84
int32_t g17 = 0; // 0x8f6b0048
int32_t g18 = 0; // 0x8f6b004c
int32_t g19 = 0; // 0x8f6b0074
int32_t g20 = 0; // 0x8f6b0078
int32_t g21 = 0; // 0x8f6b015c
int32_t g22 = 0; // 0x8f6b1608
int32_t g23 = 0; // 0x8f6b7cc0
int32_t g24 = 0; // 0x8f6c0000
int32_t g25 = 0; // 0x8f6c02aa
int32_t g26 = 0; // 0x8f6c02ba
int32_t g27 = 0; // 0x8f6c02ca
int32_t g28 = 0; // 0x8f6c02e0
int32_t g29 = 0; // 0x8f6e082c
char * g30; // 0x8f6e0849
int32_t g31 = 0; // 0x8f6e0854
int32_t g32 = 0; // 0x8f6e0858
int32_t g33 = 0; // 0x8f6e085c
int32_t g34 = 0; // 0x8f6e0878
int32_t g35 = 0; // 0x8f6e0894
int32_t g36 = 0; // 0x8f6e08b0
int32_t g37 = 0; // 0x8f6e08b4
char ** g38 = NULL; // 0x8f6e0bf8
int32_t g39 = 0; // 0x8f710c30
int32_t g40 = 0; // 0x8f710c34
int16_t * g41 = NULL; // 0x8f7112f4
int32_t g42 = 0; // 0x8f7114b8
int32_t g43 = 0; // 0x8f71302c
int32_t g44 = 0; // 0x8f713044

// ------------------------ Functions -------------------------

// Address range: 0x8f638ab0 - 0x8f638c07
int32_t show(char * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = a2; // R1
    int32_t v3 = a3; // R2
    int32_t v4 = g52; // 0x8f638ab0
    int32_t v5 = g53; // 0x8f638ab0
    int32_t v6 = g54; // 0x8f638ab0
    int32_t v7 = g55; // 0x8f638ab0
    int32_t v8 = g56; // 0x8f638ab0
    int32_t v9 = g57; // 0x8f638ab0
    int32_t v10 = g45; // 0x8f638ab0
    g53 = v1;
    g54 = (int32_t)&g41;
    g56 = a2;
    int16_t * v11 = g41;
    int32_t v12 = (int32_t)v11;
    int32_t v13 = enable_gpio_107_irq(enable_resin_n_irq(v1, a2, a3)); // 0x8f638acc
    int32_t result = connect_key(enable_kpdpwr_n_irq(v13, v2, v3, v12)); // 0x8f638ad4
    int32_t str = g53; // 0x8f638ad8
    if (str == 0) {
        // 0x8f638bd4
        g50 = v12;
        if (v11 != g41) {
            // 0x8f638be4
            __stack_chk_fail();
            // branch -> 0x8f638be8
        }
        // 0x8f638be8
        g52 = v4;
        g53 = v5;
        g54 = v6;
        g55 = v7;
        g56 = v8;
        g57 = v9;
        return result;
    }
    // 0x8f638ae0
    g55 = &g31;
    int32_t v14 = g31;
    int32_t strncmp_rc; // 0x8f638bc8
    if (v14 != 0) {
        // 0x8f638bbc
        v2 = str;
        v3 = 32;
        strncmp_rc = strncmp((char *)(v14 + 8), (char *)str, 32);
        if (strncmp_rc == 0) {
            // 0x8f638bd4
            g50 = v12;
            if (v11 != g41) {
                // 0x8f638be4
                __stack_chk_fail();
                // branch -> 0x8f638be8
            } else {
                strncmp_rc = 0;
            }
            // 0x8f638be8
            g52 = v4;
            g53 = v5;
            g54 = v6;
            g55 = v7;
            g56 = v8;
            g57 = v9;
            return strncmp_rc;
        }
    }
    // 0x8f638af0
    g52 = (int32_t)&g30;
    char v15 = *(char *)&g30; // 0x8f638af411
    int32_t v16 = v15; // 0x8f638af412
    int32_t result3; // 0x8f638b18
    int32_t strncmp_rc2; // 0x8f638b3c
    int32_t v17; // 0x8f638b64
    int32_t v18; // 0x8f638b70
    int32_t result2; // 0x8f638b98
    int32_t v19; // R0
    int32_t v20;
    int32_t v21;
    int16_t * v22;
    int32_t v23; // 0x8f638b4c
    int32_t v24; // 0x8f638b88
    int32_t str2; // 0x8f638b34
    int32_t v25; // 0x8f638bac
    int32_t v26; // 0x8f638b80
    int32_t v27; // 0x8f638b88
    if (v15 != 0) {
        // 0x8f638b0c
        result3 = print_log(2, (int32_t)"Searching screen for: %s\n", g53, v16, v1, v12, a3, v4, v5, v6, v7, v8, v9);
        v20 = g37;
        g52 = v20;
        g57 = &g36;
        if (v20 != (int32_t)&g36) {
            while (true) {
                // 0x8f638b30
                str2 = g53;
                g47 = str2;
                g50 = 32;
                strncmp_rc2 = strncmp((char *)(v20 + 8), (char *)str2, 32);
                v19 = strncmp_rc2;
                v23 = g52;
                if (strncmp_rc2 != 0) {
                    goto lab_if_8f638b44_0_true;
                }
                // 0x8f638b4c
                if (v23 == 0) {
                    // 0x8f638bd4
                    g50 = v12;
                    if (v11 != g41) {
                        // 0x8f638be4
                        __stack_chk_fail();
                        strncmp_rc = v19;
                        // branch -> 0x8f638be8
                    } else {
                        strncmp_rc = 0;
                    }
                    // 0x8f638be8
                    g52 = v4;
                    g53 = v5;
                    g54 = v6;
                    g55 = v7;
                    g56 = v8;
                    g57 = v9;
                    return strncmp_rc;
                }
                // 0x8f638b54
                if (display_get_state(0, str2, 32) != 2) {
                    // 0x8f638b6c
                    v18 = mutex_acquire((int32_t)&g34, str2, 32, (int32_t)&g36, v1, v12, a3, v4, v5, v6, v7);
                    g46 = v18;
                    v21 = g31;
                    if (v21 != 0) {
                        // 0x8f638b80
                        v26 = *(int32_t *)(v21 + 56);
                        g51 = v26;
                        g45 = -0x709c7478;
                        ((int32_t (*)(int32_t))v26)(v26);
                        // branch -> 0x8f638b88
                    }
                    // 0x8f638b88
                    v24 = g52;
                    v27 = *(int32_t *)(v24 + 52);
                    g51 = v27;
                    *(int32_t *)g55 = v24;
                    g45 = &g6;
                    ((int32_t (*)(int32_t))v27)(v27);
                    result2 = mutex_release((int32_t)&g34, str2, 32, v27, v1, v12, a3);
                    g50 = v12;
                    v22 = g41;
                    if (v11 != v22) {
                        // 0x8f638be4
                        __stack_chk_fail();
                        // branch -> 0x8f638be8
                        // 0x8f638be8
                        g52 = v4;
                        g53 = v5;
                        g54 = v6;
                        g55 = v7;
                        g56 = v8;
                        g57 = v9;
                        return result2;
                    }
                    // 0x8f638bac
                    v25 = g56;
                    g52 = v4;
                    g53 = v5;
                    g54 = v6;
                    g55 = v7;
                    g56 = v8;
                    g57 = v9;
                    g45 = v10;
                    return invalidate(v25, str2, v12, (int32_t)v22);
                }
                v17 = thread_sleep(5, str2, 32, (int32_t)&g36, v1, v12, a3, v4);
                while (display_get_state(v17, str2, 32) == 2) {
                    // 0x8f638b60
                    v17 = thread_sleep(5, str2, 32, (int32_t)&g36, v1, v12, a3, v4);
                    // continue -> 0x8f638b60
                }
                // 0x8f638b6c
                v18 = mutex_acquire((int32_t)&g34, str2, 32, (int32_t)&g36, v1, v12, a3, v4, v5, v6, v7);
                g46 = v18;
                v21 = g31;
                if (v21 != 0) {
                    // 0x8f638b80
                    v26 = *(int32_t *)(v21 + 56);
                    g51 = v26;
                    g45 = -0x709c7478;
                    ((int32_t (*)(int32_t))v26)(v26);
                    // branch -> 0x8f638b88
                }
                // 0x8f638b88
                v24 = g52;
                v27 = *(int32_t *)(v24 + 52);
                g51 = v27;
                *(int32_t *)g55 = v24;
                g45 = &g6;
                ((int32_t (*)(int32_t))v27)(v27);
                result2 = mutex_release((int32_t)&g34, str2, 32, v27, v1, v12, a3);
                g50 = v12;
                v22 = g41;
                if (v11 != v22) {
                    // 0x8f638be4
                    __stack_chk_fail();
                    // branch -> 0x8f638be8
                    // 0x8f638be8
                    g52 = v4;
                    g53 = v5;
                    g54 = v6;
                    g55 = v7;
                    g56 = v8;
                    g57 = v9;
                    return result2;
                }
                // 0x8f638bac
                v25 = g56;
                g52 = v4;
                g53 = v5;
                g54 = v6;
                g55 = v7;
                g56 = v8;
                g57 = v9;
                g45 = v10;
                return invalidate(v25, str2, v12, (int32_t)v22);
            }
        }
        // 0x8f638bd4
        g50 = v12;
        if (v11 != g41) {
            // 0x8f638be4
            __stack_chk_fail();
            // branch -> 0x8f638be8
        }
        // 0x8f638be8
        g52 = v4;
        g53 = v5;
        g54 = v6;
        g55 = v7;
        g56 = v8;
        g57 = v9;
        return result3;
    }
    thread_sleep(10, v2, v3, v16, v1, v12, a3, v4);
    char v28 = *(char *)&g30; // 0x8f638af4
    int32_t v29 = v28; // 0x8f638af4
    while (v28 == 0) {
        // 0x8f638b00
        thread_sleep(10, v2, v3, v29, v1, v12, a3, v4);
        v28 = *(char *)&g30;
        v29 = v28;
        // continue -> 0x8f638b00
    }
    // 0x8f638b0c
    result3 = print_log(2, (int32_t)"Searching screen for: %s\n", g53, v29, v1, v12, a3, v4, v5, v6, v7, v8, v9);
    v20 = g37;
    g52 = v20;
    g57 = &g36;
    if (v20 == (int32_t)&g36) {
        // 0x8f638bd4
        g50 = v12;
        if (v11 != g41) {
            // 0x8f638be4
            __stack_chk_fail();
            // branch -> 0x8f638be8
        }
        // 0x8f638be8
        g52 = v4;
        g53 = v5;
        g54 = v6;
        g55 = v7;
        g56 = v8;
        g57 = v9;
        return result3;
    }
    int32_t v30 = v20; // 0x8f638b30
    while (true) {
        // 0x8f638b30
        str2 = g53;
        g47 = str2;
        g50 = 32;
        strncmp_rc2 = strncmp((char *)(v30 + 8), (char *)str2, 32);
        v19 = strncmp_rc2;
        v23 = g52;
        if (strncmp_rc2 == 0) {
            // 0x8f638b4c
            if (v23 != 0) {
                // 0x8f638b54
                if (display_get_state(0, str2, 32) != 2) {
                    // 0x8f638b6c
                    v18 = mutex_acquire((int32_t)&g34, str2, 32, (int32_t)&g36, v1, v12, a3, v4, v5, v6, v7);
                    g46 = v18;
                    v21 = g31;
                    if (v21 != 0) {
                        // 0x8f638b80
                        v26 = *(int32_t *)(v21 + 56);
                        g51 = v26;
                        g45 = -0x709c7478;
                        ((int32_t (*)(int32_t))v26)(v26);
                        // branch -> 0x8f638b88
                    }
                    // 0x8f638b88
                    v24 = g52;
                    v27 = *(int32_t *)(v24 + 52);
                    g51 = v27;
                    *(int32_t *)g55 = v24;
                    g45 = &g6;
                    ((int32_t (*)(int32_t))v27)(v27);
                    result2 = mutex_release((int32_t)&g34, str2, 32, v27, v1, v12, a3);
                    g50 = v12;
                    v22 = g41;
                    if (v11 != v22) {
                        // 0x8f638be4
                        __stack_chk_fail();
                        // branch -> 0x8f638be8
                        // 0x8f638be8
                        g52 = v4;
                        g53 = v5;
                        g54 = v6;
                        g55 = v7;
                        g56 = v8;
                        g57 = v9;
                        return result2;
                    }
                    // 0x8f638bac
                    v25 = g56;
                    g52 = v4;
                    g53 = v5;
                    g54 = v6;
                    g55 = v7;
                    g56 = v8;
                    g57 = v9;
                    g45 = v10;
                    return invalidate(v25, str2, v12, (int32_t)v22);
                }
                v17 = thread_sleep(5, str2, 32, (int32_t)&g36, v1, v12, a3, v4);
                while (display_get_state(v17, str2, 32) == 2) {
                    // 0x8f638b60
                    v17 = thread_sleep(5, str2, 32, (int32_t)&g36, v1, v12, a3, v4);
                    // continue -> 0x8f638b60
                }
                // 0x8f638b6c
                v18 = mutex_acquire((int32_t)&g34, str2, 32, (int32_t)&g36, v1, v12, a3, v4, v5, v6, v7);
                g46 = v18;
                v21 = g31;
                if (v21 != 0) {
                    // 0x8f638b80
                    v26 = *(int32_t *)(v21 + 56);
                    g51 = v26;
                    g45 = -0x709c7478;
                    ((int32_t (*)(int32_t))v26)(v26);
                    // branch -> 0x8f638b88
                }
                // 0x8f638b88
                v24 = g52;
                v27 = *(int32_t *)(v24 + 52);
                g51 = v27;
                *(int32_t *)g55 = v24;
                g45 = &g6;
                ((int32_t (*)(int32_t))v27)(v27);
                result2 = mutex_release((int32_t)&g34, str2, 32, v27, v1, v12, a3);
                g50 = v12;
                v22 = g41;
                if (v11 != v22) {
                    // 0x8f638be4
                    __stack_chk_fail();
                    // branch -> 0x8f638be8
                    // 0x8f638be8
                    g52 = v4;
                    g53 = v5;
                    g54 = v6;
                    g55 = v7;
                    g56 = v8;
                    g57 = v9;
                    return result2;
                }
                // 0x8f638bac
                v25 = g56;
                g52 = v4;
                g53 = v5;
                g54 = v6;
                g55 = v7;
                g56 = v8;
                g57 = v9;
                g45 = v10;
                return invalidate(v25, str2, v12, (int32_t)v22);
            }
        } else {
          lab_if_8f638b44_0_true:;
            int32_t v31 = *(int32_t *)(v23 + 4); // 0x8f638b44
            g52 = v31;
            if (v31 == g57) {
                // break -> 0x8f638bd4
                break;
            }
            v30 = v31;
            // continue -> 0x8f638b30
            continue;
        }
        // 0x8f638bd4
        g50 = v12;
        if (v11 != g41) {
            // 0x8f638be4
            __stack_chk_fail();
            strncmp_rc = v19;
            // branch -> 0x8f638be8
        } else {
            strncmp_rc = 0;
        }
        // 0x8f638be8
        g52 = v4;
        g53 = v5;
        g54 = v6;
        g55 = v7;
        g56 = v8;
        g57 = v9;
        return strncmp_rc;
    }
    // 0x8f638bd4
    g50 = v12;
    if (v11 != g41) {
        // 0x8f638be4
        __stack_chk_fail();
        strncmp_rc = v19;
        // branch -> 0x8f638be8
    } else {
        strncmp_rc = strncmp_rc2;
    }
    // 0x8f638be8
    g52 = v4;
    g53 = v5;
    g54 = v6;
    g55 = v7;
    g56 = v8;
    g57 = v9;
    return strncmp_rc;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// long int atol(const char * nptr);
// void free(void * ptr);
// int isdigit(int c);
// int isxdigit(int c);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strtok_r(char * restrict s, const char * restrict delim, char ** restrict save_ptr);
// int tolower(int c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:19:08
