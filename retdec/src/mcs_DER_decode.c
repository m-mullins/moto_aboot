//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t arch_context_switch(int32_t a1, int32_t a2, int32_t a3);
int32_t arch_early_init(void);
int32_t arch_init(int32_t a1, int32_t a2);
int32_t arch_thread_initialize(int32_t a1, int32_t a2, int32_t a3);
int32_t bptools_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t confession_get_buffer(int32_t a1, int32_t a2, int32_t a3);
int32_t confession_printf(char * a1, int32_t a2);
int32_t fboot_usb_init(int32_t a1, int32_t a2, int32_t a3);
int32_t fboot_usb_write(int32_t a1, int32_t a2);
int32_t fboot_usb_write_queue(int32_t a1, uint32_t a2, int32_t a3);
int32_t fboot_usb_write_wait(int32_t a1, int32_t a2, int32_t a3);
int32_t generic_mmc_init(char * a1, int32_t a2);
int32_t generic_mmc_read_sector(int64_t a1, int64_t a2, int32_t a3, int32_t a4);
int32_t hab_su_code(int32_t a1, int32_t a2);
int32_t hab_su_srk_selection(int32_t a1, int32_t a2);
int32_t handle_fboot_command_erase(int32_t a1, int32_t a2);
int32_t handle_fboot_command_multiflash(int32_t * a1);
int32_t is_qcom_mode(void);
int32_t mcs_DER_decode(char * a1, int16_t * a2, char * a3, int16_t * a4);
int32_t mcs_DER_decodeItem(int32_t a1, int32_t a2, int32_t a3);
char * mmc_get_card_status_isra_3(char * a1, int32_t * a2, int32_t * a3);
int32_t pm8x41_reset_configure(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t power_source_detected(int32_t a1, int32_t a2, int32_t a3);
int32_t remove_sp_block(int32_t a1);
int32_t sdhci_mode_disable(int32_t a1);
int32_t SecBoundSigAllowed(void);
int32_t SecICTypeRead(void);
int32_t smb1359_init(int32_t a1, int32_t a2, int32_t a3);
int32_t smb1359_masked_write_reg(int32_t a1, int32_t a2, int32_t a3);
int32_t update_sp_block(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

bool g28 = false; // LR
int32_t g29 = 0; // R0
int32_t g30 = 0; // R1
int32_t g31 = 0; // R10
int32_t g32 = 0; // R2
int32_t g33 = 0; // R3
int32_t g34 = 0; // R4
int32_t g35 = 0; // R5
int32_t g36 = 0; // R6
int32_t g37 = 0; // R7
int32_t g38 = 0; // R8
int32_t g39 = 0; // R9
int32_t g1 = -0x15fffffa; // 0x8f600000
int32_t g2 = -0x1a60cfa4; // 0x8f619a9c
int32_t g3 = -0x1a60cfc4; // 0x8f62d6e8
char * g4 = "\n"; // 0x8f6ac1b0
int32_t g5 = -0x709d28c8; // 0x8f6ac1cc
int32_t g6 = 0; // 0x8f6c03b4
int32_t g7 = 0; // 0x8f6c064c
int32_t g8 = 0; // 0x8f6c0650
int32_t g9 = 0; // 0x8f6c0654
int32_t g10 = 0; // 0x8f6c0658
int32_t g11 = 0; // 0x8f6c065c
int32_t g12 = 0; // 0x8f6c0660
int32_t g13 = 0; // 0x8f6c0664
int32_t g14 = 0; // 0x8f6c0668
int32_t g15 = 0; // 0x8f6c066c
int32_t g16 = 0; // 0x8f6e0bd4
char * g17; // 0x8f6e12e8
int32_t g18 = 0; // 0x8f6e12ec
int32_t g19 = 0; // 0x8f6e12f0
int32_t g20 = 0; // 0x8f710c38
char * g21; // 0x8f710c3c
int32_t g22 = 0; // 0x8f710c48
int32_t g23 = 0; // 0x8f710c60
char * g24; // 0x8f710e74
int32_t g25 = 0; // 0x8f7112f4
int32_t g26 = 0; // 0x8f711534
char * g27; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f665364 - 0x8f665553
int32_t mcs_DER_decode(char * a1, int16_t * a2, char * a3, int16_t * a4) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = (int32_t)a4;
    g35 = v2;
    int32_t v3 = 0; // R7
    int32_t v4 = (int32_t)a1; // R6
    int32_t v5 = (int32_t)a2; // R10
    int32_t v6 = 0; // R11
    int32_t v7 = g25;
    int32_t result = 0; // R8
    g34 = v1;
    int32_t v8 = v7; // 0x8f665394
    if (a3 == NULL) {
        // if_8f665390_0_true
        *a4 = (int16_t)v1;
        v2 = g35;
        v8 = v7;
        // branch -> after_if_8f665390_0
    }
    uint16_t v9 = *(int16_t *)v2; // 0x8f66539820
    if (v9 == 0) {
        // 0x8f665528
        *(int16_t *)v5 = (int16_t)v6;
        *(int16_t *)g35 = (int16_t)v3;
        if (v8 != g25) {
            // 0x8f665544
            __stack_chk_fail();
            // branch -> 0x8f665548
        }
        // 0x8f665548
        return result;
    }
    // 0x8f6653a4
    int32_t v10;
    int32_t v11 = &v10; // 0x8f665424_07
    uint32_t v12 = (int32_t)v9; // 0x8f6654cc
    // branch -> 0x8f6653a4
    while (true) {
        int16_t v13 = *(int16_t *)v5; // 0x8f6653a4
        int32_t v14 = v4; // 0x8f6653a8
        int16_t * v15; // 0x8f6654d0_0
        int32_t v16; // 0x8f6654d0
        int32_t v17; // 0x8f6654d0
        if (v14 == 0) {
            // after_if_8f6653ac_0.thread
            v10 = v13;
            // branch -> 0x8f6654cc
        } else {
            // after_if_8f6653ac_0
            v10 = v13;
            if (v13 != 0) {
                int32_t v18 = g34; // 0x8f6653b8
                char * v19 = (char *)v18; // 0x8f6653b8_0
                char v20 = *v19; // 0x8f6653b8
                int32_t v21 = v20; // 0x8f6653b8
                char v22 = *(char *)v14; // 0x8f6653bc
                int32_t v23 = v22; // 0x8f6653bc
                int32_t v24 = (int32_t)*(int16_t *)(v18 + 8); // 0x8f6653c0
                int32_t v25 = v24; // R3
                int16_t * v26; // 0x8f665514_0
                int32_t v27; // 0x8f665430
                int32_t v28; // R2
                int32_t v29; // 0x8f66542c
                uint16_t v30; // 0x8f665398
                if (v20 == v22) {
                    // 0x8f665414
                    if ((v24 & 4) == 0) {
                      lab_after_if_8f665420_0_thread:
                        // after_if_8f665420_0.thread
                        v29 = v18;
                        // branch -> after_if_8f665428_0
                      lab_after_if_8f665428_0:
                        // after_if_8f665428_0
                        v27 = mcs_DER_decodeItem(v14, v11, v29);
                        int32_t v31; // 0x8f66543c
                        if (v27 == 0) {
                          lab_after_if_8f665428_0_after_if_8f665438_0_crit_edge:
                            // after_if_8f665428_0.after_if_8f665438_0_crit_edge
                            v31 = result;
                            // branch -> after_if_8f665438_0
                        } else {
                          lab_if_8f665438_0_true:
                            // if_8f665438_0_true
                            result = v27;
                            v31 = v27;
                            // branch -> after_if_8f665438_0
                        }
                        // after_if_8f665438_0
                        if ((v31 & 253) == 0) {
                            int32_t v32 = g34; // 0x8f665444
                            int32_t v33 = v32 + 12; // 0x8f665444
                            v28 = v33;
                            int32_t v34; // 0x8f665470
                            if (*(int16_t *)g35 > 1) {
                                int32_t v35 = v32 + 24; // 0x8f66549847
                                v25 = v35;
                                int32_t v36 = (int32_t)*(int16_t *)(v32 + 20); // 0x8f6654a052
                                if ((v36 & 16) != 0) {
                                    int32_t v37 = v35; // 0x8f66549857
                                    int32_t v38 = v32; // 0x8f6654ac56
                                    int32_t v39; // 0x8f665450
                                    while (true) {
                                        // 0x8f6654ac
                                        *(int16_t *)(v37 - v38 + v33 - 16) = (int16_t)(v36 | 2);
                                        int16_t * v40 = (int16_t *)g35; // 0x8f6654bc_0
                                        *v40 = (int16_t)((int32_t)*v40 - 1);
                                        int32_t v41 = v25; // 0x8f665450
                                        v39 = v41 - 12;
                                        if (*(int16_t *)g35 > 1) {
                                            int32_t v42 = g34;
                                            int32_t v43 = v41 + 12; // 0x8f665498
                                            v25 = v43;
                                            int32_t v44 = (int32_t)*(int16_t *)(v41 - v42 + v28 - 4); // 0x8f6654a0
                                            if ((v44 & 16) == 0) {
                                                v33 = v43;
                                                // break -> 0x8f66545c
                                                break;
                                            }
                                            v36 = v44;
                                            v37 = v43;
                                            v38 = v42;
                                            v33 = v28;
                                            // continue -> 0x8f6654ac
                                            continue;
                                        } else {
                                            v33 = v41;
                                        }
                                    }
                                    // 0x8f66545c
                                    v34 = mcs_DER_advanceBuffer(v4, v5, v10 % 0x10000, v33);
                                    v3 = (v3 + 1) % 0x10000;
                                    g34 = v39;
                                    v6 = (v6 + v10) % 0x10000;
                                    v4 = v34;
                                    // branch -> 0x8f665514
                                  lab_0x8f665514_5:
                                    // 0x8f665514
                                    v26 = (int16_t *)g35;
                                    g34 += 12;
                                    *v26 = (int16_t)((int32_t)*v26 - 1);
                                    v30 = *(int16_t *)g35;
                                    if (v30 == 0) {
                                        // break -> 0x8f665528
                                        break;
                                    }
                                    v12 = (int32_t)v30;
                                    // continue -> 0x8f6653a4
                                    continue;
                                } else {
                                    v33 = v35;
                                }
                            }
                            // 0x8f66545c
                            v34 = mcs_DER_advanceBuffer(v4, v5, v10 % 0x10000, v33);
                            v3 = (v3 + 1) % 0x10000;
                            g34 = v32;
                            v6 = (v6 + v10) % 0x10000;
                            v4 = v34;
                            // branch -> 0x8f665514
                            goto lab_0x8f665514_5;
                        }
                        // 0x8f665528
                        *(int16_t *)v5 = (int16_t)v6;
                        *(int16_t *)g35 = (int16_t)v3;
                        if (v8 != g25) {
                            // 0x8f665544
                            __stack_chk_fail();
                            // branch -> 0x8f665548
                        }
                        // 0x8f665548
                        return result;
                    }
                } else {
                    // 0x8f6653cc
                    if ((v24 & 4) == 0) {
                        // 0x8f6653d4
                        if ((v24 & 128) != 0) {
                            // 0x8f6653dc
                            if ((v21 || 32) == v23) {
                              lab_0x8f665414:
                                // 0x8f665414
                                // branch -> after_if_8f665420_0.thread
                                goto lab_after_if_8f665420_0_thread;
                            }
                        }
                        // 0x8f6653e8
                        if ((v24 & 65) == 64) {
                            int32_t v45 = *(int32_t *)(v18 + 4); // 0x8f6653f4
                            if (v45 != 0) {
                                // 0x8f665400
                                if (((int32_t)*(char *)v45 & 32 || v21) == v23) {
                                    goto lab_0x8f665414;
                                }
                                // 0x8f6654cc
                                v16 = g34;
                                v15 = (int16_t *)(v16 + 8);
                                v17 = (int32_t)*v15;
                                if (v12 >= 2) {
                                  lab_0x8f6654d8_2:;
                                    int32_t v46 = (int32_t)*(int16_t *)(v16 + 20); // 0x8f6654d8
                                    v28 = v46;
                                    if ((v46 & 16) != 0) {
                                        int32_t v47 = v17 | 2; // 0x8f6654e4
                                        *v15 = (int16_t)v47;
                                        *(int16_t *)(g34 + 20) = (int16_t)(v47 & 8 | v28);
                                        // branch -> 0x8f665514
                                        goto lab_0x8f665514_5;
                                    }
                                }
                              lab_0x8f6654fc_2:
                                // 0x8f6654fc
                                if ((v17 & 8) == 0) {
                                    // 0x8f66550c
                                    if ((v17 & 32) != 0) {
                                        goto lab_0x8f665514_5;
                                    }
                                    // if_8f665510_0_true
                                    result = 3;
                                    // branch -> 0x8f665514
                                    goto lab_0x8f665514_5;
                                } else {
                                    // if_8f665500_0_true
                                    *v15 = (int16_t)(v17 | 2);
                                    // branch -> 0x8f665514
                                    goto lab_0x8f665514_5;
                                }
                                int32_t v48 = g35; // 0x8f665514
                                v26 = (int16_t *)v48;
                                uint16_t v49 = *v26; // 0x8f665514
                                int32_t v50 = g34; // 0x8f665518
                                g34 = v50 + 12;
                                *v26 = (int16_t)((int32_t)v49 - 1);
                                int32_t v51 = g35; // 0x8f665398
                                v30 = *(int16_t *)v51;
                                int32_t v52 = v30; // 0x8f665398
                                if (v30 == 0) {
                                    // break -> 0x8f665528
                                    break;
                                }
                                v12 = v52;
                                // continue -> 0x8f6653a4
                                continue;
                            }
                        }
                        // 0x8f6654cc
                        v16 = g34;
                        v15 = (int16_t *)(v16 + 8);
                        v17 = (int32_t)*v15;
                        if (v12 < 2) {
                            goto lab_0x8f6654fc_2;
                        }
                        goto lab_0x8f6654d8_2;
                    } else {
                        // 0x8f665414
                        // branch -> if_8f665428_0_true
                        // if_8f665428_0_true
                        *v19 = v22;
                        *(int16_t *)(g34 + 8) = (int16_t)(v25 | 1);
                        v29 = g34;
                        // branch -> after_if_8f665428_0
                        goto lab_after_if_8f665428_0;
                    }
                  lab_after_if_8f665428_0_2:
                    // after_if_8f665428_0
                    v27 = mcs_DER_decodeItem(v14, v11, g34);
                    if (v27 == 0) {
                        goto lab_after_if_8f665428_0_after_if_8f665438_0_crit_edge;
                    }
                    goto lab_if_8f665438_0_true;
                }
                // if_8f665428_0_true
                *v19 = v22;
                *(int16_t *)(g34 + 8) = (int16_t)(v25 | 1);
                // branch -> after_if_8f665428_0
                goto lab_after_if_8f665428_0_2;
            }
        }
        // 0x8f6654cc
        v16 = g34;
        v15 = (int16_t *)(v16 + 8);
        v17 = (int32_t)*v15;
        if (v12 < 2) {
            goto lab_0x8f6654fc_2;
        }
        goto lab_0x8f6654d8_2;
    }
    // 0x8f665528
    *(int16_t *)v5 = (int16_t)v6;
    *(int16_t *)g35 = (int16_t)v3;
    if (v8 != g25) {
        // 0x8f665544
        __stack_chk_fail();
        // branch -> 0x8f665548
    }
    // 0x8f665548
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:29:09
