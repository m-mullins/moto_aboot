//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t _fdt_check_prop_offset(int32_t a1);
int32_t add_panel_to_manager(int32_t * a1, int32_t a2, int32_t a3);
int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t arm_mmu_init(int32_t a1);
int32_t board_machtype(int32_t a1, int32_t a2, int32_t a3);
int32_t display_draw_screen_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t display_draw_screen_line_alignment(int32_t a1);
int32_t factory_mode(int32_t a1, int32_t a2, int32_t a3);
void function_8f67b680(void);
int32_t is_factory_mode(void);
int32_t is_validation_enabled(char * a1, int32_t a2);
int32_t load_and_validate_logo(void);
int32_t load_and_validate_oem_image(void);
int32_t mipi_mot_panel_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_panel_on(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_enable_enhanced_erase(void);
int32_t mmc_sdhci_enable_enhanced_erase(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_sdhci_get_wp_group_size(void);
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data(char * a1, char * a2);
int32_t mot_sst_oem_unlock_handler(void);
int32_t panel_manager_init(int32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_config_s3_source(uint32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_resin_status(int32_t a1, int32_t a2);
int32_t target_serialno(char * a1, int32_t a2);
int32_t validate_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t wait_queue_block(int32_t a1, int32_t a2);
int32_t wait_queue_init(int32_t * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R10
int32_t g23 = 0; // R11
int32_t g24 = 0; // R2
int32_t g25 = 0; // R3
int32_t g26 = 0; // R4
int32_t g27 = 0; // R5
int32_t g28 = 0; // R6
int32_t g29 = 0; // R7
int32_t g30 = 0; // R8
int32_t g31 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f61bf74
char * g2 = "\xff\xff\xff\xff\x6c\x6f\x61\x64\x5f\x61\x6e\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x65\x5f\x6b\x65\x72\x6e\x65\x6c\x5f\x69\x6d\x61\x67\x65"; // 0x8f6826be
char * g3 = "\n"; // 0x8f6ac1b0
int32_t g4 = 4; // 0x8f6acacc
int32_t g5 = 4; // 0x8f6acb18
int32_t g6 = 4; // 0x8f6acb30
int32_t g7 = -1; // 0x8f6affb0
int32_t g8 = 102; // 0x8f6affdc
int32_t g9 = 1; // 0x8f6b0044
char * g10; // 0x8f6b0070
int32_t g11 = 0; // 0x8f6bc000
char * g12; // 0x8f6e06ae
int32_t g13 = 0; // 0x8f6e06b4
int32_t g14 = 0; // 0x8f6e0c38
int32_t g15 = 0; // 0x8f7112f4
int32_t g16 = 0; // 0x8f7114ac
int32_t g17 = 0; // 0x8f711550
int32_t g18 = 0; // 0x8f711554

// ------------------------ Functions -------------------------

// Address range: 0x8f64fc60 - 0x8f64fdb7
int32_t display_draw_screen_line_alignment(int32_t a1) {
    int32_t v1 = g26; // 0x8f64fc60
    int32_t v2 = g27; // 0x8f64fc60
    int32_t v3 = g28; // 0x8f64fc60
    int32_t v4 = g29; // 0x8f64fc60
    int32_t v5 = g30; // 0x8f64fc60
    int32_t v6 = g31; // 0x8f64fc60
    int32_t v7 = g22; // 0x8f64fc60
    int32_t v8 = g23; // 0x8f64fc60
    g31 = g25;
    g30 = g24;
    int32_t v9 = g21; // 0x8f64fc74
    g28 = v9;
    g23 = a1;
    int32_t v10 = g15;
    int32_t v11;
    g29 = 0x1000000 * v11 / 0x1000000;
    int32_t v12 = font_get_x(a1, v9, v10, (int32_t)&g15); // 0x8f64fc8c
    g26 = g28 * v12;
    int32_t v13 = font_get_y(v12, g21, v10, (int32_t)&g15); // 0x8f64fc94
    g20 = v13;
    g22 = &g15;
    g27 = g28 * v13;
    int32_t result; // R2
    if (g14 == 0) {
        // 0x8f64fcb4
        result = v10;
        if (v10 != g15) {
            // 0x8f64fd8c
            __stack_chk_fail();
            return result;
        }
        // 0x8f64fcc4
        g21 = (int32_t)"Display not initialized\n";
        g26 = v1;
        g27 = v2;
        g28 = v3;
        g29 = v4;
        g30 = v5;
        g31 = v6;
        g22 = v7;
        g23 = v8;
        g20 = print_log(2, (int32_t)"Display not initialized\n", v10, v10, v1, v2, v3, v4, v5, v6, v7, v8, g19);
        return result;
    }
    int32_t v14 = v13; // 0x8f64fd7412
    int32_t v15; // 0x8f64fd40
    int32_t v16; // 0x8f64fd70
    int32_t v17; // 0x8f64fd74
    int32_t v18; // 0x8f64fda8
    int32_t v19; // 0x8f64fd60
    int32_t v20; // 0x8f64fd64
    int32_t v21; // 0x8f64fd94
    int32_t v22; // 0x8f64fd9c
    int32_t v23; // 0x8f64fd58
    int32_t v24; // 0x8f64fd90
    switch (g29) {
        case 3: {
            int32_t v25 = font_get_x(v13, g21, g14, (int32_t)&g15); // 0x8f64fd04
            int32_t v26 = g28 + 1; // 0x8f64fd08
            g28 = v26;
            int32_t v27 = v26 * v25; // 0x8f64fd0c
            g26 = v27 - 2;
            v14 = v27;
            // branch -> 0x8f64fd38
            break;
        }
        case 4: {
            int32_t v28 = g21; // 0x8f64fd20
            if (g23 == 0) {
                int32_t v29 = font_get_y(v13, v28, g14, (int32_t)&g15); // 0x8f64fd20
                g27 += v29 / 2;
                // branch -> 0x8f64fd40
                // 0x8f64fd40
                v15 = display_get_screen_width(v29, g21, g14, (int32_t)&g15);
                g20 = v15;
                g21 = v10;
                result = v15;
                if (v10 == g15) {
                    // 0x8f64fd58
                    v23 = g31;
                    v19 = g27;
                    g21 = v19;
                    v20 = g30;
                    g26 = v1;
                    g27 = v2;
                    g28 = v3;
                    g29 = v4;
                    g30 = v5;
                    g31 = v6;
                    g22 = v7;
                    g23 = v8;
                    v16 = display_draw_horizontal_line(0, v19, v15, v20, v1, v2, v3, v4, v5, v6, v7, v8, g19, v23, 0, 0, 0, 0, 0, 0, 0);
                    g20 = v16;
                    return result;
                }
            } else {
                int32_t v30 = font_get_x(v13, v28, g14, (int32_t)&g15); // 0x8f64fd2c
                g26 += v30 / 2;
                // branch -> 0x8f64fd74
                // 0x8f64fd74
                v17 = display_get_screen_height(v30, g21, g14, (int32_t)&g15);
                g20 = v17;
                g21 = v10;
                result = v17;
                if (v10 == g15) {
                    // 0x8f64fd90
                    v24 = g31;
                    v21 = g26;
                    g21 = 0;
                    v22 = g30;
                    g26 = v1;
                    g27 = v2;
                    g28 = v3;
                    g29 = v4;
                    g30 = v5;
                    g31 = v6;
                    g22 = v7;
                    g23 = v8;
                    v18 = display_draw_vertical_line(v21, 0, v17, v22, v1, v2, v3, v4, v5, v6, v7, v8, g19, v24, 0, 0, 0);
                    g20 = v18;
                    return result;
                }
            }
            // 0x8f64fd8c
            __stack_chk_fail();
            return result;
        }
        case 1: {
            int32_t v31 = font_get_y(v13, g21, g14, (int32_t)&g15); // 0x8f64fcf0
            int32_t v32 = g28 + 1; // 0x8f64fcf4
            g28 = v32;
            int32_t v33 = v32 * v31; // 0x8f64fcf8
            g27 = v33 - 2;
            v14 = v33;
            // branch -> 0x8f64fd38
            break;
        }
    }
    // 0x8f64fd38
    if (g23 == 0) {
        // 0x8f64fd40
        v15 = display_get_screen_width(v14, g21, g14, (int32_t)&g15);
        g20 = v15;
        g21 = v10;
        result = v15;
        if (v10 == g15) {
            // 0x8f64fd58
            v23 = g31;
            v19 = g27;
            g21 = v19;
            v20 = g30;
            g26 = v1;
            g27 = v2;
            g28 = v3;
            g29 = v4;
            g30 = v5;
            g31 = v6;
            g22 = v7;
            g23 = v8;
            v16 = display_draw_horizontal_line(0, v19, v15, v20, v1, v2, v3, v4, v5, v6, v7, v8, g19, v23, 0, 0, 0, 0, 0, 0, 0);
            g20 = v16;
            return result;
        }
    } else {
        // 0x8f64fd74
        v17 = display_get_screen_height(v14, g21, g14, (int32_t)&g15);
        g20 = v17;
        g21 = v10;
        result = v17;
        if (v10 == g15) {
            // 0x8f64fd90
            v24 = g31;
            v21 = g26;
            g21 = 0;
            v22 = g30;
            g26 = v1;
            g27 = v2;
            g28 = v3;
            g29 = v4;
            g30 = v5;
            g31 = v6;
            g22 = v7;
            g23 = v8;
            v18 = display_draw_vertical_line(v21, 0, v17, v22, v1, v2, v3, v4, v5, v6, v7, v8, g19, v24, 0, 0, 0);
            g20 = v18;
            return result;
        }
    }
    // 0x8f64fd8c
    __stack_chk_fail();
    return result;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:56:15
