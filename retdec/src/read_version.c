//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_constprop_16(char * a1, int32_t a2);
int32_t fastboot_notify(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t fboot_cmd_erase_validate(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_build_fp(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_build_ver(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_channelid(char * a1, int32_t a2, int32_t a3);
int32_t getvar_handler_root_detect(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_kernel_ver(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_qcom_build_id(int32_t a1, int32_t a2, int32_t a3);
int32_t getvar_ro_carrier(int32_t a1, int32_t a2);
int32_t getvar_secure(char * a1, int32_t a2, int32_t a3);
int32_t getvar_utag_str(int32_t a1, int32_t a2);
char * handle_fboot_command_getvar(int32_t a1);
int32_t is_partition_erasable(int32_t a1, int32_t a2);
int32_t read_root_status(void);
int32_t read_version(char * a1, char * a2, int32_t a3);
int32_t req_complete(int32_t result, int32_t a2, int32_t a3);
int32_t show_locked_command_restriction(int32_t a1);
int32_t type_atoi_11(char * str, int32_t a2, int32_t a3);
int32_t validate_sparse_data(int32_t a1, int32_t * a2, char * a3);
int32_t validate_sparse_filled_data_isra_3(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g12 = 0; // LR
int32_t g13 = 0; // R0
int32_t g14 = 0; // R1
int32_t g15 = 0; // R10
int32_t g16 = 0; // R11
int32_t g17 = 0; // R2
int32_t g18 = 0; // R3
int32_t g19 = 0; // R4
int32_t g20 = 0; // R5
int32_t g21 = 0; // R6
int32_t g22 = 0; // R7
int32_t g23 = 0; // R8
int32_t g24 = 0; // R9
int32_t g1 = 0x2020003a; // 0x8f686ac4
char * g2 = "\x01"; // 0x8f688c94
int32_t g3 = 0x746e6300; // 0x8f6a4e20
char * g4; // 0x8f6c0628
char * g5; // 0x8f6c0649
int32_t g6 = 0; // 0x8f6c0658
int32_t g7 = 0; // 0x8f6c0660
int32_t g8 = 0; // 0x8f6c066c
int32_t g9 = 0; // 0x8f7112f4
int32_t g10 = 0; // 0x8f711534
int32_t g11 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f62ce94 - 0x8f62cffb
int32_t read_version(char * a1, char * a2, int32_t a3) {
    int32_t str2 = (int32_t)a1;
    int32_t v1 = (int32_t)a2;
    int32_t v2 = g19; // 0x8f62ce94
    int32_t v3 = g20; // 0x8f62ce94
    int32_t v4 = g21; // 0x8f62ce94
    int32_t v5 = g22; // 0x8f62ce94
    int32_t v6 = g9;
    char * v7 = get_partition_by_name((int32_t)"versions", v1, a3, v6, str2, v6, a3, v2, v3, v4, v5); // 0x8f62ceb4
    int32_t v8 = (int32_t)v7; // 0x8f62ceb4_12
    if (v7 != NULL) {
        char v9 = *(char *)(v8 + 33); // 0x8f62cec0
        char v10 = *(char *)(v8 + 32); // 0x8f62cec4
        char v11 = *(char *)(v8 + 41); // 0x8f62cec8
        char v12 = *(char *)(v8 + 34); // 0x8f62ced0
        char v13 = *(char *)(v8 + 43); // 0x8f62ced4
        char v14 = *(char *)(v8 + 35); // 0x8f62cedc
        int32_t v15 = 0x1000000 * (int32_t)v14 | 0x10000 * (int32_t)v12 | (int32_t)v10 | 256 * (int32_t)v9; // 0x8f62cee0
        char v16 = *(char *)(v8 + 40); // 0x8f62cee4
        char v17 = *(char *)(v8 + 42); // 0x8f62ceec
        int32_t v18 = 0x10000 * (int32_t)v17 | (int32_t)v16 | 256 * (int32_t)v11 | 0x1000000 * (int32_t)v13; // 0x8f62cef4
        if (v15 == 0) {
            // after_if_8f62cefc_0.thread
            // branch -> 0x8f62cfe4
        } else {
            int32_t v19 = v18 - v15; // 0x8f62cf00
            if (v18 != v15) {
                int32_t size = 512 * v19; // 0x8f62cf08
                char * mem = malloc(size); // 0x8f62cf10
                int32_t str = (int32_t)mem; // 0x8f62cf10_3
                if (mem != NULL) {
                    int32_t v20 = 0x1000000 * generic_mmc_read_sector(v15, v19, str, v18, str2, v6, a3, v2, v3, v4);
                    int32_t result = v20 / 0x1000000; // R4
                    if ((v20 || 0xffffff) >= 0x1ffffff) {
                        // 0x8f62cfc0
                        // branch -> 0x8f62cfc4
                        // 0x8f62cfc4
                        free((char *)str);
                        // branch -> 0x8f62cfcc
                      lab_0x8f62cfcc_3:
                        // 0x8f62cfcc
                        if (v6 != g9) {
                            goto lab_0x8f62cfe0_4;
                        }
                        // 0x8f62cfec
                        g19 = v2;
                        g20 = v3;
                        g21 = v4;
                        g22 = v5;
                        return -1;
                    }
                    // 0x8f62cf34
                    *(char *)(str + size - 1) = 0;
                    char * substr_pos = strstr((char *)str, (char *)str2); // 0x8f62cf44
                    if (substr_pos == NULL) {
                        // if_8f62cf4c_0_true
                        *(char *)v1 = (char)result;
                        // branch -> 0x8f62cfc4
                    } else {
                        int32_t v21 = a3 - 1; // 0x8f62cf5c
                        int32_t v22 = (int32_t)substr_pos + strlen((char *)str2); // 0x8f62cf60
                        int32_t v23 = (int32_t)(*(char *)v22 == 58) + v22; // 0x8f62cf60
                        int32_t v24 = v23; // R3
                        int32_t v25 = v23; // 0x8f62cf9c
                        if (*(char *)v23 == 32) {
                            int32_t v26 = v23 + 1; // 0x8f62cf78
                            v24 = v26;
                            v25 = v26;
                            // branch -> 0x8f62cf7c
                        }
                        int32_t v27 = result; // 0x8f62cf7c6
                        int32_t v28; // 0x8f62cf9c
                        int32_t v29; // 0x8f62cfa0
                        if (v27 >= v21) {
                            v28 = v27;
                          lab_0x8f62cf94:
                            // 0x8f62cf94
                            *(char *)(v28 + v25) = 0;
                            v29 = v24;
                            strlcpy(v1, v29, a3, v29, str2);
                            // branch -> 0x8f62cfc4
                            // 0x8f62cfc4
                            free((char *)str);
                            // branch -> 0x8f62cfcc
                            // 0x8f62cfcc
                            if (v6 != g9) {
                                goto lab_0x8f62cfe0_4;
                            }
                            // 0x8f62cfec
                            g19 = v2;
                            g20 = v3;
                            g21 = v4;
                            g22 = v5;
                            return result;
                        }
                        int32_t v30 = v27; // 0x8f62cfb8
                        while (true) {
                            // 0x8f62cf84
                            switch (*(char *)(v30 + v25)) {
                                default: {
                                    int32_t v31 = v30 + 1; // 0x8f62cfb8
                                    result = v31;
                                    if (v31 >= v21) {
                                        v28 = v31;
                                        // break (via goto) -> 0x8f62cf94
                                        goto lab_0x8f62cf94;
                                    }
                                    v30 = v31;
                                    // continue -> 0x8f62cf84
                                    continue;
                                }
                                case 10: {
                                    // 0x8f62cf94
                                    *(char *)(v30 + v25) = 0;
                                    v29 = v24;
                                    strlcpy(v1, v29, a3, v29, str2);
                                    // branch -> 0x8f62cfc4
                                    break;
                                }
                                case 13: {
                                    // 0x8f62cf94
                                    *(char *)(v30 + v25) = 0;
                                    v29 = v24;
                                    strlcpy(v1, v29, a3, v29, str2);
                                    // branch -> 0x8f62cfc4
                                    break;
                                }
                                case 0: {
                                    // 0x8f62cf94
                                    *(char *)(v30 + v25) = 0;
                                    v29 = v24;
                                    strlcpy(v1, v29, a3, v29, str2);
                                    // branch -> 0x8f62cfc4
                                    break;
                                }
                            }
                            // 0x8f62cfc4
                            free((char *)str);
                            int32_t result2 = result; // 0x8f62cfd0
                            // branch -> 0x8f62cfcc
                          lab_0x8f62cfcc:
                            // 0x8f62cfcc
                            if (v6 == g9) {
                                // 0x8f62cfec
                                g19 = v2;
                                g20 = v3;
                                g21 = v4;
                                g22 = v5;
                                return result2;
                            }
                          lab_0x8f62cfe0_4:
                            // 0x8f62cfe0
                            __stack_chk_fail();
                            // branch -> 0x8f62cfe4
                            // 0x8f62cfe4
                            result2 = -1;
                            // branch -> 0x8f62cfcc
                            goto lab_0x8f62cfcc;
                        }
                    }
                    // 0x8f62cfc4
                    free((char *)str);
                    // branch -> 0x8f62cfcc
                    // 0x8f62cfcc
                    if (v6 != g9) {
                        goto lab_0x8f62cfe0_4;
                    }
                    // 0x8f62cfec
                    g19 = v2;
                    g20 = v3;
                    g21 = v4;
                    g22 = v5;
                    return result;
                }
            }
        }
        // 0x8f62cfe4
        // branch -> 0x8f62cfcc
        goto lab_0x8f62cfcc_3;
    }
    // 0x8f62cfe4
    // branch -> 0x8f62cfcc
    goto lab_0x8f62cfcc_3;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strchrnul(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// char * strncat(char * restrict dest, const char * restrict src, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 21
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:40:37
