//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t alloc_scm_command(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_pll_clock(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t panel_power_off(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t panel_power_on(int32_t a1, int32_t a2, int32_t a3);
int32_t parse_setting_list(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_arm_support_available(int32_t a1, int32_t a2, int32_t a3);
int32_t scm_call2(int32_t * a1, int32_t a2, int32_t a3);
char * scm_call2_atomic(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_a32(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t scm_call_atomic(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_call_atomic2(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t scm_dload_mode(int32_t a1);
int32_t scm_init(int32_t a1);
char * scm_io_write(int32_t a1, int32_t a2, int32_t a3);
int32_t set_gpio(int32_t * a1, int32_t a2);
int32_t set_ldo(int32_t * a1, int32_t a2);
int32_t set_lvs(char * a1, int32_t a2);
int32_t set_pmic_gpio(char * a1, int32_t a2);
int32_t smc(int32_t a1, int32_t a2);
int32_t turn_off_backlight(int32_t a1, int32_t a2, int32_t a3);
int32_t turn_on_backlight(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g9 = 0; // LR
int32_t g10 = 0; // R0
int32_t g11 = 0; // R1
int32_t g12 = 0; // R11
int32_t g13 = 0; // R2
int32_t g14 = 0; // R3
int32_t g15 = 0; // R4
int32_t g16 = 0; // R5
int32_t g17 = 0; // R6
int32_t g18 = 0; // R7
int32_t g19 = 0; // R8
int32_t g1 = -1; // 0x8f6ac0d0
int32_t g2 = -1; // 0x8f6ac0d8
int32_t g3 = 0; // 0x8f6b8c84
int32_t (*g4)() = NULL; // 0x8f6b8c8c
int32_t (*g5)() = NULL; // 0x8f6b8c90
int32_t g6 = 0; // 0x8f7112f4
int32_t g7 = 0; // 0x8f7112fc
int32_t g8 = 0; // 0x8f711374

// ------------------------ Functions -------------------------

// Address range: 0x8f617b28 - 0x8f617c5f
int32_t set_gpio(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g15; // 0x8f617b28
    int32_t v3 = g16; // 0x8f617b28
    int32_t v4 = g17; // 0x8f617b28
    int32_t v5 = g9; // 0x8f617b28
    int32_t v6 = (int32_t)"set"; // R2
    int32_t v7 = g6;
    int32_t v8 = (int32_t)"set"; // 0x8f617b80
    if (a2 != 0) {
        // if_8f617b54_0_true
        v6 = (int32_t)"clear";
        v8 = (int32_t)"clear";
        // branch -> after_if_8f617b54_0
    }
    int32_t v9 = *(int32_t *)(v1 + 4); // 0x8f617b58
    int32_t v10 = *(int32_t *)(v1 + 16); // 0x8f617b60
    int32_t v11 = *(int32_t *)(v1 + 8); // 0x8f617b68
    int32_t v12 = *(int32_t *)(v1 + 12); // 0x8f617b70
    int32_t v13 = *a1; // 0x8f617b7c
    print_log(2, (int32_t)"%s gpio: gpio=%d, func=%d, dir=%d, pull=%d, drv=%d\n", v8, v13, v9, v10, v11, v12, 0, v7, v2, v3, v4);
    uint32_t v14 = *(int32_t *)(v1 + 28); // 0x8f617b84
    uint32_t v15 = v14 - 1; // 0x8f617b88
    int32_t v16; // R1
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20; // 0x8f617ba8
    int32_t v21; // 0x8f617bd0
    int32_t v22; // 0x8f617be4
    char v23; // 0x8f617ba8
    char v24; // 0x8f617bac
    int32_t v25; // 0x8f617bc4
    int32_t result; // 0x8f617bf4
    int32_t v26; // 0x8f617bb0
    int32_t v27; // 0x8f617bb4
    if (v15 <= 8) {
        // 0x8f617b94
        mdelay(v14, (int32_t)"%s gpio: gpio=%d, func=%d, dir=%d, pull=%d, drv=%d\n", v6, v15);
        // branch -> 0x8f617ba8
        // 0x8f617ba8
        v20 = v1;
        v23 = *(char *)(v20 + 12);
        v24 = *(char *)(v20 + 4);
        v26 = (int32_t)*(char *)(v20 + 16);
        v27 = (int32_t)*(char *)(v20 + 8);
        v25 = *(int32_t *)v20;
        gpio_tlmm_config(v25, (int32_t)v24, v26, v27, (int32_t)v23, 1, v11);
        v21 = v1;
        v17 = 0;
        if (a2 == 0) {
            // if_8f617bd4_0_true
            v17 = *(int32_t *)(v21 + 16);
            // branch -> after_if_8f617bd8_0
        }
        // after_if_8f617bd8_0
        gpio_set_dir(*(int32_t *)v21, v17, v26, v27);
        v22 = v1;
        v18 = 0;
        if (a2 == 0) {
            // if_8f617be8_0_true
            v18 = *(int32_t *)(v22 + 24);
            // branch -> after_if_8f617bec_0
        }
        // after_if_8f617bec_0
        v16 = v18;
        gpio_set_value(*(int32_t *)v22, v18, v26, v27);
        result = *(int32_t *)(v1 + 32);
        v19 = g6;
        if (result > 9) {
            // 0x8f617c20
            if (result < 10) {
                // 0x8f617c3c
                if (v7 == v19) {
                    // 0x8f617c48
                    g15 = v2;
                    g16 = v3;
                    g17 = v4;
                    return result;
                }
            } else {
                // 0x8f617c28
                if (v7 == v19) {
                    // 0x8f617c30
                    g15 = v2;
                    g16 = v3;
                    g17 = v4;
                    g9 = v5;
                    return thread_sleep(result, v16, v7, v7, v2, v3, v4, v5);
                }
            }
            // 0x8f617c44
            __stack_chk_fail();
            // branch -> 0x8f617c48
        } else {
            // 0x8f617c0c
            if (v7 == v19) {
                // 0x8f617c14
                g15 = v2;
                g16 = v3;
                g17 = v4;
                g9 = v5;
                return mdelay(result, v16, v7, v7);
            }
            // 0x8f617c44
            __stack_chk_fail();
            // branch -> 0x8f617c48
        }
        // 0x8f617c48
        g15 = v2;
        g16 = v3;
        g17 = v4;
        return result;
    }
    // 0x8f617b9c
    if (v14 >= 10) {
        // 0x8f617ba4
        thread_sleep(v14, (int32_t)"%s gpio: gpio=%d, func=%d, dir=%d, pull=%d, drv=%d\n", v6, v15, v9, v10, v11, v12);
        // branch -> 0x8f617ba8
    }
    // 0x8f617ba8
    v20 = v1;
    v23 = *(char *)(v20 + 12);
    v24 = *(char *)(v20 + 4);
    v26 = (int32_t)*(char *)(v20 + 16);
    v27 = (int32_t)*(char *)(v20 + 8);
    v25 = *(int32_t *)v20;
    gpio_tlmm_config(v25, (int32_t)v24, v26, v27, (int32_t)v23, 1, v11);
    v21 = v1;
    v17 = 0;
    if (a2 == 0) {
        // if_8f617bd4_0_true
        v17 = *(int32_t *)(v21 + 16);
        // branch -> after_if_8f617bd8_0
    }
    // after_if_8f617bd8_0
    gpio_set_dir(*(int32_t *)v21, v17, v26, v27);
    v22 = v1;
    v18 = 0;
    if (a2 == 0) {
        // if_8f617be8_0_true
        v18 = *(int32_t *)(v22 + 24);
        // branch -> after_if_8f617bec_0
    }
    // after_if_8f617bec_0
    v16 = v18;
    gpio_set_value(*(int32_t *)v22, v18, v26, v27);
    result = *(int32_t *)(v1 + 32);
    v19 = g6;
    if (result > 9) {
        // 0x8f617c20
        if (result < 10) {
            // 0x8f617c3c
            if (v7 == v19) {
                // 0x8f617c48
                g15 = v2;
                g16 = v3;
                g17 = v4;
                return result;
            }
        } else {
            // 0x8f617c28
            if (v7 == v19) {
                // 0x8f617c30
                g15 = v2;
                g16 = v3;
                g17 = v4;
                g9 = v5;
                return thread_sleep(result, v16, v7, v7, v2, v3, v4, v5);
            }
        }
        // 0x8f617c44
        __stack_chk_fail();
        // branch -> 0x8f617c48
    } else {
        // 0x8f617c0c
        if (v7 == v19) {
            // 0x8f617c14
            g15 = v2;
            g16 = v3;
            g17 = v4;
            g9 = v5;
            return mdelay(result, v16, v7, v7);
        }
        // 0x8f617c44
        __stack_chk_fail();
        // branch -> 0x8f617c48
    }
    // 0x8f617c48
    g15 = v2;
    g16 = v3;
    g17 = v4;
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 21
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:34:22
