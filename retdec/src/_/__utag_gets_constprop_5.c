//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __utag_gets_constprop_3_6(char * a1, int32_t a2);
int32_t __utag_gets_constprop_5(char * a1, int32_t a2, int32_t a3);
int32_t boot_handler(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t check_wififlash_mode(char * a1, int32_t a2);
int32_t fastboot_reason(int32_t a1);
int32_t fboot_ack(char * str, char * format, int32_t a3);
int32_t get_sku(char * a1, int32_t a2);
int32_t init_boot_event(int32_t a1, int32_t a2);
int32_t load_and_validate_kernel_image(int32_t a1);
char * mbm_entry(void);
char * mbm_init(void);
int32_t select_device_tree(int32_t a1, int32_t a2);
int32_t set_boot_item(int32_t result, int32_t a2, int32_t a3);
int32_t sparse_fill_value_in_blocks(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t type_atoi_5(char * str, int32_t a2, int32_t a3);
int32_t type_atoi_7(char * str, int32_t a2, int32_t a3);
int32_t update_console_token(char * a1, char * str, char * a3);

// --------------------- Global Variables ---------------------

int32_t g24 = 0; // LR
int32_t g25 = 0; // R0
int32_t g26 = 0; // R1
int32_t g27 = 0; // R10
int32_t g28 = 0; // R11
int32_t g29 = 0; // R2
int32_t g30 = 0; // R3
int32_t g31 = 0; // R4
int32_t g32 = 0; // R5
int32_t g33 = 0; // R6
int32_t g34 = 0; // R7
int32_t g35 = 0; // R8
int32_t g36 = 0; // R9
int32_t g1 = -0x16d2bf90; // 0x8f61db1c
int32_t g2 = -0x16d2bf81; // 0x8f61dca0
int32_t g3 = -0x16d2bfc9; // 0x8f6387c0
int32_t g4 = -0x16d2bc09; // 0x8f638ab0
int32_t g5 = 0x2020003a; // 0x8f686ac4
char g6[2] = " "; // 0x8f6a4f1e
int32_t g7 = 1; // 0x8f6ac0f0
char * g10 = "\xd4\xc7\x61\x8f\x90\x15\x60\x8f"; // 0x8f6ac19c
char * g11[2] = {
    "ttyHSL0,115200,n8",
    "ttyHSL0,115200,n8"
}; // 0x8f6ac1a8
int32_t g12 = -0x709c73f8; // 0x8f6ac374
char * g13; // 0x8f6c0298
int32_t g14 = 0; // 0x8f6c02e0
int32_t g15 = 0; // 0x8f6c02ec
char * g16; // 0x8f6c0334
int32_t g17 = 0; // 0x8f7112f4
char * g18; // 0x8f7114b0
int32_t g19 = 0; // 0x8f7114b4
int32_t g20 = 0; // 0x8f7114b8
int32_t g21 = 0; // 0x8f7114d4
char * g22; // 0x8f7114f0
int32_t g23 = 0; // 0x8f7125ec
char * g8[4] = {
    "null",
    "fastboot",
    (char *)&g1,
    (char *)&g2
}; // 0x8f6ac108
char * g9[3] = {
    "fastboot",
    (char *)&g1,
    (char *)&g2
}; // 0x8f6ac10c

// ------------------------ Functions -------------------------

// Address range: 0x8f61e95c - 0x8f61eafb
int32_t __utag_gets_constprop_5(char * a1, int32_t a2, int32_t a3) {
    // 0x8f61e95c
    int32_t v1;
    int32_t str = v1; // bp-68
    int32_t v2 = (int32_t)a1; // 0x8f61e95c_0
    int32_t v3 = g31; // 0x8f61e95c
    int32_t v4 = g33; // 0x8f61e95c
    g33 = v2;
    g32 = a2;
    g26 = v2;
    int32_t v5 = g17;
    g30 = v5;
    int32_t v6;
    uint32_t v7 = __utag_sizeof(NULL, v2, a3, v5, v6, v1, 0, 0, 0); // 0x8f61e984
    g31 = v7;
    int32_t v8;
    if (v7 == 0) {
        // after_if_8f61e99c_0.thread
        // branch -> 0x8f61eaac
        // 0x8f61eaac
        if (v7 > a3) {
            // 0x8f61eab4
            g26 = (int32_t)"!!! Cannot get utag %s: payload overflow\n";
            // branch -> 0x8f61ea68
            // 0x8f61ea68
            print_log(-1, (int32_t)"!!! Cannot get utag %s: payload overflow\n", g33, g30, v6, v1, 0, 0, 0, 0, 0, 0, 0);
            // branch -> 0x8f61eac4
        }
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return 0;
    }
    // after_if_8f61e99c_0
    if (v7 > a3) {
        // 0x8f61eaac
        if (v7 > a3) {
            // 0x8f61eab4
            g26 = (int32_t)"!!! Cannot get utag %s: payload overflow\n";
            // branch -> 0x8f61ea68
            // 0x8f61ea68
            print_log(-1, (int32_t)"!!! Cannot get utag %s: payload overflow\n", g33, g30, v6, v1, 0, 0, 0, 0, 0, 0, 0);
            // branch -> 0x8f61eac4
        }
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return 0;
    }
    int32_t v9 = g33; // 0x8f61e9ac
    g26 = v9;
    if (__utag_read(NULL, v9, g32, v7, v6, v1, 0, 0, 0, 0, 0, 0, 0) == 0) {
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return 0;
    }
    int32_t v10 = g31; // 0x8f61e9c4
    int32_t v11 = g32 + v10; // 0x8f61e9c4
    int32_t v12; // 0x8f61e9ec_0
    char * found_char_pos; // 0x8f61ea04
    int32_t v13; // 0x8f61ea10
    char * found_char_pos2; // 0x8f61ea44
    int32_t v14; // 0x8f61ea50
    int32_t v15; // 0x8f61ea84
    int32_t result;
    int32_t v16; // 0x8f61ea54
    if (*(char *)(v11 - 1) == 0) {
        // 0x8f61e9e4
        v12 = &str;
        strncpy((char *)&str, (char *)g33, 31);
        found_char_pos = strrchr((char *)&str, 58);
        v13 = type_atoi_7((char *)((int32_t)(found_char_pos != NULL) + (int32_t)found_char_pos), 58, 31);
        v16 = v13;
        if (v13 == 0) {
            // 0x8f61ea1c
            strlcat(v12, (int32_t)&g5, 31, g30, v6, str, 0, 0, 0, 0, 0, 0);
            strlcat(v12, (int32_t)"str", 31, g30, v6, str, 0, 0, 0, 0, 0, 0);
            found_char_pos2 = strrchr((char *)&str, 58);
            v14 = type_atoi_7((char *)((int32_t)(found_char_pos2 != NULL) + (int32_t)found_char_pos2), 58, 31);
            v16 = v14;
            // branch -> 0x8f61ea54
        }
        // 0x8f61ea54
        if (v16 == 255) {
            // 0x8f61ea5c
            g26 = (int32_t)"Error: not a string type: %s\n";
            // branch -> 0x8f61ea68
            // 0x8f61ea68
            print_log(-1, (int32_t)"Error: not a string type: %s\n", (int32_t)"<invalid>", g30, v6, str, 0, 0, 0, 0, 0, 0, 0);
            // branch -> 0x8f61eac4
            // 0x8f61eac4
            g29 = v5;
            v8 = g17;
            g30 = v8;
            if (v5 != v8) {
                // 0x8f61ead4
                __stack_chk_fail();
                // branch -> 0x8f61ead8
            }
            // 0x8f61ead8
            g31 = v3;
            g33 = v4;
            return 0;
        }
        // 0x8f61ea74
        g26 = v12;
        v15 = __utag_validate(NULL, v12, g32, g31, v6, str, 0, 0, 0, 0, 0, 0, 0, v5);
        g31 = v15;
        if (v15 == 0) {
            // 0x8f61ea94
            g26 = (int32_t)"!!! utag_validation FAIL for %s:%s\n";
            print_log(-1, (int32_t)"!!! utag_validation FAIL for %s:%s\n", g33, g32, v6, str, 0, 0, 0, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x8f61eac4
        } else {
            // if_8f61ea8c_0_true
            result = g32;
            // branch -> 0x8f61eac4
        }
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return result;
    }
    // 0x8f61e9d4
    if (v10 == a3) {
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return 0;
    }
    // if_8f61e9d8_0_true
    *(char *)v11 = 0;
    // branch -> 0x8f61e9e4
    // 0x8f61e9e4
    v12 = &str;
    strncpy((char *)&str, (char *)g33, 31);
    found_char_pos = strrchr((char *)&str, 58);
    v13 = type_atoi_7((char *)((int32_t)(found_char_pos != NULL) + (int32_t)found_char_pos), 58, 31);
    v16 = v13;
    if (v13 == 0) {
        // 0x8f61ea1c
        strlcat(v12, (int32_t)&g5, 31, g30, v6, str, 0, 0, 0, 0, 0, 0);
        strlcat(v12, (int32_t)"str", 31, g30, v6, str, 0, 0, 0, 0, 0, 0);
        found_char_pos2 = strrchr((char *)&str, 58);
        v14 = type_atoi_7((char *)((int32_t)(found_char_pos2 != NULL) + (int32_t)found_char_pos2), 58, 31);
        v16 = v14;
        // branch -> 0x8f61ea54
    }
    // 0x8f61ea54
    if (v16 == 255) {
        // 0x8f61ea5c
        g26 = (int32_t)"Error: not a string type: %s\n";
        // branch -> 0x8f61ea68
        // 0x8f61ea68
        print_log(-1, (int32_t)"Error: not a string type: %s\n", (int32_t)"<invalid>", g30, v6, str, 0, 0, 0, 0, 0, 0, 0);
        // branch -> 0x8f61eac4
        // 0x8f61eac4
        g29 = v5;
        v8 = g17;
        g30 = v8;
        if (v5 != v8) {
            // 0x8f61ead4
            __stack_chk_fail();
            // branch -> 0x8f61ead8
        }
        // 0x8f61ead8
        g31 = v3;
        g33 = v4;
        return 0;
    }
    // 0x8f61ea74
    g26 = v12;
    v15 = __utag_validate(NULL, v12, g32, g31, v6, str, 0, 0, 0, 0, 0, 0, 0, v5);
    g31 = v15;
    if (v15 == 0) {
        // 0x8f61ea94
        g26 = (int32_t)"!!! utag_validation FAIL for %s:%s\n";
        print_log(-1, (int32_t)"!!! utag_validation FAIL for %s:%s\n", g33, g32, v6, str, 0, 0, 0, 0, 0, 0, 0);
        result = 0;
        // branch -> 0x8f61eac4
    } else {
        // if_8f61ea8c_0_true
        result = g32;
        // branch -> 0x8f61eac4
    }
    // 0x8f61eac4
    g29 = v5;
    v8 = g17;
    g30 = v8;
    if (v5 != v8) {
        // 0x8f61ead4
        __stack_chk_fail();
        // branch -> 0x8f61ead8
    }
    // 0x8f61ead8
    g31 = v3;
    g33 = v4;
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// char * asctime(const struct tm * tp);
// struct tm * gmtime(const time_t * timer);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// char * strncat(char * restrict dest, const char * restrict src, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// size_t strnlen(const char * string, size_t maxlen);
// char * strrchr(char * s, int c);
// char * strtok(char * restrict s, const char * restrict delim);
// time_t time(time_t * timer);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 17
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:36:36
