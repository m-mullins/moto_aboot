//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_read(char * a1, int32_t a2, char * a3, int32_t a4);
int32_t __utag_write(char * a1, int32_t a2, char * a3, int32_t size);
void function_8f64b05c(void);
void function_8f64b0ac(int32_t a1, int32_t a2);
int32_t get_current_panel(void);
int32_t gfx_flush(int32_t * a1, int32_t a2, int32_t a3);
int32_t gfx_putpixel(int32_t a1, uint32_t a2, uint32_t a3);
int32_t handle_fboot_oem_command_write_protect_test(int32_t a1, int32_t a2);
int32_t is_gpt_initialized(int32_t a1);
int32_t is_usb_connected(int32_t a1, int32_t a2);
int32_t kpdpwr_n_irq_handler(int32_t a1, int32_t a2);
int32_t max17058_get_battery_capacity(int32_t a1, int32_t a2);
int32_t max17058_get_temp_thresholds(char * a1, int32_t a2, int32_t a3);
int32_t mp_mont_prod(int32_t * a1, int32_t result, int32_t a3, int32_t a4);
int32_t mp_mont_reduce(int32_t * a1, int32_t a2, int32_t a3);
int32_t pm8x41_ldo_get(int32_t a1, int32_t a2);
int32_t pm8x41_ldo_set_voltage(char * a1, int32_t a2, int32_t a3);
int32_t register_int_handler(int32_t a1, int32_t a2, int32_t a3);
int32_t send_usb_status_command(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t set_current_panel(int32_t a1, int32_t a2, int32_t a3);
int32_t speedo_delete(int32_t a1, int32_t a2);
int32_t speedo_start(int32_t a1, int32_t a2, int32_t a3);
int32_t target_detect(int32_t a1, int32_t a2, int32_t a3);
int32_t target_get_reset_status(char * a1, int32_t a2, int32_t a3);
int32_t thread_unblock_from_wait_queue(int32_t a1, int32_t a2, int32_t a3);
int32_t uninit_gpt(char * a1, int32_t a2);
int32_t unmask_interrupt(int32_t a1, int32_t a2, int32_t a3);
int32_t update_usb_status(int32_t a1, int32_t a2, int32_t a3);
int32_t wait_queue_timeout_handler(int32_t a1, int32_t a2, int32_t a3);
int32_t write_protect_enabled_on_eng_hw(int32_t a1, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g21 = 0; // LR
int32_t g22 = 0; // R0
int32_t g23 = 0; // R1
int32_t g24 = 0; // R10
int32_t g25 = 0; // R11
int32_t g26 = 0; // R12
int32_t g27 = 0; // R2
int32_t g28 = 0; // R3
int32_t g29 = 0; // R4
int32_t g30 = 0; // R5
int32_t g31 = 0; // R6
int32_t g32 = 0; // R7
int32_t g33 = 0; // R8
int32_t g34 = 0; // R9
int32_t g1 = 0x746e6300; // 0x8f6a4e20
int32_t g2 = 1; // 0x8f6ac0f0
int32_t g3 = 0xffff; // 0x8f6ac218
int32_t g4 = 1; // 0x8f6afd7c
char * g5; // 0x8f6e06b0
int32_t g6 = 0; // 0x8f6e06b4
int32_t g7 = 0; // 0x8f6e0718
int32_t g8 = 0; // 0x8f6e071c
int32_t g9 = 0; // 0x8f6e0748
int32_t g10 = 0; // 0x8f6e0764
int32_t g11 = 0; // 0x8f6e0b4c
int32_t g12 = 0; // 0x8f6e0b5c
int32_t g13 = 0; // 0x8f6e1310
char * g14; // 0x8f6e131c
char * g15; // 0x8f6e1400
char * g16; // 0x8f6e9400
int32_t g17 = 0; // 0x8f710e80
int32_t g18 = 0; // 0x8f7112f4
int32_t g19 = 0; // 0x8f711550
int32_t g20 = 0; // 0x8f711554

// ------------------------ Functions -------------------------

// Address range: 0x8f67961c - 0x8f6797bb
int32_t __utag_write(char * a1, int32_t a2, char * a3, int32_t size) {
    // 0x8f67961c
    int32_t v1;
    char * v2 = (char *)v1;
    int32_t v3 = (int32_t)a1;
    int32_t v4 = (int32_t)a3;
    int32_t v5 = g18;
    int32_t v6 = get_utags(v3, a2, v4); // 0x8f679640
    int32_t v7 = v6; // R9
    if (size != 0) {
        int32_t v8 = *(int32_t *)(v6 + 12); // 0x8f679650
        int32_t v9; // 0x8f679720_5
        int32_t v10; // 0x8f679740_3
        int32_t v11; // 0x8f679678
        int32_t v12; // 0x8f6796a4
        char * mem3; // 0x8f6796d0
        char * mem; // 0x8f679720
        char * mem2; // 0x8f679740
        int32_t v13; // R1
        int32_t v14; // R2
        int32_t v15; // R3
        int32_t v16; // R5
        int32_t v17; // R6
        int32_t v18;
        int32_t result;
        int32_t v19; // 0x8f67965c
        int32_t v20; // 0x8f6796dc
        int32_t v21; // 0x8f67966c
        int32_t v22; // 0x8f679670
        int32_t v23; // 0x8f679674
        int32_t v24; // 0x8f6796a0
        int32_t v25; // 0x8f6796f0
        int32_t v26; // 0x8f679708
        int32_t v27; // 0x8f67970c
        int32_t v28; // 0x8f67972c
        int32_t v29; // 0x8f679768
        uint32_t v30; // 0x8f6796b0
        int32_t v31; // 0x8f6796dc
        int32_t v32; // 0x8f679770
        int32_t v33; // 0x8f679774
        if (v8 == 0) {
            // 0x8f679688
            if (__utags_init(v3, a2, v4, 0, v18, v1, 0, v5, 0, g29, g30, g31, g32) == 0) {
                // 0x8f679688
                // branch -> 0x8f67965c
                // 0x8f67965c
                v19 = v7 + 20;
                v16 = v19;
                mutex_acquire(v19, a2, v4, v8, v18, v1, 0, v5, 0, g29, g30);
                v21 = a2;
                v22 = v4;
                v14 = v22;
                v23 = size;
                v15 = v23;
                v11 = __utag_validate((char *)v3, v21, v22, v23, v18, v1, 0, v5, 0, g29, g30, g31, g32, g33);
                if (v11 != 0) {
                    // 0x8f67969c
                    v24 = a2;
                    v13 = v24;
                    v12 = __find_first_utag(v3, v24, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31, g32, g33);
                    v17 = v12;
                    if (v12 == 0) {
                        // 0x8f679718
                        v13 = 52;
                        mem = calloc(1, 52);
                        v9 = (int32_t)mem;
                        v17 = v9;
                        if (mem != NULL) {
                            // 0x8f67972c
                            v28 = a2;
                            strlcpy(v9, v28, 32, v15, v18);
                            *(int32_t *)(v17 + 32) = size;
                            mem2 = malloc(size);
                            v10 = (int32_t)mem2;
                            v15 = v10;
                            *(int32_t *)(v17 + 44) = v10;
                            if (mem2 == NULL) {
                                // 0x8f679754
                                free((char *)v17);
                                // branch -> 0x8f6796bc
                                // 0x8f6796bc
                                mutex_release(v16, v28, 32, v15, v18, (int32_t)(char *)v15, 0);
                                result = 0;
                                // branch -> 0x8f67979c
                            } else {
                                // 0x8f679764
                                v29 = v4;
                                memcpy(mem2, (char *)v29, size);
                                v32 = *(int32_t *)(v7 + 12);
                                v15 = v32;
                                v33 = *(int32_t *)(v32 + 48);
                                v14 = v33;
                                *(int32_t *)(v17 + 48) = v33;
                                *(int32_t *)(v15 + 48) = v17;
                                *(int32_t *)(v7 + 16) = v17;
                                // branch -> 0x8f679784
                                // 0x8f679784
                                mutex_release(v16, v29, v14, v15, v18, v1, 0);
                                on_utag_change(v3, a2, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31);
                                result = size;
                                // branch -> 0x8f67979c
                            }
                            // 0x8f67979c
                            if (v5 != g18) {
                                // 0x8f6797ac
                                __stack_chk_fail();
                                // branch -> 0x8f6797b0
                            }
                            // 0x8f6797b0
                            return result;
                        }
                    } else {
                        // 0x8f6796b0
                        v30 = *(int32_t *)(v12 + 36);
                        v15 = v30;
                        if (v30 % 2 == 0) {
                            // 0x8f6796cc
                            mem3 = malloc(size);
                            v7 = (int32_t)mem3;
                            if (mem3 != NULL) {
                                // 0x8f6796dc
                                v20 = v17;
                                v31 = *(int32_t *)(v20 + 44);
                                v25 = v20;
                                if (v31 != 0) {
                                    // 0x8f6796e8
                                    free((char *)v31);
                                    v25 = v17;
                                    // branch -> 0x8f6796ec
                                }
                                // 0x8f6796ec
                                strlcpy(v25, a2, 32, v15, v18);
                                *(int32_t *)(v17 + 32) = size;
                                *(int32_t *)(v17 + 44) = v7;
                                v26 = v4;
                                v27 = size;
                                v14 = v27;
                                memcpy((char *)v7, (char *)v26, v27);
                                // branch -> 0x8f679784
                                // 0x8f679784
                                mutex_release(v16, v26, v14, v15, v18, v1, 0);
                                on_utag_change(v3, a2, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31);
                                // branch -> 0x8f67979c
                                // 0x8f67979c
                                if (v5 != g18) {
                                    // 0x8f6797ac
                                    __stack_chk_fail();
                                    // branch -> 0x8f6797b0
                                }
                                // 0x8f6797b0
                                return size;
                            }
                        }
                    }
                    // 0x8f6796bc
                    mutex_release(v16, v13, v14, v15, v18, (int32_t)v2, 0);
                    // branch -> 0x8f67979c
                    // 0x8f67979c
                    if (v5 != g18) {
                        // 0x8f6797ac
                        __stack_chk_fail();
                        // branch -> 0x8f6797b0
                    }
                    // 0x8f6797b0
                    return 0;
                }
                // 0x8f6796bc
                mutex_release(v16, v21, v14, v15, v18, (int32_t)v2, 0);
                // branch -> 0x8f67979c
            }
            // 0x8f67979c
            if (v5 != g18) {
                // 0x8f6797ac
                __stack_chk_fail();
                // branch -> 0x8f6797b0
            }
            // 0x8f6797b0
            return 0;
        }
        // 0x8f67965c
        v19 = v6 + 20;
        v16 = v19;
        mutex_acquire(v19, a2, v4, v8, v18, v1, 0, v5, 0, g29, g30);
        v21 = a2;
        v22 = v4;
        v14 = v22;
        v23 = size;
        v15 = v23;
        v11 = __utag_validate((char *)v3, v21, v22, v23, v18, v1, 0, v5, 0, g29, g30, g31, g32, g33);
        if (v11 != 0) {
            // 0x8f67969c
            v24 = a2;
            v13 = v24;
            v12 = __find_first_utag(v3, v24, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31, g32, g33);
            v17 = v12;
            if (v12 == 0) {
                // 0x8f679718
                v13 = 52;
                mem = calloc(1, 52);
                v9 = (int32_t)mem;
                v17 = v9;
                if (mem != NULL) {
                    // 0x8f67972c
                    v28 = a2;
                    strlcpy(v9, v28, 32, v15, v18);
                    *(int32_t *)(v17 + 32) = size;
                    mem2 = malloc(size);
                    v10 = (int32_t)mem2;
                    v15 = v10;
                    *(int32_t *)(v17 + 44) = v10;
                    if (mem2 == NULL) {
                        // 0x8f679754
                        free((char *)v17);
                        // branch -> 0x8f6796bc
                        // 0x8f6796bc
                        mutex_release(v16, v28, 32, v15, v18, (int32_t)(char *)v15, 0);
                        result = 0;
                        // branch -> 0x8f67979c
                    } else {
                        // 0x8f679764
                        v29 = v4;
                        memcpy(mem2, (char *)v29, size);
                        v32 = *(int32_t *)(v7 + 12);
                        v15 = v32;
                        v33 = *(int32_t *)(v32 + 48);
                        v14 = v33;
                        *(int32_t *)(v17 + 48) = v33;
                        *(int32_t *)(v15 + 48) = v17;
                        *(int32_t *)(v7 + 16) = v17;
                        // branch -> 0x8f679784
                        // 0x8f679784
                        mutex_release(v16, v29, v14, v15, v18, v1, 0);
                        on_utag_change(v3, a2, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31);
                        result = size;
                        // branch -> 0x8f67979c
                    }
                    // 0x8f67979c
                    if (v5 != g18) {
                        // 0x8f6797ac
                        __stack_chk_fail();
                        // branch -> 0x8f6797b0
                    }
                    // 0x8f6797b0
                    return result;
                }
            } else {
                // 0x8f6796b0
                v30 = *(int32_t *)(v12 + 36);
                v15 = v30;
                if (v30 % 2 == 0) {
                    // 0x8f6796cc
                    mem3 = malloc(size);
                    v7 = (int32_t)mem3;
                    if (mem3 != NULL) {
                        // 0x8f6796dc
                        v20 = v17;
                        v31 = *(int32_t *)(v20 + 44);
                        v25 = v20;
                        if (v31 != 0) {
                            // 0x8f6796e8
                            free((char *)v31);
                            v25 = v17;
                            // branch -> 0x8f6796ec
                        }
                        // 0x8f6796ec
                        strlcpy(v25, a2, 32, v15, v18);
                        *(int32_t *)(v17 + 32) = size;
                        *(int32_t *)(v17 + 44) = v7;
                        v26 = v4;
                        v27 = size;
                        v14 = v27;
                        memcpy((char *)v7, (char *)v26, v27);
                        // branch -> 0x8f679784
                        // 0x8f679784
                        mutex_release(v16, v26, v14, v15, v18, v1, 0);
                        on_utag_change(v3, a2, v14, v15, v18, v1, 0, v5, 0, g29, g30, g31);
                        // branch -> 0x8f67979c
                        // 0x8f67979c
                        if (v5 != g18) {
                            // 0x8f6797ac
                            __stack_chk_fail();
                            // branch -> 0x8f6797b0
                        }
                        // 0x8f6797b0
                        return size;
                    }
                }
            }
            // 0x8f6796bc
            mutex_release(v16, v13, v14, v15, v18, (int32_t)v2, 0);
            // branch -> 0x8f67979c
            // 0x8f67979c
            if (v5 != g18) {
                // 0x8f6797ac
                __stack_chk_fail();
                // branch -> 0x8f6797b0
            }
            // 0x8f6797b0
            return 0;
        }
        // 0x8f6796bc
        mutex_release(v16, v21, v14, v15, v18, (int32_t)v2, 0);
        // branch -> 0x8f67979c
    }
    // 0x8f67979c
    if (v5 != g18) {
        // 0x8f6797ac
        __stack_chk_fail();
        // branch -> 0x8f6797b0
    }
    // 0x8f6797b0
    return 0;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void * calloc(size_t nmemb, size_t size);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:31:13
