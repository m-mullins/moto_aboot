//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_describe(int32_t a1, int32_t a2, int32_t a3);
int32_t __utag_format(char * a1, int32_t a2, char * a3, int32_t a4, int32_t a5);
int32_t cmd_multiflash_mmc_img(char * str, char * a2, int32_t a3, int32_t a4);
int32_t cmd_multiflash_mmc_sparse_img(int32_t a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t dbval_provision_store(char * a1, int32_t * a2, char * a3);
int32_t dbval_validate_datablock(int32_t a1, int32_t a2, int32_t a3, char * a4);
int32_t disable_charger_mode(int32_t a1, int32_t a2);
int32_t fastboot_init_validators(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t fboot_cmd_multiflash_validate(int32_t a1, int32_t a2);
int32_t get_delay_abs_time(int32_t a1, int32_t a2, int32_t a3);
int32_t get_offset_ui_setting(int32_t a1, int32_t a2);
int32_t get_schedule_abs_time(int32_t a1);
int32_t is_recovery_mode(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_clear_rsa_ctx(char * a1, int32_t a2, int32_t a3);
int32_t mcs_hashSHA(int32_t a1, int32_t * a2, int32_t * a3);
int32_t mcs_mp_mont_prod(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_mp_mont_reduce(int32_t * a1, int32_t a2, int32_t a3);
int32_t mutex_acquire(int32_t a1, int32_t a2);
int32_t mutex_release(int32_t a1);
int32_t recovery_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t start_usb_detection(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t stop_charging(int32_t a1, int32_t a2);
int32_t stop_usb_detection(int32_t a1, int32_t a2);
int32_t target_display_pre_on(int32_t a1, int32_t a2, int32_t a3);
int32_t target_reboot_device(int32_t a1);
int32_t thread_preempt(void);
int32_t thread_resume(int32_t a1, int32_t a2);
int32_t wififlash_mode(int32_t a1, int32_t a2, int32_t a3);
int32_t XXH32_intermediateDigest(void);
int32_t XXH32_update(char * a1, char * a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g43 = 0; // LR
int32_t g44 = 0; // R0
int32_t g45 = 0; // R1
int32_t g46 = 0; // R10
int32_t g47 = 0; // R11
int32_t g48 = 0; // R2
int32_t g49 = 0; // R4
int32_t g50 = 0; // R5
int32_t g51 = 0; // R6
int32_t g52 = 0; // R7
int32_t g53 = 0; // R8
int32_t g54 = 0; // R9
int32_t g1 = -0x1a60cfd8; // 0x8f62dd14
int32_t g2 = -0x1a60cfd8; // 0x8f62dd48
int32_t g3 = -0x16d2bfed; // 0x8f62dd7c
int32_t g4 = -0x16d2bf09; // 0x8f62dee0
int32_t g5 = -0x16d2bf8d; // 0x8f62e0bc
int32_t g6 = -0x16d2bfc9; // 0x8f62e21c
int32_t g7 = -0x16d2bf8d; // 0x8f62e284
int32_t g8 = -0x16d2bfc9; // 0x8f62e74c
int32_t g9 = -0x16d2b010; // 0x8f62e900
int32_t g10 = -0x16d2bc10; // 0x8f62eb6c
int32_t g11 = -0x1a60c1d8; // 0x8f62f18c
int32_t g12 = -0x16d2bf8d; // 0x8f630638
int32_t g13 = -0x16d2bf09; // 0x8f634ac0
char * g14 = "\x01"; // 0x8f6a3f48
int32_t g15 = 1; // 0x8f6ac0f0
char * g16 = "\n"; // 0x8f6ac1b0
int32_t g17 = -1; // 0x8f6ac1c4
char * g18 = "\xf1"; // 0x8f6affa8
int32_t g19 = 0; // 0x8f6c0378
int32_t g20 = 0; // 0x8f6c037c
int64_t g21 = 0; // 0x8f6c0380
int32_t g22 = 0; // 0x8f6c0384
int32_t g23 = 0; // 0x8f6c0388
int32_t g24 = 0; // 0x8f6c038c
char * g25; // 0x8f6c0394
char * g26; // 0x8f6c03b8
int32_t g27 = 0; // 0x8f6c03c8
int32_t g28 = 0; // 0x8f6c03cc
char * g29; // 0x8f6c03d4
int32_t g30 = 0; // 0x8f6c03dc
char * g31; // 0x8f6c03e0
int32_t g32 = 0; // 0x8f6e07ec
int32_t g33 = 0; // 0x8f6e07f4
int32_t g34 = 0; // 0x8f6e0828
int16_t * g35 = NULL; // 0x8f70da9c
int32_t g36 = 0; // 0x8f70da9e
int32_t g37 = 0; // 0x8f7112f4
int32_t g38 = 0; // 0x8f7114ac
int32_t g39 = 0; // 0x8f7114f4
int32_t g40 = 0; // 0x8f7114f8
int32_t g41 = 0; // 0x8f71150c
int32_t g42 = 0; // 0x8f711510

// ------------------------ Functions -------------------------

// Address range: 0x8f65912c - 0x8f659303
int32_t XXH32_intermediateDigest(void) {
    int32_t v1 = g44 + 32; // 0x8f659134
    uint32_t v2 = v1 + *(int32_t *)(g44 + 28); // 0x8f65914c
    uint32_t v3 = *(int32_t *)g44; // 0x8f659158
    int32_t v4 = *(int32_t *)(g44 + 4); // 0x8f659158
    uint32_t v5; // 0x8f6592b4
    uint32_t v6; // 0x8f6592bc
    uint32_t v7; // 0x8f6592c8
    if (*(char *)&g14 != 1) {
        bool v8 = false; // 0x8f659210
        bool v9 = false; // 0x8f659210
        if (v4 == 0) {
            // if_8f65920c_0_true
            v8 = v3 == 15;
            v9 = v3 < 15;
            // branch -> after_if_8f65920c_0
        }
        // after_if_8f65920c_0
        int32_t v10;
        if (v8 || v9) {
            // 0x8f659238
            v10 = *(int32_t *)(g44 + 8) + 0x165667b1;
            // branch -> 0x8f659244
        } else {
            int32_t v11 = *(int32_t *)(g44 + 12); // 0x8f659214
            uint32_t v12 = *(int32_t *)(g44 + 16); // 0x8f659218
            uint32_t v13 = *(int32_t *)(g44 + 20); // 0x8f659224
            uint32_t v14 = *(int32_t *)(g44 + 24); // 0x8f659228
            int32_t v15 = (0x1000 * v13 | v13 / 0x100000) + (128 * v12 | v12 / 0x2000000) + (2 * v11 | (int32_t)(v11 < 0)) + (0x40000 * v14 | v14 / 0x4000); // 0x8f659230
            v10 = v15;
            // branch -> 0x8f659244
        }
        int32_t v16 = v10 + v3; // 0x8f659244
        uint32_t v17 = v2 - 4; // 0x8f659250
        int32_t v18 = v1; // 0x8f65929819
        int32_t v19; // 0x8f65929c
        int32_t v20; // 0x8f6592a8
        int32_t v21; // 0x8f65929c
        uint32_t v22; // 0x8f6592a0
        if (v1 <= v17) {
            while (true) {
                char v23 = *(char *)(v1 + 1); // 0x8f65925c
                int32_t v24 = v1 + 4; // 0x8f659260
                char v25 = *(char *)v1; // 0x8f659264
                char v26 = *(char *)(v1 + 2); // 0x8f65926c
                char v27 = *(char *)(v1 + 3); // 0x8f659274
                uint32_t v28 = v16 + -0x3d4d51c3 * llvm_bswap_i32(0x1000000 * (int32_t)v27 | 0x10000 * (int32_t)v26 | (int32_t)v25 | 256 * (int32_t)v23); // 0x8f65928061
                int32_t v29 = 0x27d4eb2f * (0x20000 * v28 | v28 / 0x8000); // 0x8f659288
                if (v24 > v17) {
                    v16 = v29;
                    v18 = v24;
                    // break -> 0x8f659290
                    break;
                }
                v16 = v29;
                v1 = v24;
                // continue -> 0x8f65925c
            }
            // 0x8f659290
            v5 = v16;
            if (v18 >= v2) {
                // 0x8f6592e0
                v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
                v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
                return v7 / 0x10000 ^ v7;
            }
            v19 = v18;
            v21 = v19 + 1;
            v22 = 0x165667b1 * (int32_t)*(char *)v19 + v16;
            v20 = -0x61c8864f * (2048 * v22 | v22 / 0x200000);
            v5 = v20;
            while (v21 < v2) {
                // if_8f6592a4_0_true
                v19 = v21;
                v21 = v19 + 1;
                v22 = 0x165667b1 * (int32_t)*(char *)v19 + v20;
                v20 = -0x61c8864f * (2048 * v22 | v22 / 0x200000);
                v5 = v20;
                // continue -> if_8f6592a4_0_true
            }
            // 0x8f6592e0
            v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
            v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
            return v7 / 0x10000 ^ v7;
        }
        // 0x8f659290
        if (v18 < v2) {
            v19 = v18;
            v21 = v19 + 1;
            v22 = 0x165667b1 * (int32_t)*(char *)v19 + v16;
            v20 = -0x61c8864f * (2048 * v22 | v22 / 0x200000);
            v5 = v20;
            while (v21 < v2) {
                // if_8f6592a4_0_true
                v19 = v21;
                v21 = v19 + 1;
                v22 = 0x165667b1 * (int32_t)*(char *)v19 + v20;
                v20 = -0x61c8864f * (2048 * v22 | v22 / 0x200000);
                v5 = v20;
                // continue -> if_8f6592a4_0_true
            }
            // 0x8f6592e0
            v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
            v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
            return v7 / 0x10000 ^ v7;
        }
        v5 = v16;
        // 0x8f6592e0
        v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
        v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
        return v7 / 0x10000 ^ v7;
    }
    bool v30 = false; // 0x8f659168
    bool v31 = false; // 0x8f659168
    if (v4 == 0) {
        // if_8f659164_0_true
        v30 = v3 == 15;
        v31 = v3 < 15;
        // branch -> after_if_8f659164_0
    }
    // after_if_8f659164_0
    int32_t v32;
    if (v30 || v31) {
        // 0x8f659190
        v32 = *(int32_t *)(g44 + 8) + 0x165667b1;
        // branch -> 0x8f65919c
    } else {
        int32_t v33 = *(int32_t *)(g44 + 12); // 0x8f65916c
        uint32_t v34 = *(int32_t *)(g44 + 16); // 0x8f659170
        uint32_t v35 = *(int32_t *)(g44 + 20); // 0x8f65917c
        uint32_t v36 = *(int32_t *)(g44 + 24); // 0x8f659180
        int32_t v37 = (0x1000 * v35 | v35 / 0x100000) + (128 * v34 | v34 / 0x2000000) + (2 * v33 | (int32_t)(v33 < 0)) + (0x40000 * v36 | v36 / 0x4000); // 0x8f659188
        v32 = v37;
        // branch -> 0x8f65919c
    }
    int32_t v38 = v32 + v3; // 0x8f65919c
    uint32_t v39 = v2 - 4; // 0x8f6591a8
    int32_t v40 = v1; // 0x8f6591ec9
    int32_t v41; // 0x8f6591f4
    int32_t v42; // 0x8f659200
    int32_t v43; // 0x8f6591f4
    uint32_t v44; // 0x8f6591f8
    if (v1 > v39) {
        // 0x8f6591e4
        if (v40 < v2) {
            v5 = v38;
            // 0x8f6592e0
            v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
            v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
            return v7 / 0x10000 ^ v7;
        }
        v41 = v40;
        v43 = v41 + 1;
        v44 = 0x165667b1 * (int32_t)*(char *)v41 + v38;
        v42 = -0x61c8864f * (2048 * v44 | v44 / 0x200000);
        v5 = v42;
        while (v43 >= v2) {
            // 0x8f6591f4
            v41 = v43;
            v43 = v41 + 1;
            v44 = 0x165667b1 * (int32_t)*(char *)v41 + v42;
            v42 = -0x61c8864f * (2048 * v44 | v44 / 0x200000);
            v5 = v42;
            // continue -> 0x8f6591f4
        }
        // 0x8f6592e0
        v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
        v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
        return v7 / 0x10000 ^ v7;
    }
    int32_t v45 = v1; // 0x8f6591b4
    while (true) {
        char v46 = *(char *)(v45 + 1); // 0x8f6591b4
        int32_t v47 = v45 + 4; // 0x8f6591b8
        char v48 = *(char *)v45; // 0x8f6591bc
        char v49 = *(char *)(v45 + 2); // 0x8f6591c4
        char v50 = *(char *)(v45 + 3); // 0x8f6591cc
        uint32_t v51 = v38 + -0x3d4d51c3 * (0x1000000 * (int32_t)v50 | 0x10000 * (int32_t)v49 | (int32_t)v48 | 256 * (int32_t)v46); // 0x8f6591d460
        int32_t v52 = 0x27d4eb2f * (0x20000 * v51 | v51 / 0x8000); // 0x8f6591dc
        if (v47 > v39) {
            v38 = v52;
            v40 = v47;
            // break -> 0x8f6591e4
            break;
        }
        v38 = v52;
        v45 = v47;
        // continue -> 0x8f6591b4
    }
    // 0x8f6591e4
    if (v40 < v2) {
        v5 = v38;
        // 0x8f6592e0
        v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
        v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
        return v7 / 0x10000 ^ v7;
    }
    v41 = v40;
    v43 = v41 + 1;
    v44 = 0x165667b1 * (int32_t)*(char *)v41 + v38;
    v42 = -0x61c8864f * (2048 * v44 | v44 / 0x200000);
    v5 = v42;
    while (v43 >= v2) {
        // 0x8f6591f4
        v41 = v43;
        v43 = v41 + 1;
        v44 = 0x165667b1 * (int32_t)*(char *)v41 + v42;
        v42 = -0x61c8864f * (2048 * v44 | v44 / 0x200000);
        v5 = v42;
        // continue -> 0x8f6591f4
    }
    // 0x8f6592e0
    v6 = -0x7a143589 * (v5 / 0x8000 ^ v5);
    v7 = -0x3d4d51c3 * (v6 / 0x2000 ^ v6);
    return v7 / 0x10000 ^ v7;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:49:15
