//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_defined(int32_t a1, int32_t a2);
char * __utag_typeof(void);
int32_t handle_fboot_command_boot(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t handle_fboot_command_continue(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t heap_alloc(uint32_t a1, uint32_t a2);
int32_t heap_free(void);
int32_t is_piv_magic(char * str, int32_t a2);
char * is_secure_boot_enable(int32_t a1);
int32_t mcs_clear_rng_ctx(int32_t a1, int32_t a2);
int32_t mcs_habp_rsa_core(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, int32_t * a7);
int32_t mcs_habp_rsa_crt_large(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_rsa_do_rsa(char * a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t mdp_dsi_cmd_config(int32_t a1, int32_t a2);
int32_t mdp_dsi_video_on(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mdss_qos_remapper_setup(int32_t result, int32_t a2, int32_t a3);
char * mdss_vbif_qos_remapper_setup(int32_t a1);
int32_t mipi_dsi_cmd_bta_sw_trigger(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_cmds_rx(int32_t * a1, int32_t result);
int32_t misc_check_mode(char * a1, int32_t a2);
int32_t pm8x41_chgr_led_enable(int32_t a1, int32_t a2);
int32_t rtc_get(void);
char * scm_io_write(int32_t a1, int32_t a2, int32_t a3);
int32_t set_accessory_type(int32_t a1);
int32_t thread_init(int32_t a1, int32_t a2);
int32_t thread_init_early(void);
int32_t thread_sleep(int32_t a1);
int32_t type_atoi_98(char * str, int32_t a2, int32_t a3);
int32_t XXH32(char * a1, int32_t a2, int32_t a3);
int32_t XXH32_resetState(int32_t * a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g25 = 0; // R0
int32_t g26 = 0; // R1
int32_t g27 = 0; // R11
int32_t g28 = 0; // R2
int32_t g29 = 0; // R4
int32_t g30 = 0; // R5
int32_t g31 = 0; // R6
int32_t g32 = 0; // R7
int32_t g33 = 0; // R8
int32_t g34 = 0; // R9
int32_t g1 = -0x16d2bfc9; // 0x8f61b264
char * g2; // 0x8f622364
int32_t g3 = -0x16d2bfc9; // 0x8f6387c0
int32_t g4 = -0x16d2bc09; // 0x8f638ab0
char * g5 = "\x01"; // 0x8f6a3f48
char * g6 = "\x4d\x4f\x54\x4f\x13\x57\x9b"; // 0x8f6a42ac
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = 10; // 0x8f6afe00
char (*g9)[14] = "boot-recovery"; // 0x8f6aff94
int32_t g10 = 0; // 0x8f6c0064
int32_t g11 = 0; // 0x8f6c0164
int32_t g12 = 0; // 0x8f6c0168
char * g13; // 0x8f6c016c
int32_t g14 = 0; // 0x8f6c0170
int32_t g15 = 0; // 0x8f6c0174
int32_t g16 = 0; // 0x8f6c0180
int32_t g17 = 0; // 0x8f6c0184
int32_t g18 = 0; // 0x8f6c0188
int32_t g19 = 0; // 0x8f6c01b0
int32_t g20 = 0; // 0x8f6e0bf0
int32_t g21 = 0; // 0x8f6e0bf4
char * g22; // 0x8f6ed840
int32_t g23 = 0; // 0x8f7112f4
int32_t g24 = 0; // 0x8f7114ac

// ------------------------ Functions -------------------------

// Address range: 0x8f658670 - 0x8f658ba7
int32_t XXH32(char * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1; // 0x8f658670_0
    int32_t v2 = a3; // R2
    int32_t v3 = g23;
    char v4 = *(char *)&g5; // 0x8f658688
    uint32_t v5 = v1 + a2; // 0x8f65868c
    int32_t v6; // 0x8f658b50
    uint32_t v7; // 0x8f658b5c
    uint32_t v8; // 0x8f658b64
    if (v1 % 4 != 0) {
        // 0x8f658694
        if (v4 == 1) {
            // 0x8f65869c
            int32_t v9;
            if (a2 < 16) {
                v9 = a3 + 0x165667b1;
                // branch -> 0x8f658730
            } else {
                int32_t v10 = v1 + 16; // 0x8f6586cc
                uint32_t v11 = a3 + 0x24234428 + -0x7a143589 * *(int32_t *)v1; // 0x8f6586d0140
                uint32_t v12 = a3 - 0x7a143589 + -0x7a143589 * *(int32_t *)(v1 + 4); // 0x8f6586d8141
                int32_t v13 = 0x2000 * v11 | v11 / 0x80000; // 0x8f6586e0
                uint32_t v14 = a3 + -0x7a143589 * *(int32_t *)(v1 + 8); // 0x8f6586e4142
                int32_t v15 = 0x2000 * v12 | v12 / 0x80000; // 0x8f6586ec
                int32_t v16 = -0x61c8864f * v13; // 0x8f6586f4
                uint32_t v17 = a3 + 0x61c8864f + -0x7a143589 * *(int32_t *)(v1 + 12); // 0x8f6586f8143
                int32_t v18 = 0x2000 * v14 | v14 / 0x80000; // 0x8f6586fc
                int32_t v19 = -0x61c8864f * v15; // 0x8f658700
                int32_t v20 = -0x61c8864f * v18; // 0x8f658704
                int32_t v21 = 0x2000 * v17 | v17 / 0x80000; // 0x8f658708
                int32_t v22 = -0x61c8864f * v21; // 0x8f65870c
                // branch -> 0x8f6586c8
                while (v10 <= v5 - 16) {
                    // 0x8f6586c8
                    v1 = v10;
                    v10 = v1 + 16;
                    v11 = v16 + -0x7a143589 * *(int32_t *)v1;
                    v12 = v19 + -0x7a143589 * *(int32_t *)(v1 + 4);
                    v13 = 0x2000 * v11 | v11 / 0x80000;
                    v14 = v20 + -0x7a143589 * *(int32_t *)(v1 + 8);
                    v15 = 0x2000 * v12 | v12 / 0x80000;
                    v16 = -0x61c8864f * v13;
                    v17 = v22 + -0x7a143589 * *(int32_t *)(v1 + 12);
                    v18 = 0x2000 * v14 | v14 / 0x80000;
                    v19 = -0x61c8864f * v15;
                    v20 = -0x61c8864f * v18;
                    v21 = 0x2000 * v17 | v17 / 0x80000;
                    v22 = -0x61c8864f * v21;
                    // continue -> 0x8f6586c8
                }
                int32_t v23 = (v19 / 0x2000000 | 0x1bbcd880 * v15) + ((int32_t)(v16 < 0) | 0x3c6ef362 * v13) + (v20 / 0x100000 | 0x779b1000 * v18) + (v22 / 0x4000 | -0x193c0000 * v21); // 0x8f658720
                v1 = v10;
                v9 = v23;
                // branch -> 0x8f658730
            }
            int32_t v24 = v9 + a2; // 0x8f658734
            uint32_t v25 = v5 - 4; // 0x8f65873c
            int32_t v26 = v1; // 0x8f65876035
            int32_t v27; // 0x8f658768
            int32_t v28; // 0x8f658774
            int32_t v29; // 0x8f658768
            uint32_t v30; // 0x8f65876c
            if (v1 <= v25) {
                int32_t v31 = v1; // 0x8f658744
                while (true) {
                    int32_t v32 = v31 + 4; // 0x8f658744
                    uint32_t v33 = v24 + -0x3d4d51c3 * *(int32_t *)v31; // 0x8f658748144
                    int32_t v34 = 0x27d4eb2f * (0x20000 * v33 | v33 / 0x8000); // 0x8f658750
                    if (v32 > v25) {
                        v24 = v34;
                        v26 = v32;
                        // break -> 0x8f658758
                        break;
                    }
                    v24 = v34;
                    v31 = v32;
                    // continue -> after_if_8f658748_0
                }
                // 0x8f658758
                v6 = v24;
                if (v26 < v5) {
                    // 0x8f658b4c
                    v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                    v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                    if (v3 != g23) {
                        // 0x8f658b78
                        __stack_chk_fail();
                        // branch -> 0x8f658b7c
                    }
                    // 0x8f658b7c
                    return v8 / 0x10000 ^ v8;
                }
                v27 = v26;
                v29 = v27 + 1;
                v30 = 0x165667b1 * (int32_t)*(char *)v27 + v24;
                v28 = -0x61c8864f * (2048 * v30 | v30 / 0x200000);
                v6 = v28;
                while (v29 >= v5) {
                    // 0x8f658768
                    v27 = v29;
                    v29 = v27 + 1;
                    v30 = 0x165667b1 * (int32_t)*(char *)v27 + v28;
                    v28 = -0x61c8864f * (2048 * v30 | v30 / 0x200000);
                    v6 = v28;
                    // continue -> 0x8f658768
                }
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            // 0x8f658758
            if (v26 >= v5) {
                v27 = v26;
                v29 = v27 + 1;
                v30 = 0x165667b1 * (int32_t)*(char *)v27 + v24;
                v28 = -0x61c8864f * (2048 * v30 | v30 / 0x200000);
                v6 = v28;
                while (v29 >= v5) {
                    // 0x8f658768
                    v27 = v29;
                    v29 = v27 + 1;
                    v30 = 0x165667b1 * (int32_t)*(char *)v27 + v28;
                    v28 = -0x61c8864f * (2048 * v30 | v30 / 0x200000);
                    v6 = v28;
                    // continue -> 0x8f658768
                }
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            v6 = v24;
        } else {
            // 0x8f65877c
            int32_t v35;
            if (a2 < 16) {
                v35 = a3 + 0x165667b1;
                // branch -> 0x8f658820
            } else {
                int32_t v36 = a3 + 0x61c8864f; // 0x8f6587ec
                int32_t v37 = v1 + 16; // 0x8f6587ac
                uint32_t v38 = a3 + 0x24234428 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)v1); // 0x8f6587b4145
                uint32_t v39 = a3 - 0x7a143589 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 4)); // 0x8f6587c0146
                int32_t v40 = 0x2000 * v38 | v38 / 0x80000; // 0x8f6587c8
                int32_t v41 = -0x61c8864f * v40; // 0x8f6587d0
                uint32_t v42 = a3 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 8)); // 0x8f6587d4147
                int32_t v43 = 0x2000 * v39 | v39 / 0x80000; // 0x8f6587dc
                int32_t v44 = -0x61c8864f * v43; // 0x8f6587e8
                uint32_t v45 = v36 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 12)); // 0x8f6587ec148
                int32_t v46 = 0x2000 * v42 | v42 / 0x80000; // 0x8f6587f0
                int32_t v47 = -0x61c8864f * v46; // 0x8f6587f4
                int32_t v48 = 0x2000 * v45 | v45 / 0x80000; // 0x8f6587f8
                int32_t v49 = -0x61c8864f * v48; // 0x8f6587fc
                // branch -> 0x8f6587a8
                while (v37 <= v5 - 16) {
                    // 0x8f6587a8
                    v1 = v37;
                    v37 = v1 + 16;
                    v38 = v41 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)v1);
                    v39 = v44 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 4));
                    v40 = 0x2000 * v38 | v38 / 0x80000;
                    v41 = -0x61c8864f * v40;
                    v42 = v47 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 8));
                    v43 = 0x2000 * v39 | v39 / 0x80000;
                    v44 = -0x61c8864f * v43;
                    v45 = v49 + -0x7a143589 * llvm_bswap_i32(*(int32_t *)(v1 + 12));
                    v46 = 0x2000 * v42 | v42 / 0x80000;
                    v47 = -0x61c8864f * v46;
                    v48 = 0x2000 * v45 | v45 / 0x80000;
                    v49 = -0x61c8864f * v48;
                    // continue -> 0x8f6587a8
                }
                int32_t v50 = (v49 / 0x4000 | -0x193c0000 * v48) + (v47 / 0x100000 | 0x779b1000 * v46) + (v44 / 0x2000000 | 0x1bbcd880 * v43) + ((int32_t)(v41 < 0) | 0x3c6ef362 * v40); // 0x8f658810
                v1 = v37;
                v35 = v50;
                // branch -> 0x8f658820
            }
            int32_t v51 = v35 + a2; // 0x8f658824
            uint32_t v52 = v5 - 4; // 0x8f65882c
            int32_t v53 = v1; // 0x8f65885845
            int32_t v54; // 0x8f658860
            int32_t v55; // 0x8f65886c
            int32_t v56; // 0x8f658860
            uint32_t v57; // 0x8f658864
            if (v1 <= v52) {
                int32_t v58 = v1; // 0x8f658838
                while (true) {
                    int32_t v59 = v58 + 4; // 0x8f658838
                    uint32_t v60 = v51 + -0x3d4d51c3 * llvm_bswap_i32(*(int32_t *)v58); // 0x8f658840149
                    int32_t v61 = 0x27d4eb2f * (0x20000 * v60 | v60 / 0x8000); // 0x8f658848
                    if (v59 > v52) {
                        v51 = v61;
                        v53 = v59;
                        // break -> 0x8f658850
                        break;
                    }
                    v51 = v61;
                    v58 = v59;
                    // continue -> 0x8f658838
                }
                // 0x8f658850
                v6 = v51;
                if (v53 < v5) {
                    // 0x8f658b4c
                    v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                    v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                    if (v3 != g23) {
                        // 0x8f658b78
                        __stack_chk_fail();
                        // branch -> 0x8f658b7c
                    }
                    // 0x8f658b7c
                    return v8 / 0x10000 ^ v8;
                }
                v54 = v53;
                v56 = v54 + 1;
                v57 = 0x165667b1 * (int32_t)*(char *)v54 + v51;
                v55 = -0x61c8864f * (2048 * v57 | v57 / 0x200000);
                v6 = v55;
                while (v56 >= v5) {
                    // 0x8f658860
                    v54 = v56;
                    v56 = v54 + 1;
                    v57 = 0x165667b1 * (int32_t)*(char *)v54 + v55;
                    v55 = -0x61c8864f * (2048 * v57 | v57 / 0x200000);
                    v6 = v55;
                    // continue -> 0x8f658860
                }
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            // 0x8f658850
            if (v53 >= v5) {
                v54 = v53;
                v56 = v54 + 1;
                v57 = 0x165667b1 * (int32_t)*(char *)v54 + v51;
                v55 = -0x61c8864f * (2048 * v57 | v57 / 0x200000);
                v6 = v55;
                while (v56 >= v5) {
                    // 0x8f658860
                    v54 = v56;
                    v56 = v54 + 1;
                    v57 = 0x165667b1 * (int32_t)*(char *)v54 + v55;
                    v55 = -0x61c8864f * (2048 * v57 | v57 / 0x200000);
                    v6 = v55;
                    // continue -> 0x8f658860
                }
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            v6 = v51;
        }
        // 0x8f658b4c
        v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
        v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
        if (v3 != g23) {
            // 0x8f658b78
            __stack_chk_fail();
            // branch -> 0x8f658b7c
        }
        // 0x8f658b7c
        return v8 / 0x10000 ^ v8;
    }
    // 0x8f658874
    int32_t v62; // R12
    int32_t v63; // R7
    int32_t v64; // R8
    if (v4 == 1) {
        // 0x8f65887c
        int32_t v65;
        uint32_t v66; // 0x8f6589c014
        if (a2 < 16) {
            v66 = v5;
            v65 = a3 + 0x165667b1;
            // branch -> 0x8f658970
        } else {
            // 0x8f658884
            v64 = -0x7a143589;
            v63 = -0x61c8864f;
            v62 = a3 + 0x61c8864f;
            int32_t v67 = a3 - 0x7a143589; // 0x8f6588f4
            int32_t v68 = a3 + 0x24234428; // 0x8f6588cc
            int32_t v69 = -0x7a143589; // 0x8f6588f4
            char v70 = *(char *)(v1 + 1); // 0x8f6588a8
            char v71 = *(char *)v1; // 0x8f6588b0
            char v72 = *(char *)(v1 + 2); // 0x8f6588b8
            char v73 = *(char *)(v1 + 3); // 0x8f6588c0
            char v74 = *(char *)(v1 + 5); // 0x8f6588c8
            uint32_t v75 = (0x1000000 * (int32_t)v73 | 0x10000 * (int32_t)v72 | (int32_t)v71 | 256 * (int32_t)v70) * v69 + v68; // 0x8f6588cc
            char v76 = *(char *)(v1 + 4); // 0x8f6588d0
            char v77 = *(char *)(v1 + 6); // 0x8f6588d8
            char v78 = *(char *)(v1 + 7); // 0x8f6588e0
            char v79 = *(char *)(v1 + 9); // 0x8f6588ec
            int32_t v80 = -0x61c8864f * (0x2000 * v75 | v75 / 0x80000); // 0x8f6588f0
            uint32_t v81 = (0x1000000 * (int32_t)v78 | 0x10000 * (int32_t)v77 | (int32_t)v76 | 256 * (int32_t)v74) * v69 + v67; // 0x8f6588f4
            char v82 = *(char *)(v1 + 8); // 0x8f6588f8
            char v83 = *(char *)(v1 + 10); // 0x8f658900
            char v84 = *(char *)(v1 + 11); // 0x8f658908
            char v85 = *(char *)(v1 + 13); // 0x8f658914
            int32_t v86 = (0x2000 * v81 | v81 / 0x80000) * v63; // 0x8f658918
            uint32_t v87 = v2 + v64 * (0x1000000 * (int32_t)v84 | 0x10000 * (int32_t)v83 | (int32_t)v82 | 256 * (int32_t)v79); // 0x8f65891c
            int32_t v88 = v1 + 16; // 0x8f658920
            char v89 = *(char *)(v88 - 4); // 0x8f658920
            char v90 = *(char *)(v88 - 2); // 0x8f658928
            char v91 = *(char *)(v88 - 1); // 0x8f658930
            int32_t v92 = (0x2000 * v87 | v87 / 0x80000) * v63; // 0x8f658940
            uint32_t v93 = (0x1000000 * (int32_t)v91 | 0x10000 * (int32_t)v90 | (int32_t)v89 | 256 * (int32_t)v85) * v64 + v62; // 0x8f658944
            int32_t v94 = (0x2000 * v93 | v93 / 0x80000) * v63; // 0x8f65894c
            // branch -> 0x8f6588a8
            while (v88 <= v5 - 16) {
                // 0x8f6588a8
                v69 = v64;
                v1 = v88;
                v70 = *(char *)(v1 + 1);
                v71 = *(char *)v1;
                v72 = *(char *)(v1 + 2);
                v73 = *(char *)(v1 + 3);
                v74 = *(char *)(v1 + 5);
                v75 = (0x1000000 * (int32_t)v73 | 0x10000 * (int32_t)v72 | (int32_t)v71 | 256 * (int32_t)v70) * v69 + v80;
                v76 = *(char *)(v1 + 4);
                v77 = *(char *)(v1 + 6);
                v78 = *(char *)(v1 + 7);
                v79 = *(char *)(v1 + 9);
                v80 = (0x2000 * v75 | v75 / 0x80000) * v63;
                v81 = (0x1000000 * (int32_t)v78 | 0x10000 * (int32_t)v77 | (int32_t)v76 | 256 * (int32_t)v74) * v69 + v86;
                v82 = *(char *)(v1 + 8);
                v83 = *(char *)(v1 + 10);
                v84 = *(char *)(v1 + 11);
                v85 = *(char *)(v1 + 13);
                v86 = (0x2000 * v81 | v81 / 0x80000) * v63;
                v87 = v92 + v64 * (0x1000000 * (int32_t)v84 | 0x10000 * (int32_t)v83 | (int32_t)v82 | 256 * (int32_t)v79);
                v88 = v1 + 16;
                v89 = *(char *)(v88 - 4);
                v90 = *(char *)(v88 - 2);
                v91 = *(char *)(v88 - 1);
                v92 = (0x2000 * v87 | v87 / 0x80000) * v63;
                v93 = (0x1000000 * (int32_t)v91 | 0x10000 * (int32_t)v90 | (int32_t)v89 | 256 * (int32_t)v85) * v64 + v94;
                v94 = (0x2000 * v93 | v93 / 0x80000) * v63;
                // continue -> 0x8f6588a8
            }
            int32_t v95 = (0x40000 * v94 | v94 / 0x4000) + (0x1000 * v92 | v92 / 0x100000) + (128 * v86 | v86 / 0x2000000) + (2 * v80 | (int32_t)(v80 < 0)); // 0x8f658960
            v1 = v88;
            v66 = v5;
            v65 = v95;
            // branch -> 0x8f658970
        }
        int32_t v96 = v65 + a2; // 0x8f658974
        uint32_t v97 = v66 - 4; // 0x8f65897c
        int32_t v98 = v1; // 0x8f6589c015
        int32_t v99; // 0x8f6589c8
        int32_t v100; // 0x8f6589d4
        int32_t v101; // 0x8f6589c8
        uint32_t v102; // 0x8f6589cc
        if (v1 <= v97) {
            int32_t v103 = v1; // 0x8f658988
            while (true) {
                char v104 = *(char *)(v103 + 1); // 0x8f658988
                int32_t v105 = v103 + 4; // 0x8f65898c
                char v106 = *(char *)v103; // 0x8f658990
                char v107 = *(char *)(v103 + 2); // 0x8f658998
                char v108 = *(char *)(v103 + 3); // 0x8f6589a0
                uint32_t v109 = v96 + -0x3d4d51c3 * (0x1000000 * (int32_t)v108 | 0x10000 * (int32_t)v107 | (int32_t)v106 | 256 * (int32_t)v104); // 0x8f6589a8150
                int32_t v110 = 0x27d4eb2f * (0x20000 * v109 | v109 / 0x8000); // 0x8f6589b0
                if (v105 > v97) {
                    v96 = v110;
                    v98 = v105;
                    // break -> 0x8f6589b8
                    break;
                }
                v96 = v110;
                v103 = v105;
                // continue -> 0x8f658988
            }
            // 0x8f6589b8
            v6 = v96;
            if (v98 < v66) {
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            v99 = v98;
            v101 = v99 + 1;
            v102 = 0x165667b1 * (int32_t)*(char *)v99 + v96;
            v100 = -0x61c8864f * (2048 * v102 | v102 / 0x200000);
            v6 = v100;
            while (v101 >= v66) {
                // 0x8f6589c8
                v99 = v101;
                v101 = v99 + 1;
                v102 = 0x165667b1 * (int32_t)*(char *)v99 + v100;
                v100 = -0x61c8864f * (2048 * v102 | v102 / 0x200000);
                v6 = v100;
                // continue -> 0x8f6589c8
            }
            // 0x8f658b4c
            v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
            v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
            if (v3 != g23) {
                // 0x8f658b78
                __stack_chk_fail();
                // branch -> 0x8f658b7c
            }
            // 0x8f658b7c
            return v8 / 0x10000 ^ v8;
        }
        // 0x8f6589b8
        if (v98 >= v66) {
            v99 = v98;
            v101 = v99 + 1;
            v102 = 0x165667b1 * (int32_t)*(char *)v99 + v96;
            v100 = -0x61c8864f * (2048 * v102 | v102 / 0x200000);
            v6 = v100;
            while (v101 >= v66) {
                // 0x8f6589c8
                v99 = v101;
                v101 = v99 + 1;
                v102 = 0x165667b1 * (int32_t)*(char *)v99 + v100;
                v100 = -0x61c8864f * (2048 * v102 | v102 / 0x200000);
                v6 = v100;
                // continue -> 0x8f6589c8
            }
            // 0x8f658b4c
            v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
            v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
            if (v3 != g23) {
                // 0x8f658b78
                __stack_chk_fail();
                // branch -> 0x8f658b7c
            }
            // 0x8f658b7c
            return v8 / 0x10000 ^ v8;
        }
        v6 = v96;
    } else {
        // 0x8f6589dc
        int32_t v111;
        uint32_t v112; // 0x8f658b3424
        if (a2 < 16) {
            v112 = v5;
            v111 = a3 + 0x165667b1;
            // branch -> 0x8f658ae0
        } else {
            // 0x8f6589e4
            v64 = -0x7a143589;
            v63 = -0x61c8864f;
            v62 = a3 + 0x61c8864f;
            int32_t v113 = a3 - 0x7a143589; // 0x8f658a5c
            int32_t v114 = a3 + 0x24234428; // 0x8f658a30
            int32_t v115 = -0x7a143589; // 0x8f658a5c
            char v116 = *(char *)(v1 + 1); // 0x8f658a08
            char v117 = *(char *)v1; // 0x8f658a10
            char v118 = *(char *)(v1 + 2); // 0x8f658a18
            char v119 = *(char *)(v1 + 3); // 0x8f658a20
            char v120 = *(char *)(v1 + 5); // 0x8f658a28
            uint32_t v121 = llvm_bswap_i32(0x1000000 * (int32_t)v119 | 0x10000 * (int32_t)v118 | (int32_t)v117 | 256 * (int32_t)v116) * v115 + v114; // 0x8f658a30
            char v122 = *(char *)(v1 + 4); // 0x8f658a34
            char v123 = *(char *)(v1 + 6); // 0x8f658a3c
            char v124 = *(char *)(v1 + 7); // 0x8f658a44
            char v125 = *(char *)(v1 + 9); // 0x8f658a50
            int32_t v126 = -0x61c8864f * (0x2000 * v121 | v121 / 0x80000); // 0x8f658a58
            uint32_t v127 = llvm_bswap_i32(0x1000000 * (int32_t)v124 | 0x10000 * (int32_t)v123 | (int32_t)v122 | 256 * (int32_t)v120) * v115 + v113; // 0x8f658a5c
            char v128 = *(char *)(v1 + 8); // 0x8f658a60
            char v129 = *(char *)(v1 + 10); // 0x8f658a68
            char v130 = *(char *)(v1 + 11); // 0x8f658a70
            char v131 = *(char *)(v1 + 13); // 0x8f658a7c
            int32_t v132 = v63 * (0x2000 * v127 | v127 / 0x80000); // 0x8f658a84
            uint32_t v133 = v2 + v64 * llvm_bswap_i32(0x1000000 * (int32_t)v130 | 0x10000 * (int32_t)v129 | (int32_t)v128 | 256 * (int32_t)v125); // 0x8f658a88
            int32_t v134 = v1 + 16; // 0x8f658a8c
            char v135 = *(char *)(v134 - 4); // 0x8f658a8c
            char v136 = *(char *)(v134 - 2); // 0x8f658a94
            char v137 = *(char *)(v134 - 1); // 0x8f658a9c
            int32_t v138 = (0x2000 * v133 | v133 / 0x80000) * v63; // 0x8f658ab0
            uint32_t v139 = v62 + llvm_bswap_i32(0x1000000 * (int32_t)v137 | 0x10000 * (int32_t)v136 | (int32_t)v135 | 256 * (int32_t)v131) * v64; // 0x8f658ab4
            int32_t v140 = (0x2000 * v139 | v139 / 0x80000) * v63; // 0x8f658abc
            // branch -> 0x8f658a08
            while (v134 <= v5 - 16) {
                // 0x8f658a08
                v115 = v64;
                v1 = v134;
                v116 = *(char *)(v1 + 1);
                v117 = *(char *)v1;
                v118 = *(char *)(v1 + 2);
                v119 = *(char *)(v1 + 3);
                v120 = *(char *)(v1 + 5);
                v121 = llvm_bswap_i32(0x1000000 * (int32_t)v119 | 0x10000 * (int32_t)v118 | (int32_t)v117 | 256 * (int32_t)v116) * v115 + v126;
                v122 = *(char *)(v1 + 4);
                v123 = *(char *)(v1 + 6);
                v124 = *(char *)(v1 + 7);
                v125 = *(char *)(v1 + 9);
                v126 = (0x2000 * v121 | v121 / 0x80000) * v63;
                v127 = llvm_bswap_i32(0x1000000 * (int32_t)v124 | 0x10000 * (int32_t)v123 | (int32_t)v122 | 256 * (int32_t)v120) * v115 + v132;
                v128 = *(char *)(v1 + 8);
                v129 = *(char *)(v1 + 10);
                v130 = *(char *)(v1 + 11);
                v131 = *(char *)(v1 + 13);
                v132 = v63 * (0x2000 * v127 | v127 / 0x80000);
                v133 = v138 + v64 * llvm_bswap_i32(0x1000000 * (int32_t)v130 | 0x10000 * (int32_t)v129 | (int32_t)v128 | 256 * (int32_t)v125);
                v134 = v1 + 16;
                v135 = *(char *)(v134 - 4);
                v136 = *(char *)(v134 - 2);
                v137 = *(char *)(v134 - 1);
                v138 = (0x2000 * v133 | v133 / 0x80000) * v63;
                v139 = v140 + llvm_bswap_i32(0x1000000 * (int32_t)v137 | 0x10000 * (int32_t)v136 | (int32_t)v135 | 256 * (int32_t)v131) * v64;
                v140 = (0x2000 * v139 | v139 / 0x80000) * v63;
                // continue -> 0x8f658a08
            }
            int32_t v141 = (0x40000 * v140 | v140 / 0x4000) + (0x1000 * v138 | v138 / 0x100000) + (128 * v132 | v132 / 0x2000000) + (2 * v126 | (int32_t)(v126 < 0)); // 0x8f658ad0
            v1 = v134;
            v112 = v5;
            v111 = v141;
            // branch -> 0x8f658ae0
        }
        int32_t v142 = v111 + a2; // 0x8f658ae4
        uint32_t v143 = v112 - 4; // 0x8f658aec
        int32_t v144 = v1; // 0x8f658b3425
        int32_t v145; // 0x8f658b38
        int32_t v146; // 0x8f658b44
        int32_t v147; // 0x8f658b38
        uint32_t v148; // 0x8f658b3c
        if (v1 <= v143) {
            int32_t v149 = v1; // 0x8f658af8
            while (true) {
                char v150 = *(char *)(v149 + 1); // 0x8f658af8
                int32_t v151 = v149 + 4; // 0x8f658afc
                char v152 = *(char *)v149; // 0x8f658b00
                char v153 = *(char *)(v149 + 2); // 0x8f658b08
                char v154 = *(char *)(v149 + 3); // 0x8f658b10
                uint32_t v155 = v142 + -0x3d4d51c3 * llvm_bswap_i32(0x1000000 * (int32_t)v154 | 0x10000 * (int32_t)v153 | (int32_t)v152 | 256 * (int32_t)v150); // 0x8f658b1c151
                int32_t v156 = 0x27d4eb2f * (0x20000 * v155 | v155 / 0x8000); // 0x8f658b24
                if (v151 > v143) {
                    v142 = v156;
                    v144 = v151;
                    // break -> 0x8f658b2c
                    break;
                }
                v142 = v156;
                v149 = v151;
                // continue -> 0x8f658af8
            }
            // 0x8f658b2c
            v6 = v142;
            if (v144 >= v112) {
                // 0x8f658b4c
                v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
                v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
                if (v3 != g23) {
                    // 0x8f658b78
                    __stack_chk_fail();
                    // branch -> 0x8f658b7c
                }
                // 0x8f658b7c
                return v8 / 0x10000 ^ v8;
            }
            v145 = v144;
            v147 = v145 + 1;
            v148 = 0x165667b1 * (int32_t)*(char *)v145 + v142;
            v146 = -0x61c8864f * (2048 * v148 | v148 / 0x200000);
            v6 = v146;
            while (v147 < v112) {
                // if_8f658b40_0_true
                v145 = v147;
                v147 = v145 + 1;
                v148 = 0x165667b1 * (int32_t)*(char *)v145 + v146;
                v146 = -0x61c8864f * (2048 * v148 | v148 / 0x200000);
                v6 = v146;
                // continue -> if_8f658b40_0_true
            }
            // 0x8f658b4c
            v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
            v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
            if (v3 != g23) {
                // 0x8f658b78
                __stack_chk_fail();
                // branch -> 0x8f658b7c
            }
            // 0x8f658b7c
            return v8 / 0x10000 ^ v8;
        }
        // 0x8f658b2c
        if (v144 < v112) {
            v145 = v144;
            v147 = v145 + 1;
            v148 = 0x165667b1 * (int32_t)*(char *)v145 + v142;
            v146 = -0x61c8864f * (2048 * v148 | v148 / 0x200000);
            v6 = v146;
            while (v147 < v112) {
                // if_8f658b40_0_true
                v145 = v147;
                v147 = v145 + 1;
                v148 = 0x165667b1 * (int32_t)*(char *)v145 + v146;
                v146 = -0x61c8864f * (2048 * v148 | v148 / 0x200000);
                v6 = v146;
                // continue -> if_8f658b40_0_true
            }
            // 0x8f658b4c
            v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
            v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
            if (v3 != g23) {
                // 0x8f658b78
                __stack_chk_fail();
                // branch -> 0x8f658b7c
            }
            // 0x8f658b7c
            return v8 / 0x10000 ^ v8;
        }
        v6 = v142;
    }
    // 0x8f658b4c
    v7 = -0x7a143589 * (v6 / 0x8000 ^ v6);
    v8 = -0x3d4d51c3 * (v7 / 0x2000 ^ v7);
    if (v3 != g23) {
        // 0x8f658b78
        __stack_chk_fail();
        // branch -> 0x8f658b7c
    }
    // 0x8f658b7c
    return v8 / 0x10000 ^ v8;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strrchr(char * s, int c);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:29:06
