//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __gnu_uldivmod_helper(uint32_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7);
int32_t bytes_to_mpint(int32_t a1, int32_t a2, int32_t a3);
int32_t clock_config_mmc(int32_t a1, int32_t a2);
int32_t clock_config_uart_dm(void);
int32_t clock_lib2_rcg_set_rate(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t clock_lib2_rcg_set_rate_mnd(int32_t * a1, int32_t a2);
int32_t fastboot_get_reason(void);
int32_t get_accessory_type(int32_t a1);
int32_t gpio_config_factory_cable(int32_t a1, int32_t a2);
int32_t handle_fboot_oem_command_unlock(int32_t a1, int32_t a2);
char * init_temp_monitoring(void);
int32_t is_charger_bq24296(int32_t a1, int32_t a2);
int32_t is_charger_smb1359(int32_t a1, int32_t a2);
int32_t is_launch_to_fastboot_log(void);
int32_t is_stick_to_fastboot_mode(int32_t a1, int32_t a2);
int32_t is_warm_reset(int32_t a1);
int32_t mcs_DER_decodeContents(int32_t a1);
int32_t mcs_DER_decodeItem(int32_t a1, int32_t a2, int32_t a3);
int32_t mcs_mp_subb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_unit_modular_inverse(int64_t a1);
int32_t mipi_mot_panel_apply_dt_cfg(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_panel_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mp_mont_prod(int32_t * a1, int32_t result, int32_t a3, int32_t a4);
int32_t msm_gpio_int_uninit(int32_t a1);
int32_t report_usbin_uv_status(int32_t a1, int32_t a2, int32_t a3);
int32_t set_accessory_type(int32_t a1);
int32_t thread_block(int32_t a1, int32_t a2);
int32_t thread_preempt(void);
int32_t write_protect_enabled_on_eng_hw(int32_t a1, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g22 = 0; // LR
int32_t g23 = 0; // R0
int32_t g24 = 0; // R1
int32_t g25 = 0; // R12
int32_t g26 = 0; // R2
int32_t g27 = 0; // R4
int32_t g28 = 0; // R5
int32_t g29 = 0; // R6
int32_t g30 = 0; // R7
int32_t g31 = 0; // R8
int32_t g1 = -0x16d2be0d; // 0x8f6039b8
int32_t g2 = -0x16d2bfed; // 0x8f627020
int32_t g3 = -0x16d2be0d; // 0x8f6385e0
int32_t g4 = -0x16d2bfc9; // 0x8f6387c0
int32_t g5 = -0x16d2bc09; // 0x8f638ab0
int32_t g6 = 0x65440030; // 0x8f69c66f
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = 4; // 0x8f6acb30
char * g9 = "\n"; // 0x8f6afe00
char * g10; // 0x8f6b5080
char * g11; // 0x8f6b509c
char * g12; // 0x8f6c02dd
char * g13; // 0x8f6c02e4
int32_t g14 = 0; // 0x8f6c02ec
char * g15; // 0x8f6c032c
char * g16; // 0x8f6e069e
char * g17; // 0x8f6e06a5
char * g18; // 0x8f6e06a7
char * g19; // 0x8f6e06a8
int32_t g20 = 0; // 0x8f7112f4
int32_t g21 = 0; // 0x8f7114ac

// ------------------------ Functions -------------------------

// Address range: 0x8f670a80 - 0x8f670d2f
int32_t mp_mont_prod(int32_t * a1, int32_t result, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // R9
    int32_t v2 = 0; // R10
    int32_t v3 = (int32_t)a1;
    int32_t v4 = 0; // 0x8f670a80
    int32_t v5 = *(int32_t *)(v3 + 16); // 0x8f670a8c
    int32_t v6 = (int32_t)*(int16_t *)(v3 + 4); // 0x8f670a98
    int32_t v7 = g20;
    int32_t v8 = v6 - 1; // 0x8f670aa4
    int32_t v9 = 2 * v8 + 3; // R1
    *(int32_t *)v5 = 0;
    int32_t v10 = 1; // 0x8f670ac864
    int32_t v11; // 0x8f670cdc629
    int32_t v12;
    int32_t v13; // LR
    int32_t v14; // 0x8f670cdc
    int32_t result2; // 0x8f670d14
    int32_t v15; // R3
    int32_t v16;
    int32_t v17; // 0x8f670b3c
    int32_t v18; // 0x8f670b44
    int32_t v19; // 0x8f670ad8
    int32_t v20; // 0x8f670adc
    int32_t v21; // 0x8f670adc
    int32_t v22; // 0x8f670cc8
    int32_t v23; // 0x8f670b6c
    int32_t v24; // 0x8f670cd0
    int32_t v25; // 0x8f670b08
    int32_t v26; // 0x8f670b28
    int32_t v27; // 0x8f670cb8
    int32_t v28; // 0x8f670cfc
    int32_t v29; // 0x8f670b1c
    int32_t v30; // 0x8f670cd0
    int32_t v31; // 0x8f670d04
    int32_t v32; // 0x8f670ca8
    uint32_t v33; // 0x8f670b14
    int32_t v34; // 0x8f670b20
    if (v10 >= v9) {
        // 0x8f670ad4
        v19 = v8;
        v20 = v5;
        v21 = v20 - 4;
        v9 = 0;
        if (v19 > 0) {
            // 0x8f670b00
            v15 = 4 * (v19 < 1 ? 4 : v6 + 0x3fffffff) + v20;
            v25 = 0;
            v11 = v21;
            // branch -> 0x8f670b00
          lab_0x8f670b00_2:
            while (true) {
                // 0x8f670b00
                v33 = *(int32_t *)(4 * v25 + a3);
                v13 = v11;
                v29 = v33 / 0x10000;
                v34 = v33 % 0x10000;
                v23 = 0;
                v17 = v34;
                v18 = v29;
                v26 = 0;
                // branch -> 0x8f670b24
                goto lab_0x8f670b24;
            }
        } else {
            // after_if_8f670af0_0
            v12 = v21;
            // branch -> 0x8f670ca0
        }
        // 0x8f670ca0
        v32 = v20 + 4 * v6;
        if (v19 >= 0) {
            v27 = -4;
            while (true) {
                // 0x8f670cb8
                *(int32_t *)result = *(int32_t *)(v32 + v27);
                v22 = 1;
                v15 = v22;
                if (v22 <= v8) {
                    goto lab_0x8f670cb8_2;
                }
                // 0x8f670cd0
                v24 = v3;
                v30 = *(int32_t *)v24;
                v14 = mp_compare(v24, result, v30, v22, v12, v6, result);
                v16 = g20;
                if (v14 == -1) {
                    // 0x8f670d18
                    if (v7 == v16) {
                        // 0x8f670d24
                        return result;
                    }
                } else {
                    // 0x8f670cf4
                    if (v7 == v16) {
                        // 0x8f670cfc
                        v28 = v3;
                        v31 = *(int32_t *)v28;
                        result2 = mp_subb(v28, result, v31, 0, g27, g28, g29, g30, g31, v1, v2, v4);
                        return result2;
                    }
                }
                // 0x8f670d20
                __stack_chk_fail();
                // branch -> 0x8f670d24
                // 0x8f670d24
                return result;
            }
        }
        // 0x8f670cd0
        v24 = v3;
        v30 = *(int32_t *)v24;
        v14 = mp_compare(v24, result, v30, 0, v12, v6, result);
        v16 = g20;
        if (v14 == -1) {
            // 0x8f670d18
            if (v7 == v16) {
                // 0x8f670d24
                return result;
            }
        } else {
            // 0x8f670cf4
            if (v7 == v16) {
                // 0x8f670cfc
                v28 = v3;
                v31 = *(int32_t *)v28;
                result2 = mp_subb(v28, result, v31, 0, g27, g28, g29, g30, g31, v1, v2, v4);
                return result2;
            }
        }
        // 0x8f670d20
        __stack_chk_fail();
        // branch -> 0x8f670d24
        // 0x8f670d24
        return result;
    }
    *(int32_t *)(4 * v10 + v5) = 0;
    int32_t v35 = v10 + 1; // 0x8f670ac8
    while (v35 < v9) {
        // 0x8f670ac4
        *(int32_t *)(4 * v35 + v5) = 0;
        v35++;
        // continue -> 0x8f670ac4
    }
    // 0x8f670ad4
    v19 = v8;
    v20 = v5;
    v21 = v20 - 4;
    v9 = 0;
    if (v19 > 0) {
        // 0x8f670b00
        v15 = 4 * (v19 < 1 ? 4 : v6 + 0x3fffffff) + v20;
        v25 = 0;
        v11 = v21;
        // branch -> 0x8f670b00
        while (true) {
            // 0x8f670b00
            v33 = *(int32_t *)(4 * v25 + a3);
            v13 = v11;
            v29 = v33 / 0x10000;
            v34 = v33 % 0x10000;
            v23 = 0;
            v17 = v34;
            v18 = v29;
            v26 = 0;
            // branch -> 0x8f670b24
          lab_0x8f670b24:
            while (true) {
                uint32_t v36 = *(int32_t *)(4 * v26 + a4); // 0x8f670b28
                int32_t v37 = v26 + 1; // 0x8f670b2c
                int32_t v38 = v37; // R12
                uint32_t v39 = v36 % 0x10000; // 0x8f670b30
                uint32_t v40 = v36 / 0x10000; // 0x8f670b34
                int32_t v41 = v40 * v18; // 0x8f670b38
                uint32_t v42 = v40 * v17; // 0x8f670b3c
                uint32_t v43 = v39 * v18 + v42; // 0x8f670b44
                int32_t v44 = v41; // 0x8f670b50
                if (v43 < v42) {
                    // if_8f670b4c_0_true
                    v44 = v41 + 0x10000;
                    // branch -> after_if_8f670b4c_0
                }
                int32_t v45 = v44 + v43 / 0x10000; // R6
                int32_t v46 = v13 + 4; // 0x8f670b5c
                int32_t * v47 = (int32_t *)v46; // 0x8f670b5c_0
                v13 = v46;
                *v47 = 0x10000 * v43 + v39 * v17 + v23 + *v47;
                if (v37 < v8) {
                    // if_8f670b7c_0_true
                    v23 = v45;
                    v17 = v34;
                    v18 = v29;
                    v26 = v38;
                    // branch -> 0x8f670b24
                    continue;
                } else {
                    int32_t v48 = 4 * v25; // 0x8f670b08
                    int32_t * v49 = (int32_t *)v15; // 0x8f670b84_0
                    int32_t v50 = v45 + *v49; // 0x8f670b88
                    *v49 = v50;
                    int32_t v51; // 0x8f670c04
                    int32_t v52; // 0x8f670c0c
                    int32_t v53; // 0x8f670bc4
                    int32_t v54; // 0x8f670c34
                    uint32_t v55; // 0x8f670bd8
                    int32_t v56; // 0x8f670bf0
                    int32_t v57; // 0x8f670be4
                    int32_t v58; // 0x8f670be8
                    if (v50 < v45) {
                        // if_8f670b94_0_true
                        // branch -> 0x8f670bc0
                    } else {
                        int32_t v59 = v50 + 4; // 0x8f670b9c13
                        int32_t v60 = *(int32_t *)v59; // 0x8f670b9c15
                        v38 = v59;
                        int32_t v61 = v60; // 0x8f670bb8
                        if (v60 == -1) {
                            *(int32_t *)(v50 + 4) = 0;
                            int32_t v62 = v38; // 0x8f670bb0
                            int32_t v63 = v62 + 4; // 0x8f670b9c
                            int32_t v64 = *(int32_t *)v63; // 0x8f670b9c
                            while (v64 == -1) {
                                // if_8f670ba8_0_true
                                *(int32_t *)(v62 + 4) = 0;
                                v62 = v63;
                                v63 = v62 + 4;
                                v64 = *(int32_t *)v63;
                                // continue -> if_8f670ba8_0_true
                            }
                            // 0x8f670bb8
                            *(int32_t *)v63 = v64 + 1;
                            // branch -> 0x8f670bc0
                          lab_0x8f670bc0:
                            // 0x8f670bc0
                            v53 = v3;
                            v13 = v11;
                            v55 = *(int32_t *)(v5 + v48) * *(int32_t *)(v53 + 24);
                            v57 = v55 / 0x10000;
                            v58 = v55 % 0x10000;
                            v54 = 0;
                            v51 = v58;
                            v52 = v57;
                            v56 = 0;
                            // branch -> 0x8f670bec
                          lab_0x8f670bec:;
                            int32_t v65; // 0x8f670c94
                            int32_t v66; // 0x8f670af8
                            while (true) {
                                uint32_t v67 = *(int32_t *)(4 * v56 + *(int32_t *)v53); // 0x8f670bf0
                                int32_t v68 = v56 + 1; // 0x8f670bf4
                                v38 = v68;
                                uint32_t v69 = v67 % 0x10000; // 0x8f670bf8
                                uint32_t v70 = v67 / 0x10000; // 0x8f670bfc
                                int32_t v71 = v70 * v52; // 0x8f670c00
                                uint32_t v72 = v70 * v51; // 0x8f670c04
                                uint32_t v73 = v69 * v52 + v72; // 0x8f670c0c
                                int32_t v74 = v71; // 0x8f670c18
                                if (v73 < v72) {
                                    // if_8f670c14_0_true
                                    v74 = v71 + 0x10000;
                                    // branch -> after_if_8f670c14_0
                                }
                                // after_if_8f670c14_0
                                v45 = v74 + v73 / 0x10000;
                                int32_t v75 = v13 + 4; // 0x8f670c24
                                int32_t * v76 = (int32_t *)v75; // 0x8f670c24_0
                                v13 = v75;
                                *v76 = 0x10000 * v73 + v69 * v51 + v54 + *v76;
                                if (v68 < v8) {
                                    // if_8f670c44_0_true
                                    v54 = v45;
                                    v51 = v58;
                                    v52 = v57;
                                    v56 = v38;
                                    // branch -> 0x8f670bec
                                    continue;
                                } else {
                                    int32_t * v77 = (int32_t *)v15; // 0x8f670c4c_0
                                    int32_t v78 = v45 + *v77; // 0x8f670c50
                                    *v77 = v78;
                                    int32_t v79; // 0x8f670c8c
                                    if (v78 < v45) {
                                        // if_8f670c5c_0_true
                                        // branch -> 0x8f670c88
                                    } else {
                                        int32_t v80 = v78 + 4; // 0x8f670c6419
                                        int32_t v81 = *(int32_t *)v80; // 0x8f670c6421
                                        v38 = v80;
                                        int32_t v82 = v81; // 0x8f670c80
                                        int32_t v83;
                                        if (v81 == -1) {
                                            *(int32_t *)(v78 + 4) = 0;
                                            int32_t v84 = v38; // 0x8f670c78
                                            int32_t v85 = v84 + 4; // 0x8f670c64
                                            int32_t v86 = *(int32_t *)v85; // 0x8f670c64
                                            while (v86 == -1) {
                                                // if_8f670c70_0_true
                                                *(int32_t *)(v84 + 4) = 0;
                                                v84 = v85;
                                                v85 = v84 + 4;
                                                v86 = *(int32_t *)v85;
                                                // continue -> if_8f670c70_0_true
                                            }
                                            // 0x8f670c80
                                            *(int32_t *)v85 = v86 + 1;
                                            // branch -> 0x8f670c88
                                          lab_0x8f670c88:
                                            // 0x8f670c88
                                            v79 = v9 + 1;
                                            v9 = v79;
                                            v15 = v83 + 4;
                                            v65 = v11 + 4;
                                            v66 = v8;
                                            if (v79 >= v66) {
                                                // break (via goto) -> 0x8f670af8
                                                goto lab_0x8f670af8_2;
                                            }
                                            v25 = v79;
                                            v11 = v65;
                                            // continue (via goto) -> 0x8f670b00
                                            goto lab_0x8f670b00_2;
                                        }
                                        // 0x8f670c80
                                        *(int32_t *)v80 = v82 + 1;
                                        v83 = v15;
                                        // branch -> 0x8f670c88
                                        goto lab_0x8f670c88;
                                    }
                                    // 0x8f670c88
                                    v79 = v9 + 1;
                                    v9 = v79;
                                    v15 += 4;
                                    v65 = v11 + 4;
                                    v66 = v8;
                                    if (v79 >= v66) {
                                        // break (via goto) -> 0x8f670af8
                                        goto lab_0x8f670af8_2;
                                    }
                                    v25 = v79;
                                    v11 = v65;
                                    // continue (via goto) -> 0x8f670b00
                                    goto lab_0x8f670b00_2;
                                }
                            }
                          lab_0x8f670af8_2:
                            // 0x8f670af8
                            v12 = v65;
                            // branch -> 0x8f670ca0
                            // 0x8f670ca0
                            v15 = 0;
                            v32 = v5 + 4 * v6;
                            int32_t v87 = 0; // 0x8f670cdc
                            if (v66 >= 0) {
                                int32_t v88 = 0; // 0x8f670cc4
                                v27 = -4;
                                while (true) {
                                    // 0x8f670cb8
                                    *(int32_t *)(4 * v88 + result) = *(int32_t *)(v32 + v27);
                                    v22 = v15 + 1;
                                    v15 = v22;
                                    if (v22 <= v8) {
                                      lab_0x8f670cb8_2:
                                        // 0x8f670cb8
                                        v88 = v22;
                                        v27 += 4;
                                        // branch -> 0x8f670cb8
                                        continue;
                                    } else {
                                        v87 = v22;
                                    }
                                }
                            }
                            // 0x8f670cd0
                            v24 = v3;
                            v30 = *(int32_t *)v24;
                            v14 = mp_compare(v24, result, v30, v87, v12, v6, result);
                            v16 = g20;
                            if (v14 == -1) {
                                // 0x8f670d18
                                if (v7 == v16) {
                                    // 0x8f670d24
                                    return result;
                                }
                            } else {
                                // 0x8f670cf4
                                if (v7 == v16) {
                                    // 0x8f670cfc
                                    v28 = v3;
                                    v31 = *(int32_t *)v28;
                                    result2 = mp_subb(v28, result, v31, 0, g27, g28, g29, g30, g31, v1, v2, v4);
                                    return result2;
                                }
                            }
                            // 0x8f670d20
                            __stack_chk_fail();
                            // branch -> 0x8f670d24
                            // 0x8f670d24
                            return result;
                        }
                        // 0x8f670bb8
                        *(int32_t *)v59 = v61 + 1;
                        // branch -> 0x8f670bc0
                        goto lab_0x8f670bc0;
                    }
                    // 0x8f670bc0
                    v53 = v3;
                    v13 = v11;
                    v55 = *(int32_t *)(v5 + v48) * *(int32_t *)(v53 + 24);
                    v57 = v55 / 0x10000;
                    v58 = v55 % 0x10000;
                    v54 = 0;
                    v51 = v58;
                    v52 = v57;
                    v56 = 0;
                    // branch -> 0x8f670bec
                    goto lab_0x8f670bec;
                }
            }
        }
    } else {
        // after_if_8f670af0_0
        v12 = v21;
        // branch -> 0x8f670ca0
    }
    // 0x8f670ca0
    v32 = v20 + 4 * v6;
    if (v19 >= 0) {
        v27 = -4;
        while (true) {
            // 0x8f670cb8
            *(int32_t *)result = *(int32_t *)(v32 + v27);
            v22 = 1;
            v15 = v22;
            if (v22 <= v8) {
                goto lab_0x8f670cb8_2;
            }
            // 0x8f670cd0
            v24 = v3;
            v30 = *(int32_t *)v24;
            v14 = mp_compare(v24, result, v30, v22, v12, v6, result);
            v16 = g20;
            if (v14 == -1) {
                // 0x8f670d18
                if (v7 == v16) {
                    // 0x8f670d24
                    return result;
                }
            } else {
                // 0x8f670cf4
                if (v7 == v16) {
                    // 0x8f670cfc
                    v28 = v3;
                    v31 = *(int32_t *)v28;
                    result2 = mp_subb(v28, result, v31, 0, g27, g28, g29, g30, g31, v1, v2, v4);
                    return result2;
                }
            }
            // 0x8f670d20
            __stack_chk_fail();
            // branch -> 0x8f670d24
            // 0x8f670d24
            return result;
        }
    }
    // 0x8f670cd0
    v24 = v3;
    v30 = *(int32_t *)v24;
    v14 = mp_compare(v24, result, v30, 0, v12, v6, result);
    v16 = g20;
    if (v14 == -1) {
        // 0x8f670d18
        if (v7 == v16) {
            // 0x8f670d24
            return result;
        }
    } else {
        // 0x8f670cf4
        if (v7 == v16) {
            // 0x8f670cfc
            v28 = v3;
            v31 = *(int32_t *)v28;
            result2 = mp_subb(v28, result, v31, 0, g27, g28, g29, g30, g31, v1, v2, v4);
            return result2;
        }
    }
    // 0x8f670d20
    __stack_chk_fail();
    // branch -> 0x8f670d24
    // 0x8f670d24
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// size_t strlen(const char * s);
// size_t strnlen(const char * string, size_t maxlen);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:23:15
