//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t clock_ce_disable(int32_t a1);
int32_t clock_ce_enable(int32_t a1);
int32_t enable_smb1359_stat_gpio_irq(int32_t a1, int32_t a2, int32_t a3);
int32_t fastboot_get_reason(void);
int32_t fastboot_set_reason(char * a1, int32_t a2, int32_t a3);
int32_t fdt_add_subnode_namelen(int32_t a1, int32_t a2, char * a3, int32_t a4);
int32_t fdt_delprop(int32_t a1, int32_t a2, int32_t a3);
int32_t free_sparse_image(int32_t a1, int32_t a2, int32_t a3);
void function_8f64b57c(void);
void function_8f64b5d8(char * a1, int32_t a2);
int32_t get_brightness(int32_t a1, int32_t a2, int32_t a3);
int32_t get_entry_index_by_name(char * str, int32_t a2, int32_t a3);
char * init_temp_monitoring(void);
int32_t is_launch_to_fastboot_log(void);
void kmain(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mcs_clear_rsa_ctx(char * a1, int32_t a2, int32_t a3);
int32_t mcs_rsa_sig(char * a1, int32_t a2, int16_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7);
int32_t mmc_sdhci_get_wp_status(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mmc_wp(void);
int32_t mutex_init(int32_t * a1, int32_t a2, int32_t a3);
int32_t set_backlight_dev(int32_t a1, int32_t a2, int32_t a3);
int32_t set_launch_to_fastboot_log(char a1, int32_t a2, int32_t a3);
int32_t smb1359_stat_gpio_config(void);
int32_t speedo_log(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t speedo_read(int32_t a1, int32_t a2, int32_t a3);
int32_t target_get_max_flash_size(int32_t a1, int32_t a2, int32_t a3);
int32_t target_get_scratch_address(int32_t a1);
int32_t thread_exit(int32_t a1, int32_t a2, int32_t a3);
int32_t thread_yield(int32_t a1, int32_t a2);
int32_t validate_powerup_reason(char * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R2
int32_t g23 = 0; // R3
int32_t g24 = 0; // R4
int32_t g25 = 0; // R5
int32_t g26 = 0; // R6
int32_t g27 = 0; // R7
int32_t g28 = 0; // R8
int32_t g1 = -0x1a60cfc8; // 0x8f602dd0
int32_t g2 = -0x16d2be0d; // 0x8f6039b8
int32_t g3 = -0x16d2bfed; // 0x8f61adc8
int32_t g4 = -0x1a60df68; // 0x8f61b3e8
int32_t g5 = 0x65440030; // 0x8f69c66f
int32_t g6 = 0x1f3f7fff; // 0x8f6a6a14
int32_t g7 = 1; // 0x8f6ac0f0
int32_t g8 = 255; // 0x8f6aca80
char * g9; // 0x8f6b5080
char * g10; // 0x8f6b509c
char * g11; // 0x8f6b7d40
char g12 = 0; // 0x8f6b7d41
int32_t g13 = 0; // 0x8f6c02ec
char * g14; // 0x8f6c032c
int32_t g15 = 0; // 0x8f6e0a88
int32_t g16 = 0; // 0x8f710c70
int32_t g17 = 0; // 0x8f7112f4
int32_t g18 = 0; // 0x8f7114ac

// ------------------------ Functions -------------------------

// Address range: 0x8f64d154 - 0x8f64d2b3
int32_t fdt_add_subnode_namelen(int32_t a1, int32_t a2, char * a3, int32_t a4) {
    // 0x8f64d154
    int32_t v1;
    int32_t v2 = v1; // bp-48
    g20 = a1;
    int32_t v3 = (int32_t)a3;
    int32_t v4 = g27; // 0x8f64d154
    int32_t v5 = a1; // R4
    g27 = a2;
    int32_t v6 = g17;
    int32_t v7;
    int32_t v8;
    int32_t v9 = _fdt_rw_check_header(a1, a2, v3, v6, v8, v7, v1); // 0x8f64d178
    g20 = v9;
    int32_t v10 = v9; // R6
    int32_t v11; // 0x8f64d1b4_0
    int32_t v12; // 0x8f64d1ec
    int32_t v13; // 0x8f64d210
    int32_t v14; // 0x8f64d230
    int32_t v15; // 0x8f64d248
    int32_t v16; // 0x8f64d27c
    int32_t v17; // R1
    int32_t v18; // R5
    int32_t result; // 0x8f64d2ac_2
    int32_t v19; // bp+210
    int32_t v20; // 0x8f64d1f0
    int32_t v21; // 0x8f64d21c
    int32_t v22; // 0x8f64d25c
    int32_t v23; // 0x8f64d214
    int32_t v24; // 0x8f64d224
    int32_t v25; // 0x8f64d24c
    int32_t v26; // 0x8f64d268
    int32_t v27; // 0x8f64d26c
    int32_t v28; // 0x8f64d270
    int32_t v29; // 0x8f64d290
    int32_t v30; // 0x8f64d208
    int32_t v31; // 0x8f64d220
    int32_t v32; // 0x8f64d228
    if (v9 != 0) {
        // if_8f64d180_0_true
        g20 = v9;
        // branch -> 0x8f64d294
        // 0x8f64d294
        if (v6 != g17) {
            // 0x8f64d2a4
            __stack_chk_fail();
            result = g20;
            // branch -> 0x8f64d2a8
        } else {
            result = v9;
        }
        // 0x8f64d2a8
        g27 = v4;
        return result;
      lab_0x8f64d200:
        // 0x8f64d200
        if (v12 == 2) {
            goto lab_0x8f64d1d0;
        }
        // 0x8f64d208
        v30 = *(int32_t *)(v5 + 8);
        g20 = v30;
        v13 = fdt32_to_cpu_101(v30, v17, v11, v20, v8, v7, v2, v6, 0, g24);
        v23 = a4 + 4 & -4;
        v21 = v23 + 8;
        v31 = v18 + v13;
        v24 = v5;
        g20 = v24;
        v32 = v24 + v31;
        g27 = v32;
        v14 = _fdt_splice_struct(v24, v32, 0, v21, v8, v7, v2, v6, 0, g24, g25, g26, v4);
        g20 = v14;
        if (v14 == 0) {
            // 0x8f64d240
            g20 = 1;
            v15 = fdt32_to_cpu_101(1, 0, 0, v21, v8, 0, v2, v6, 0, g24);
            v25 = v23;
            *(int32_t *)(v31 + v5) = v15;
            v22 = g27 + 4;
            g20 = v22;
            memset((char *)v22, 0, v25);
            v26 = v3;
            v27 = a4;
            v28 = v22;
            g20 = v28;
            memcpy((char *)v28, (char *)v26, v27);
            g20 = 2;
            v16 = fdt32_to_cpu_101(2, v26, v27, v21, v8, 0, v2, v6, 0, g24);
            g20 = v16;
            *(int32_t *)(g27 + v25 + 4) = v16;
            v29 = v18;
            // branch -> 0x8f64d290
            // 0x8f64d290
            g20 = v29;
            v19 = v29;
            // branch -> 0x8f64d294
        } else {
            // if_8f64d238_0_true
            g20 = v14;
            v19 = v14;
            // branch -> 0x8f64d294
        }
        // 0x8f64d294
        if (v6 != g17) {
            // 0x8f64d2a4
            __stack_chk_fail();
            result = g20;
            // branch -> 0x8f64d2a8
        } else {
            result = v19;
        }
        // 0x8f64d2a8
        g27 = v4;
        return result;
    }
    // 0x8f64d188
    g20 = v5;
    int32_t v33 = a4; // R3
    int32_t v34 = fdt_subnode_offset_namelen(v5, g27, v3, a4, v8, v7, v1, v6, 0, g24, g25, g26, v4, g28, 0, 0); // 0x8f64d198
    g20 = v34;
    v18 = v34;
    if (v34 > -1) {
        // 0x8f64d288
        g20 = -2;
        // branch -> 0x8f64d294
    } else {
        // 0x8f64d1a4
        if (v34 != -1) {
            v29 = v34;
            // 0x8f64d290
            g20 = v29;
            // branch -> 0x8f64d294
            // 0x8f64d294
            if (v6 != g17) {
                // 0x8f64d2a4
                __stack_chk_fail();
                result = g20;
                // branch -> 0x8f64d2a8
            } else {
                result = v29;
            }
            // 0x8f64d2a8
            g27 = v4;
            return result;
        }
        // 0x8f64d1ac
        g20 = v5;
        int32_t v35 = g27; // 0x8f64d1b0
        v17 = v35;
        v11 = &v2;
        int32_t v36 = fdt_next_tag(v5, v35, v11, v33, v8, v7, v1, v6, 0, g24, g25, g26, v4); // 0x8f64d1b8
        g20 = v36;
        // branch -> 0x8f64d1bc
      lab_0x8f64d1bc:
        while (true) {
            // 0x8f64d1bc
            int32_t v37; // 0x8f64d1d4
            switch (v36) {
                default: {
                    // 0x8f64d1d4
                    v37 = v10;
                    // branch -> 0x8f64d1d4
                    break;
                }
                case 1: {
                    int32_t v38 = v10 + 1; // 0x8f64d1c0
                    v10 = v38;
                    v37 = v38;
                    // branch -> 0x8f64d1d4
                    break;
                }
                case 2: {
                  lab_0x8f64d1d0:;
                    int32_t v39 = v10 - 1; // 0x8f64d1d0
                    v10 = v39;
                    v37 = v39;
                    // branch -> 0x8f64d1d4
                    break;
                }
            }
            // 0x8f64d1d4
            if (v37 == 0) {
                // 0x8f64d1d4
                // branch -> 0x8f64d208
            } else {
                int32_t v40 = v2; // 0x8f64d1dc
                v18 = v40;
                g20 = v5;
                v17 = v40;
                v12 = fdt_next_tag(v5, v40, v11, v33, v8, v7, v40, v6, 0, g24, g25, g26, v4);
                g20 = v12;
                v20 = v12 - 3;
                v33 = v20;
                if (v12 != 1) {
                    // break (via goto) -> after_if_8f64d1f8_0
                    goto lab_after_if_8f64d1f8_0;
                }
                v36 = 1;
                // continue -> 0x8f64d1bc
                continue;
            }
            // 0x8f64d208
            v30 = *(int32_t *)(v5 + 8);
            g20 = v30;
            v13 = fdt32_to_cpu_101(v30, v17, v11, v33, v8, v7, v2, v6, 0, g24);
            v23 = a4 + 4 & -4;
            v21 = v23 + 8;
            v31 = v18 + v13;
            v24 = v5;
            g20 = v24;
            v32 = v24 + v31;
            g27 = v32;
            v14 = _fdt_splice_struct(v24, v32, 0, v21, v8, v7, v2, v6, 0, g24, g25, g26, v4);
            g20 = v14;
            if (v14 == 0) {
                // 0x8f64d240
                g20 = 1;
                v15 = fdt32_to_cpu_101(1, 0, 0, v21, v8, 0, v2, v6, 0, g24);
                v25 = v23;
                *(int32_t *)(v31 + v5) = v15;
                v22 = g27 + 4;
                g20 = v22;
                memset((char *)v22, 0, v25);
                v26 = v3;
                v27 = a4;
                v28 = v22;
                g20 = v28;
                memcpy((char *)v28, (char *)v26, v27);
                g20 = 2;
                v16 = fdt32_to_cpu_101(2, v26, v27, v21, v8, 0, v2, v6, 0, g24);
                g20 = v16;
                *(int32_t *)(g27 + v25 + 4) = v16;
                v29 = v18;
                // branch -> 0x8f64d290
                // 0x8f64d290
                g20 = v29;
                v19 = v29;
                // branch -> 0x8f64d294
            } else {
                // if_8f64d238_0_true
                g20 = v14;
                v19 = v14;
                // branch -> 0x8f64d294
            }
            // 0x8f64d294
            if (v6 != g17) {
                // 0x8f64d2a4
                __stack_chk_fail();
                result = g20;
                // branch -> 0x8f64d2a8
            } else {
                result = v19;
            }
            // 0x8f64d2a8
            g27 = v4;
            return result;
        }
      lab_after_if_8f64d1f8_0:
        // after_if_8f64d1f8_0
        if (v20 >= 2) {
            // break (via goto) -> 0x8f64d200
            goto lab_0x8f64d200;
        }
        v36 = v12;
        // continue (via goto) -> 0x8f64d1bc
        goto lab_0x8f64d1bc;
    }
    // 0x8f64d294
    if (v6 != g17) {
        // 0x8f64d2a4
        __stack_chk_fail();
        result = g20;
        // branch -> 0x8f64d2a8
    } else {
        result = -2;
    }
    // 0x8f64d2a8
    g27 = v4;
    return result;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:17:03
