//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------- Function Prototypes --------------------

int32_t _fdt_check_node_offset(int32_t a1, int32_t a2);
int32_t _fdt_check_prop_offset(int32_t a1);
int32_t add_panel_to_manager(int32_t * a1, int32_t a2, int32_t a3);
int32_t arch_disable_mmu(int32_t a1, int32_t a2, int32_t a3);
int32_t arm_mmu_init(int32_t a1);
int32_t board_machtype(int32_t a1, int32_t a2, int32_t a3);
int32_t display_draw_screen_line(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t display_draw_screen_line_alignment(int32_t a1);
int32_t factory_mode(int32_t a1, int32_t a2, int32_t a3);
void function_8f67b680(void);
int32_t is_factory_mode(void);
int32_t is_validation_enabled(char * a1, int32_t a2);
int32_t load_and_validate_logo(void);
int32_t load_and_validate_oem_image(void);
int32_t mipi_mot_panel_off(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_mot_panel_on(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_enable_enhanced_erase(void);
int32_t mmc_sdhci_enable_enhanced_erase(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_sdhci_get_wp_group_size(void);
void mmc_set_power_on_wp_user(char * a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data(char * a1, char * a2);
int32_t mot_sst_oem_unlock_handler(void);
int32_t panel_manager_init(int32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_config_s3_source(uint32_t a1, int32_t a2, int32_t a3);
int32_t pm8x41_resin_status(int32_t a1, int32_t a2);
int32_t target_serialno(char * a1, int32_t a2);
int32_t validate_partition(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t wait_queue_block(int32_t a1, int32_t a2);
int32_t wait_queue_init(int32_t * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R10
int32_t g23 = 0; // R11
int32_t g24 = 0; // R2
int32_t g25 = 0; // R3
int32_t g26 = 0; // R4
int32_t g27 = 0; // R5
int32_t g28 = 0; // R6
int32_t g29 = 0; // R7
int32_t g30 = 0; // R8
int32_t g31 = 0; // R9
int32_t g1 = -0x16d2bfed; // 0x8f61bf74
char * g2 = "\xff\xff\xff\xff\x6c\x6f\x61\x64\x5f\x61\x6e\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x65\x5f\x6b\x65\x72\x6e\x65\x6c\x5f\x69\x6d\x61\x67\x65"; // 0x8f6826be
char * g3 = "\n"; // 0x8f6ac1b0
int32_t g4 = 4; // 0x8f6acacc
int32_t g5 = 4; // 0x8f6acb18
int32_t g6 = 4; // 0x8f6acb30
int32_t g7 = -1; // 0x8f6affb0
int32_t g8 = 102; // 0x8f6affdc
int32_t g9 = 1; // 0x8f6b0044
char * g10; // 0x8f6b0070
int32_t g11 = 0; // 0x8f6bc000
char * g12; // 0x8f6e06ae
int32_t g13 = 0; // 0x8f6e06b4
int32_t g14 = 0; // 0x8f6e0c38
int32_t g15 = 0; // 0x8f7112f4
int32_t g16 = 0; // 0x8f7114ac
int32_t g17 = 0; // 0x8f711550
int32_t g18 = 0; // 0x8f711554

// ------------------------ Functions -------------------------

// Address range: 0x8f67b680 - 0x8f67bf1b
void function_8f67b680(void) {
    int32_t v1 = g26; // 0x8f67b684
    int32_t v2 = g31; // 0x8f67b684
    uint32_t v3 = g21; // 0x8f67b7dc
    int32_t v4 = g20; // 0x8f67b808
    int32_t v5 = 0; // 0x8f67b6c8
    if (g21 <= 0xffffffff) {
        // 0x8f67b6a4
        v3 = -((g21 + (int32_t)(g20 != 0)));
        v4 = -g20;
        v5 = -1;
        // branch -> 0x8f67b6b8
    }
    // 0x8f67b6b8
    g26 = v5;
    int32_t v6 = v5; // 0x8f67baf8
    int32_t v7 = g24; // 0x8f67b700
    uint32_t v8 = g25; // 0x8f67b7c8
    if (g25 <= 0xffffffff) {
        int32_t v9 = -1 - v5; // 0x8f67b6c8
        g26 = v9;
        v6 = v9;
        v7 = -g24;
        v8 = -((g25 + (int32_t)(g24 != 0)));
        // branch -> 0x8f67b6d4
    }
    // 0x8f67b6d4
    g31 = v4;
    if (v8 != 0) {
        // 0x8f67b98c
        if (v8 >= v3 && v8 != v3) {
            // 0x8f67baf4
            // branch -> 0x8f67baf8
            // 0x8f67baf8
            if (v6 != 0) {
                // 0x8f67bb08
                // branch -> 0x8f67bb10
            }
            // 0x8f67bb10
            g26 = v1;
            g31 = v2;
            return;
        }
        uint32_t v10 = llvm_ctlz_i32(v8, false); // 0x8f67b994
        g31 = v10;
        if (v10 == 0) {
            // 0x8f67b9a0
            if (v8 == v3 || v3 < v8) {
                // after_if_8f67b9a4_0
                if (v4 < v7) {
                    // 0x8f67baf4
                    // branch -> 0x8f67baf8
                    // 0x8f67baf8
                    if (v6 != 0) {
                        // 0x8f67bb08
                        // branch -> 0x8f67bb10
                    }
                    // 0x8f67bb10
                    g26 = v1;
                    g31 = v2;
                    return;
                }
            } else {
                // after_if_8f67b9a4_0thread-pre-split
                if (v3 < v8) {
                    // 0x8f67baf4
                    // branch -> 0x8f67baf8
                    // 0x8f67baf8
                    if (v6 != 0) {
                        // 0x8f67bb08
                        // branch -> 0x8f67bb10
                    }
                    // 0x8f67bb10
                    g26 = v1;
                    g31 = v2;
                    return;
                }
            }
            // after_if_8f67b9b4_0
            // branch -> 0x8f67baf8
            // 0x8f67baf8
            if (v6 != 0) {
                // 0x8f67bb08
                // branch -> 0x8f67bb10
            }
            // 0x8f67bb10
            g26 = v1;
            g31 = v2;
            return;
        }
        uint32_t v11 = (32 - v10) % 256; // 0x8f67b9c4
        uint32_t v12 = v11 > 32 ? 32 : v11; // 0x8f67b9c4
        uint32_t v13 = v7 >> v12 | (v10 < 32 ? v8 << v10 : 0); // 0x8f67b9c8
        uint32_t v14 = v3 >> v12; // 0x8f67b9cc
        uint32_t v15 = v13 / 0x10000; // 0x8f67b9d0
        uint32_t v16 = v4 >> v12 | (v10 < 32 ? v3 << v10 : 0); // 0x8f67b9e0
        uint32_t v17 = v10 < 32 ? v7 << v10 : 0; // 0x8f67b9e4
        int32_t v18 = v14 / v15;
        uint32_t v19 = v13 % 0x10000; // 0x8f67b9f4
        uint32_t v20 = v18 * v19; // 0x8f67ba00
        int32_t v21 = 0x10000 * (v14 % v15) | v16 / 0x10000; // 0x8f67ba24
        int32_t v22; // 0x8f67ba4c
        int32_t v23; // 0x8f67bab4
        if (v21 < v20) {
            // if_8f67ba2c_0_true
            v23 = v18;
            v22 = v21;
            // branch -> 0x8f67ba4c
        } else {
            int32_t v24 = v21 + v13; // 0x8f67ba34
            if (v24 < v20) {
                // if_8f67ba44_0_true
                v23 = v18 - 2;
                v22 = v24 + v13;
                // branch -> 0x8f67ba4c
            } else {
                v23 = v18 - 1;
                v22 = v24;
            }
        }
        uint32_t v25 = v22 - v20; // 0x8f67ba4c
        int32_t v26 = v25 / v15;
        uint32_t v27 = v26 * v19; // 0x8f67ba78
        int32_t v28 = 0x10000 * (v25 % v15) | v16 % 0x10000; // 0x8f67ba8c
        int32_t v29; // 0x8f67babc
        int32_t v30; // 0x8f67bab4
        if (v28 < v27) {
            // if_8f67ba94_0_true
            v29 = v28;
            v30 = v26;
            // branch -> 0x8f67bab4
        } else {
            int32_t v31 = v28 + v13; // 0x8f67ba9c
            if (v31 < v27) {
                // if_8f67baac_0_true
                v29 = v31 + v13;
                v30 = v26 - 2;
                // branch -> 0x8f67bab4
            } else {
                v29 = v31;
                v30 = v26 - 1;
            }
        }
        uint64_t v32 = (int64_t)(v30 | 0x10000 * v23) * (int64_t)v17; // 0x8f67bab8
        uint32_t v33 = (int32_t)(v32 / 0x100000000); // 0x8f67bab8
        uint32_t v34 = v29 - v27; // 0x8f67babc
        if (v33 > v34) {
            // 0x8f67bae4
            // branch -> 0x8f67bae8
            // 0x8f67bae8
            // branch -> 0x8f67baf8
            // 0x8f67baf8
            if (v6 != 0) {
                // 0x8f67bb08
                // branch -> 0x8f67bb10
            }
            // 0x8f67bb10
            g26 = v1;
            g31 = v2;
            return;
        }
        // 0x8f67bac8
        if ((int32_t)v32 > (v10 < 32 ? v4 << v10 : 0)) {
            // after_if_8f67bad8_0
            if (v33 == v34) {
                // 0x8f67bae4
                // branch -> 0x8f67bae8
                // 0x8f67bae8
                // branch -> 0x8f67baf8
            }
        }
        // 0x8f67baf8
        if (v6 != 0) {
            // 0x8f67bb08
            // branch -> 0x8f67bb10
        }
        // 0x8f67bb10
        g26 = v1;
        g31 = v2;
        return;
    }
    // 0x8f67b6e8
    if (v7 > v3) {
        uint32_t v35 = llvm_ctlz_i32(v7, false); // 0x8f67b6f0
        uint32_t v36 = v4; // 0x8f67b778
        uint32_t v37 = v3; // 0x8f67b730
        uint32_t v38 = v7; // 0x8f67b7a0
        if (v35 != 0) {
            uint32_t v39 = (32 - v35) % 256; // 0x8f67b6fc
            int32_t v40 = v35 < 32 ? v3 << v35 : 0; // 0x8f67b704
            int32_t v41 = v35 < 32 ? v4 << v35 : 0; // 0x8f67b708
            g31 = v41;
            v36 = v41;
            v37 = v4 >> (v39 > 32 ? 32 : v39) | v40;
            v38 = v35 < 32 ? v7 << v35 : 0;
            // branch -> after_if_8f67b708_0
        }
        uint32_t v42 = v38 / 0x10000; // 0x8f67b70c
        uint32_t v43 = v38 % 0x10000; // 0x8f67b720
        uint32_t v44 = v37 / v42 * v43; // 0x8f67b72c
        int32_t v45 = 0x10000 * (v37 % v42) | v36 / 0x10000; // 0x8f67b73c
        int32_t v46; // 0x8f67b764
        if (v45 < v44) {
            // if_8f67b744_0_true
            v46 = v45;
            // branch -> 0x8f67b764
        } else {
            int32_t v47 = v45 + v38; // 0x8f67b74c
            if (v47 < v44) {
                // if_8f67b75c_0_true
                v46 = v47 + v38;
                // branch -> 0x8f67b764
            } else {
                v46 = v47;
            }
        }
        uint32_t v48 = v46 - v44; // 0x8f67b764
        int32_t v49 = v36 % 0x10000; // 0x8f67b77c
        g31 = v49;
        uint32_t v50 = v48 / v42 * v43; // 0x8f67b784
        uint32_t v51 = 0x10000 * (v48 % v42) | v49; // 0x8f67b790
        if (v51 < v50) {
            // if_8f67b798_0_true
            // branch -> 0x8f67b7b4
        } else {
            // 0x8f67b7a0
            if (v51 + v38 < v50) {
                // if_8f67b7b0_0_true
                // branch -> 0x8f67b7b4
            }
        }
        // 0x8f67b7b4
        // branch -> 0x8f67bae8
        // 0x8f67bae8
        // branch -> 0x8f67baf8
    } else {
        int32_t v52 = v7; // 0x8f67b7dc
        if (v7 == 0) {
            // 0x8f67b7c4
            v52 = 0;
            // branch -> 0x8f67b7d4
        }
        uint32_t v53 = llvm_ctlz_i32(v52, false); // 0x8f67b7d4
        uint32_t v54; // 0x8f67b970
        uint32_t v55; // 0x8f67b8d0
        uint32_t v56; // 0x8f67b944
        if (v53 == 0) {
            // if_8f67b7dc_0_true
            v56 = v4;
            v55 = v3 - v52;
            v54 = v52;
            // branch -> 0x8f67b8cc
        } else {
            uint32_t v57 = v53 < 32 ? v52 << v53 : 0; // 0x8f67b7e8
            uint32_t v58 = (32 - v53) % 256; // 0x8f67b7f0
            uint32_t v59 = v58 > 32 ? 32 : v58; // 0x8f67b7f0
            uint32_t v60 = v3 >> v59; // 0x8f67b7f0
            uint32_t v61 = v57 / 0x10000; // 0x8f67b7f8
            uint32_t v62 = v4 >> v59 | (v53 < 32 ? v3 << v53 : 0); // 0x8f67b7fc
            int32_t v63 = v53 < 32 ? v4 << v53 : 0; // 0x8f67b808
            g31 = v63;
            uint32_t v64 = v57 % 0x10000; // 0x8f67b818
            uint32_t v65 = v60 / v61 * v64; // 0x8f67b824
            int32_t v66 = 0x10000 * (v60 % v61) | v62 / 0x10000; // 0x8f67b840
            int32_t v67; // 0x8f67b868
            if (v66 < v65) {
                // if_8f67b848_0_true
                v67 = v66;
                // branch -> 0x8f67b868
            } else {
                int32_t v68 = v66 + v57; // 0x8f67b850
                if (v68 < v65) {
                    // if_8f67b860_0_true
                    v67 = v68 + v57;
                    // branch -> 0x8f67b868
                } else {
                    v67 = v68;
                }
            }
            uint32_t v69 = v67 - v65; // 0x8f67b868
            uint32_t v70 = v69 / v61 * v64; // 0x8f67b890
            int32_t v71 = 0x10000 * (v69 % v61) | v62 % 0x10000; // 0x8f67b89c
            int32_t v72; // 0x8f67b8c4
            if (v71 < v70) {
                // if_8f67b8a4_0_true
                v72 = v71;
                // branch -> 0x8f67b8c4
            } else {
                int32_t v73 = v71 + v57; // 0x8f67b8ac
                if (v73 < v70) {
                    // if_8f67b8bc_0_true
                    v72 = v73 + v57;
                    // branch -> 0x8f67b8c4
                } else {
                    v72 = v73;
                }
            }
            // 0x8f67b8c4
            v56 = v63;
            v55 = v72 - v70;
            v54 = v57;
            // branch -> 0x8f67b8cc
        }
        uint32_t v74 = v54 / 0x10000; // 0x8f67b8cc
        uint32_t v75 = v54 % 0x10000; // 0x8f67b8e8
        uint32_t v76 = v55 / v74 * v75; // 0x8f67b8f4
        int32_t v77 = 0x10000 * (v55 % v74) | v56 / 0x10000; // 0x8f67b904
        int32_t v78; // 0x8f67b92c
        if (v77 < v76) {
            // if_8f67b90c_0_true
            v78 = v77;
            // branch -> 0x8f67b92c
        } else {
            int32_t v79 = v77 + v54; // 0x8f67b914
            if (v79 < v76) {
                // if_8f67b924_0_true
                v78 = v79 + v54;
                // branch -> 0x8f67b92c
            } else {
                v78 = v79;
            }
        }
        uint32_t v80 = v78 - v76; // 0x8f67b92c
        int32_t v81 = v56 % 0x10000; // 0x8f67b948
        g31 = v81;
        uint32_t v82 = v80 / v74 * v75; // 0x8f67b950
        uint32_t v83 = 0x10000 * (v80 % v74) | v81; // 0x8f67b960
        if (v83 < v82) {
            // if_8f67b968_0_true
            // branch -> 0x8f67b984
        } else {
            // 0x8f67b970
            if (v83 + v54 < v82) {
                // if_8f67b980_0_true
                // branch -> 0x8f67b984
            }
        }
        // 0x8f67b984
        // branch -> 0x8f67baf8
    }
    // 0x8f67baf8
    if (v6 != 0) {
        // 0x8f67bb08
        // branch -> 0x8f67bb10
    }
    // 0x8f67bb10
    g26 = v1;
    g31 = v2;
}

// --------------- Statically Linked Functions ----------------

// ulldiv_t __aeabi_uldivmod(unsigned long long a, unsigned long long b);
// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:56:15
