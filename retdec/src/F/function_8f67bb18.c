//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t backlight_get_brightness(int32_t * a1, int32_t a2);
int32_t backlight_set_brightness(int32_t a1, int32_t a2);
char * cid_verify_sig(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t dsi_cmd_dma_trigger_for_panel(int32_t a1, int32_t a2, int32_t a3);
int32_t fboot_cmd_multiflash_disable(int32_t a1, int32_t a2);
int32_t fboot_cmd_multiflash_post_validate(int32_t a1, int32_t a2, int32_t a3);
void function_8f64a234(void);
void function_8f64a270(int32_t a1, int32_t a2, int32_t a3);
void function_8f67bb18(void);
int32_t get_db_cid(void);
int32_t get_primary_gpt_partition(int32_t a1, int32_t a2, int32_t a3);
int32_t handle_fboot_oem_command_get_unlock_data(void);
int32_t mcs_DER_decodeBitString(int32_t a1, uint32_t a2, int32_t a3);
int32_t mcs_DER_decodeInteger(int32_t a1, uint16_t a2, int32_t a3);
int32_t mcs_X509Certificate_finalize(int32_t a1, int32_t a2);
int32_t mcs_X509Certificate_initialize(int16_t * a1, int32_t a2);
int32_t mdss_dual_dsi_cmd_dma_trigger_for_panel(int32_t a1, int32_t a2, int32_t a3);
int32_t mmc_enable_hw_reset(void);
int32_t mmc_get_wp_group_size(int32_t a1);
int32_t mot_sst_pal_gen_aes_cmac(char * a1, int32_t a2, int32_t a3);
int32_t ptn_stat(char * a1, int32_t * a2, int32_t * a3, int32_t * a4);
int32_t qtimer_get_phy_timer_cnt(void);
int32_t qtimer_set_physical_timer(int32_t a1, int32_t a2, int32_t a3);
int32_t rtc_alarm_disable(int32_t a1, int32_t a2, int32_t a3);
int32_t rtc_get(void);
int32_t SecICTypeRead(void);
int32_t SecSetSVNum(uint32_t a1, uint32_t a2, int32_t a3);
int32_t ufs_erase(int32_t a1, int32_t a2, int32_t a3);
int32_t ufs_get_serial_num(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g33 = 0; // LR
int32_t g34 = 0; // R0
int32_t g35 = 0; // R1
int32_t g36 = 0; // R2
int32_t g37 = 0; // R3
int32_t g38 = 0; // R4
int32_t g39 = 0; // R5
int32_t g40 = 0; // R6
int32_t g41 = 0; // R7
int32_t g1 = -0x1a60cf90; // 0x8f60c6d8
char * g2 = "\x39\x02\x63\x69\x64\x5f\x67\x65\x74\x5f\x63\x69\x64\x5f\x64\x61\x74\x61\x20\x2d\x20\x53\x54\x41\x52\x54\x0a"; // 0x8f6a54e8
int32_t g3 = -0x79b779d6; // 0x8f6a6a2b
int16_t * g4 = (int16_t *)0xffff; // 0x8f6affa4
int32_t g5 = 0; // 0x8f6b8ac0
int32_t g6 = 0; // 0x8f6b8ac4
int32_t g7 = 0; // 0x8f6b8ac8
int32_t g8 = 0; // 0x8f6b8acc
int32_t g9 = 0; // 0x8f6e0a88
char * g10; // 0x8f70da9b
int32_t g11 = 0; // 0x8f70f725
int32_t g12 = 0; // 0x8f70f745
int32_t g13 = 0; // 0x8f70f746
int32_t g14 = 0; // 0x8f70f747
int32_t g15 = 0; // 0x8f70f748
int32_t g16 = 0; // 0x8f70f749
int32_t g17 = 0; // 0x8f70f74a
int32_t g18 = 0; // 0x8f70f74b
int32_t g19 = 0; // 0x8f70f74c
int32_t g20 = 0; // 0x8f70f74d
int32_t g21 = 0; // 0x8f70f74e
int32_t g22 = 0; // 0x8f70f74f
int32_t g23 = 0; // 0x8f70f750
int32_t g24 = 0; // 0x8f70f751
int32_t g25 = 0; // 0x8f70f752
int32_t g26 = 0; // 0x8f70f753
int32_t g27 = 0; // 0x8f70f754
char g28 = 0; // 0x8f70f755
char g29 = 0; // 0x8f70f756
char * g30; // 0x8f70f75d
int32_t g31 = 0; // 0x8f7112f4
int32_t g32 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f67bb18 - 0x8f67bf1b
void function_8f67bb18(void) {
    uint32_t v1 = g37; // 0x8f67bb18
    if (v1 != 0) {
        // 0x8f67bdb4
        if (v1 > g35) {
            // 0x8f67bf0c
            // branch -> 0x8f67bf10
            // 0x8f67bf10
            return;
        }
        uint32_t v2 = llvm_ctlz_i32(v1, false); // 0x8f67bdbc
        if (v2 == 0) {
            // 0x8f67bdc8
            if (g35 > v1) {
                // after_if_8f67bddc_0.thread13
                // branch -> 0x8f67bf10
                // 0x8f67bf10
                return;
            }
            // if_8f67bdcc_0_true
            if (g34 < g36) {
                // 0x8f67bf0c
                // branch -> 0x8f67bf10
            }
            // 0x8f67bf10
            return;
        }
        uint32_t v3 = (32 - v2) % 256; // 0x8f67bdec
        uint32_t v4 = v3 > 32 ? 32 : v3; // 0x8f67bdec
        uint32_t v5 = g36 >> v4 | (v2 < 32 ? v1 << v2 : 0); // 0x8f67bdf0
        uint32_t v6 = g35 >> v4; // 0x8f67bdf4
        uint32_t v7 = v5 / 0x10000; // 0x8f67bdfc
        uint32_t v8 = g34 >> v4 | (v2 < 32 ? g35 << v2 : 0); // 0x8f67be00
        uint32_t v9 = v2 < 32 ? g36 << v2 : 0; // 0x8f67be0c
        int32_t v10 = v6 / v7;
        uint32_t v11 = v5 % 0x10000; // 0x8f67be1c
        uint32_t v12 = v10 * v11; // 0x8f67be28
        int32_t v13 = 0x10000 * (v6 % v7) | v8 / 0x10000; // 0x8f67be44
        int32_t v14; // 0x8f67be6c
        int32_t v15; // 0x8f67becc
        if (v13 < v12) {
            // if_8f67be4c_0_true
            v15 = v10;
            v14 = v13;
            // branch -> 0x8f67be6c
        } else {
            int32_t v16 = v13 + v5; // 0x8f67be54
            if (v16 < v12) {
                // if_8f67be64_0_true
                v15 = v10 - 2;
                v14 = v16 + v5;
                // branch -> 0x8f67be6c
            } else {
                v15 = v10 - 1;
                v14 = v16;
            }
        }
        uint32_t v17 = v14 - v12; // 0x8f67be6c
        int32_t v18 = v17 / v7;
        uint32_t v19 = v18 * v11; // 0x8f67be94
        int32_t v20 = 0x10000 * (v17 % v7) | v8 % 0x10000; // 0x8f67bea4
        int32_t v21; // 0x8f67bed4
        int32_t v22; // 0x8f67becc
        if (v20 < v19) {
            // if_8f67beac_0_true
            v21 = v20;
            v22 = v18;
            // branch -> 0x8f67becc
        } else {
            int32_t v23 = v20 + v5; // 0x8f67beb4
            if (v23 < v19) {
                // if_8f67bec4_0_true
                v21 = v23 + v5;
                v22 = v18 - 2;
                // branch -> 0x8f67becc
            } else {
                v21 = v23;
                v22 = v18 - 1;
            }
        }
        uint64_t v24 = (int64_t)(v22 | 0x10000 * v15) * (int64_t)v9; // 0x8f67bed0
        uint32_t v25 = (int32_t)(v24 / 0x100000000); // 0x8f67bed0
        uint32_t v26 = v21 - v19; // 0x8f67bed4
        if (v25 > v26) {
            // 0x8f67befc
            // branch -> 0x8f67bf00
            // 0x8f67bf00
            // branch -> 0x8f67bf10
            // 0x8f67bf10
            return;
        }
        // 0x8f67bee0
        if ((int32_t)v24 > (v2 < 32 ? g34 << v2 : 0)) {
            // after_if_8f67bef0_0
            if (v25 == v26) {
                // 0x8f67befc
                // branch -> 0x8f67bf00
                // 0x8f67bf00
                // branch -> 0x8f67bf10
            }
        }
        // 0x8f67bf10
        return;
    }
    // 0x8f67bb38
    if (g36 > g35) {
        uint32_t v27 = llvm_ctlz_i32(g36, false); // 0x8f67bb40
        int32_t v28; // 0x8f67bbf0
        uint32_t v29; // 0x8f67bb80
        uint32_t v30; // 0x8f67bbbc
        uint32_t v31; // 0x8f67bbc8
        if (v27 == 0) {
            // after_if_8f67bb54_0.thread
            v31 = g34;
            v28 = g36;
            v29 = g35;
            v30 = g36 / 0x10000;
            // branch -> after_if_8f67bb5c_0
        } else {
            uint32_t v32 = (32 - v27) % 256; // 0x8f67bb4c
            int32_t v33 = v27 < 32 ? g36 << v27 : 0; // 0x8f67bb50
            v31 = v27 < 32 ? g34 << v27 : 0;
            v28 = v33;
            v29 = g34 >> (v32 > 32 ? 32 : v32) | (v27 < 32 ? g35 << v27 : 0);
            v30 = v33 / 0x10000;
            // branch -> after_if_8f67bb5c_0
        }
        uint32_t v34 = v28 % 0x10000; // 0x8f67bb70
        uint32_t v35 = v29 / v30 * v34; // 0x8f67bb7c
        int32_t v36 = 0x10000 * (v29 % v30) | v31 / 0x10000; // 0x8f67bb8c
        int32_t v37; // 0x8f67bbb4
        if (v36 < v35) {
            // if_8f67bb94_0_true
            v37 = v36;
            // branch -> 0x8f67bbb4
        } else {
            int32_t v38 = v36 + v28; // 0x8f67bb9c
            if (v38 < v35) {
                // if_8f67bbac_0_true
                v37 = v38 + v28;
                // branch -> 0x8f67bbb4
            } else {
                v37 = v38;
            }
        }
        uint32_t v39 = v37 - v35; // 0x8f67bbb4
        uint32_t v40 = v39 / v30 * v34; // 0x8f67bbd4
        uint32_t v41 = 0x10000 * (v39 % v30) | v31 % 0x10000; // 0x8f67bbe0
        if (v41 < v40) {
            // if_8f67bbe8_0_true
            // branch -> 0x8f67bc04
        } else {
            // 0x8f67bbf0
            if (v41 + v28 < v40) {
                // if_8f67bc00_0_true
                // branch -> 0x8f67bc04
            }
        }
        // 0x8f67bc04
        // branch -> 0x8f67bf00
        // 0x8f67bf00
        // branch -> 0x8f67bf10
    } else {
        int32_t v42 = g36; // 0x8f67bc2c
        if (g36 == 0) {
            // 0x8f67bc14
            v42 = 0;
            // branch -> 0x8f67bc24
        }
        uint32_t v43 = llvm_ctlz_i32(v42, false); // 0x8f67bc24
        uint32_t v44; // 0x8f67bd98
        uint32_t v45; // 0x8f67bd28
        uint32_t v46; // 0x8f67bd70
        if (v43 == 0) {
            // if_8f67bc2c_0_true
            v46 = g34;
            v45 = g35 - v42;
            v44 = v42;
            // branch -> 0x8f67bd04
        } else {
            uint32_t v47 = v43 < 32 ? v42 << v43 : 0; // 0x8f67bc38
            uint32_t v48 = (32 - v43) % 256; // 0x8f67bc40
            uint32_t v49 = v48 > 32 ? 32 : v48; // 0x8f67bc40
            uint32_t v50 = g35 >> v49; // 0x8f67bc40
            uint32_t v51 = v47 / 0x10000; // 0x8f67bc4c
            uint32_t v52 = g34 >> v49 | (v43 < 32 ? g35 << v43 : 0); // 0x8f67bc58
            uint32_t v53 = v47 % 0x10000; // 0x8f67bc64
            uint32_t v54 = v50 / v51 * v53; // 0x8f67bc70
            int32_t v55 = 0x10000 * (v50 % v51) | v52 / 0x10000; // 0x8f67bc80
            int32_t v56; // 0x8f67bca8
            if (v55 < v54) {
                // if_8f67bc88_0_true
                v56 = v55;
                // branch -> 0x8f67bca8
            } else {
                int32_t v57 = v55 + v47; // 0x8f67bc90
                if (v57 < v54) {
                    // if_8f67bca0_0_true
                    v56 = v57 + v47;
                    // branch -> 0x8f67bca8
                } else {
                    v56 = v57;
                }
            }
            uint32_t v58 = v56 - v54; // 0x8f67bca8
            uint32_t v59 = v58 / v51 * v53; // 0x8f67bcc8
            int32_t v60 = 0x10000 * (v58 % v51) | v52 % 0x10000; // 0x8f67bcd4
            int32_t v61; // 0x8f67bcfc
            if (v60 < v59) {
                // if_8f67bcdc_0_true
                v61 = v60;
                // branch -> 0x8f67bcfc
            } else {
                int32_t v62 = v60 + v47; // 0x8f67bce4
                if (v62 < v59) {
                    // if_8f67bcf4_0_true
                    v61 = v62 + v47;
                    // branch -> 0x8f67bcfc
                } else {
                    v61 = v62;
                }
            }
            // 0x8f67bcfc
            v46 = v43 < 32 ? g34 << v43 : 0;
            v45 = v61 - v59;
            v44 = v47;
            // branch -> 0x8f67bd04
        }
        uint32_t v63 = v44 / 0x10000; // 0x8f67bd04
        uint32_t v64 = v44 % 0x10000; // 0x8f67bd18
        uint32_t v65 = v45 / v63 * v64; // 0x8f67bd24
        int32_t v66 = 0x10000 * (v45 % v63) | v46 / 0x10000; // 0x8f67bd34
        int32_t v67; // 0x8f67bd5c
        if (v66 < v65) {
            // if_8f67bd3c_0_true
            v67 = v66;
            // branch -> 0x8f67bd5c
        } else {
            int32_t v68 = v66 + v44; // 0x8f67bd44
            if (v68 < v65) {
                // if_8f67bd54_0_true
                v67 = v68 + v44;
                // branch -> 0x8f67bd5c
            } else {
                v67 = v68;
            }
        }
        uint32_t v69 = v67 - v65; // 0x8f67bd5c
        uint32_t v70 = v69 / v63 * v64; // 0x8f67bd7c
        uint32_t v71 = 0x10000 * (v69 % v63) | v46 % 0x10000; // 0x8f67bd88
        if (v71 < v70) {
            // if_8f67bd90_0_true
            // branch -> 0x8f67bdac
        } else {
            // 0x8f67bd98
            if (v71 + v44 < v70) {
                // if_8f67bda8_0_true
                // branch -> 0x8f67bdac
            }
        }
        // 0x8f67bdac
        // branch -> 0x8f67bf10
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 29
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:45:04
