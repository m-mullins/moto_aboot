//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

void arm_data_abort_handler(void);
void arm_undefined_handler(void);
int32_t atoul(char * a1, int32_t a2);
int32_t disconnect_from_key(int32_t a1, int32_t a2);
int32_t fastboot_usb_udc_device_setup(int32_t a1, int32_t a2, int32_t a3);
void function_8f649d24(void);
void function_8f64a270(void);
void function_8f67b3c0(void);
int32_t function_8f67b3c8(uint32_t a1, uint32_t a2, int32_t a3);
int32_t gcd(void);
int32_t generic_mmc_read_sector(int64_t a1, int64_t a2, int32_t a3, int32_t a4);
int32_t generic_mmc_write_sector(int64_t a1, int64_t a2, int32_t a3);
int32_t get_console_string(int32_t a1, int32_t a2);
int32_t get_db_channelid_feature_flag_byte(void);
int32_t get_db_cid_version_byte(int32_t a1, int32_t a2);
int32_t get_udc_device(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t get_unlock_data(int32_t * a1, int32_t a2);
int32_t gic_mask_interrupt(uint32_t a1);
int32_t gic_unmask_interrupt(uint32_t a1);
int32_t is_gpe_product(void);
int32_t is_key_connected(int32_t a1);
char * is_secure_boot_enable(int32_t a1);
int32_t mcs_DER_decode(char * a1, int16_t * a2, char * a3, int16_t * a4);
int32_t mcs_habp_rsa_large(int32_t a1);
int32_t mcs_habp_rsa_med(int32_t a1);
int32_t mcs_habp_rsa_mod(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t mcs_multi_bit_length(int32_t a1, uint32_t a2);
int32_t mcs_Random_secure_generate(int32_t a1, int32_t a2, int32_t a3);
char * scm_xpu_err_fatal_init(int32_t a1);
int32_t set_console_string(char * str, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

int32_t g13 = 0; // LR
int32_t g14 = 0; // R0
int32_t g15 = 0; // R1
int32_t g16 = 0; // R11
int32_t g17 = 0; // R12
int32_t g18 = 0; // R2
int32_t g19 = 0; // R3
int32_t g20 = 0; // R4
int32_t g21 = 0; // R5
int32_t g22 = 0; // R6
bool g1 = false; // flagc
char * g2 = "S"; // 0x8f6a4aed
int32_t g3 = 0x2e8022b8; // 0x8f6ac050
char * g4; // 0x8f6ac05c
char * g5; // 0x8f6b7954
char * g6; // 0x8f6c0335
char * g7; // 0x8f6e0af4
char * g8; // 0x8f6e0b34
char g9 = 0; // 0x8f70da98
char * g10; // 0x8f70da99
int32_t g11 = 0; // 0x8f7112f4
int32_t g12 = 0; // 0x8f7125ec

// ------------------------ Functions -------------------------

// Address range: 0x8f67b3c8 - 0x8f67b487
int32_t function_8f67b3c8(uint32_t a1, uint32_t a2, int32_t a3) {
    // 0x8f67b3c8
    if (!g1) {
        // 0x8f67b45c
        int32_t v1;
        if (a1 != 0) {
            // if_8f67b460_0_true
            v1 = -1;
            // branch -> after_if_8f67b460_0
        } else {
            v1 = 0;
        }
        // after_if_8f67b460_0
        return v1 / a2;
    }
    // 0x8f67b3cc
    if (a1 <= a2) {
        // 0x8f67b440
        return a1 == a2;
    }
    int32_t v2 = llvm_ctlz_i32(a2, false); // 0x8f67b44c
    if (a2 == a3) {
        uint32_t v3 = (31 - v2) % 256; // 0x8f67b454
        return a1 >> (v3 > 32 ? 32 : v3);
    }
    uint32_t v4 = (v2 - llvm_ctlz_i32(a1, false)) % 256; // 0x8f67b3ec
    int32_t v5 = 0; // 0x8f67b400
    uint32_t v6 = v4 == 0 ? 1 : v4 < 32 ? 1 << v4 : 0; // 0x8f67b42c
    int32_t v7 = a1; // 0x8f67b3fc
    uint32_t v8 = v4 == 0 ? a2 : v4 < 32 ? a2 << v4 : 0; // 0x8f67b430
    // branch -> 0x8f67b3f8
    while (true) {
        int32_t v9 = v7; // 0x8f67b408
        int32_t v10 = v5; // 0x8f67b40c
        if (v7 < v8) {
            // if_8f67b3fc_0_true
            v9 = v7 - v8;
            v10 = v6 | v5;
            // branch -> after_if_8f67b400_0
        }
        uint32_t v11 = v8 / 2; // 0x8f67b404
        int32_t v12 = v9; // 0x8f67b414
        int32_t v13 = v10; // 0x8f67b418
        if (v9 < v11) {
            // if_8f67b408_0_true
            v12 = v9 - v11;
            v13 = v10 | v6 / 2;
            // branch -> after_if_8f67b40c_0
        }
        uint32_t v14 = v8 / 4; // 0x8f67b410
        int32_t v15 = v12; // 0x8f67b420
        int32_t v16 = v13; // 0x8f67b424
        if (v12 < v14) {
            // if_8f67b414_0_true
            v15 = v12 - v14;
            v16 = v13 | v6 / 4;
            // branch -> after_if_8f67b418_0
        }
        uint32_t v17 = v8 / 8; // 0x8f67b41c
        int32_t v18 = v15; // 0x8f67b428
        int32_t result = v16; // 0x8f67b438
        if (v15 < v17) {
            // if_8f67b420_0_true
            v18 = v15 - v17;
            result = v16 | v6 / 8;
            // branch -> after_if_8f67b424_0
        }
        // after_if_8f67b424_0
        if (v18 == 0 || v6 < 16) {
            // 0x8f67b438
            return result;
        }
        // after_if_8f67b430_0
        v5 = result;
        v6 /= 16;
        v7 = v18;
        v8 /= 16;
        // branch -> 0x8f67b3f8
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// long int atol(const char * nptr);
// void free(void * ptr);
// int isdigit(int c);
// int isxdigit(int c);
// void * malloc(size_t size);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_ctlz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:46:49
