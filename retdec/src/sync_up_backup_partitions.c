//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __utag_define(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
char * __utag_typeof(void);
int32_t finalize_security_policies(int32_t a1, int32_t a2, int32_t a3);
void function_8f64a088(void);
void function_8f64a0c8(int32_t a1, int32_t a2, int32_t a3);
void function_8f64ab9c(void);
void function_8f64abd0(int32_t a1, int32_t a2, int32_t a3);
void function_8f67b2cc(void);
int32_t get_hw_radio(int32_t a1, int32_t a2, int32_t a3);
int32_t get_hw_rev(int32_t a1, int32_t a2, int32_t a3);
int32_t get_image_version(int32_t a1, int32_t a2, int32_t a3);
int32_t get_signature_size(int32_t a1, int32_t a2);
int32_t hab_csf_check(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_csf_verification(int32_t * a1);
int32_t hab_health_check(int32_t a1, int32_t a2, int32_t a3);
int32_t hab_publickey_verification(int32_t a1, int32_t a2, char * a3);
int32_t hab_su_type(void);
int32_t hab_virtual_to_physical(int32_t a1, int32_t a2, int32_t a3);
int32_t image_match_partition_size(char * a1, int32_t a2, int32_t a3);
int32_t is_always_on(char * a1, int32_t a2, int32_t a3);
int32_t set_console_string(char * str, int32_t a2, int32_t a3, int32_t a4);
int32_t smb1359_config_for_fact_cbl(void);
int32_t smb135x_temp_charging(int32_t a1, int32_t a2, int32_t a3);
int32_t sod_prune(void);
int32_t sod_ramdump_disable(void);
int32_t sync_up_backup_partitions(void);
int32_t transit_to_state(int32_t a1, int32_t a2, int32_t (*a3)(int32_t), int32_t a4);
int32_t update_ker_tags_rdisk_addr(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g30 = 0; // LR
int32_t g31 = 0; // R0
int32_t g32 = 0; // R1
int32_t g33 = 0; // R10
int32_t g34 = 0; // R2
int32_t g35 = 0; // R3
int32_t g36 = 0; // R4
int32_t g37 = 0; // R5
int32_t g38 = 0; // R6
int32_t g39 = 0; // R7
int32_t g40 = 0; // R8
int32_t g41 = 0; // R9
int32_t g1 = -0x1a60cfb0; // 0x8f675474
char * g2 = "\xda\x95\x1b\x6d\xdc\x97\x07\xce\x40\xea\x53\x0f\x90\x20\x91\xb5\x20\xdd\x2f\xf3\x0d\x0e\x0f"; // 0x8f6a6af2
char * g3[2] = {
    "sp",
    "keystore"
}; // 0x8f6a7d98
int32_t g4 = 1; // 0x8f6ac0f0
int32_t g5 = -1; // 0x8f6ac1f4
char (*g6)[5] = "sbl1"; // 0x8f6affb4
int32_t g7 = 0; // 0x8f6b000c
int32_t g8 = 1; // 0x8f6b0044
int32_t g9 = 0; // 0x8f6b7988
int32_t g10 = 0; // 0x8f6b798c
char * g11; // 0x8f6c0335
char * g12; // 0x8f6e0794
int32_t g13 = 0; // 0x8f710ed4
int32_t g14 = 0; // 0x8f710ed8
int32_t g15 = 0; // 0x8f7112f4
char * g16; // 0x8f7125f0
char g17 = 0; // 0x8f7125f4
char g18 = 0; // 0x8f7125f5
char * g19; // 0x8f7125f6
int32_t g20 = 0; // 0x8f7125fc
char * g21; // 0x8f7129d8
int32_t g22 = 0; // 0x8f7129dc
int32_t g23 = 0; // 0x8f7129e8
int32_t g24 = 0; // 0x8f7129f8
int32_t g25 = 0; // 0x8f712a08
int32_t g26 = 0; // 0x8f712a18
int32_t g27 = 0; // 0x8f712a1c
int32_t g28 = 0; // 0x8f712e28
int32_t g29 = 0; // 0x8f712f2c

// ------------------------ Functions -------------------------

// Address range: 0x8f673ef8 - 0x8f67423b
int32_t sync_up_backup_partitions(void) {
    int32_t v1 = g36; // 0x8f673ef8
    int32_t v2 = g37; // 0x8f673ef8
    int32_t v3 = g38; // 0x8f673ef8
    int32_t v4 = g39; // 0x8f673ef8
    int32_t v5 = g40; // 0x8f673ef8
    int32_t v6 = g41; // 0x8f673ef8
    int32_t v7 = g33; // 0x8f673ef8
    int32_t v8 = 0; // 0x8f673ef8
    int32_t v9 = g30; // 0x8f673ef8
    g39 = 0;
    g33 = (int32_t)&g6;
    int32_t v10 = g15;
    g35 = v10;
    int32_t v11 = (int32_t)&g6; // 0x8f673f24
    int32_t v12 = 0; // 0x8f673f24
    // branch -> 0x8f673f14
    while (true) {
        int32_t v13 = v12 + v11; // 0x8f673f14
        g41 = v13;
        int32_t v14 = *(int32_t *)(v13 + 4); // 0x8f673f18
        g37 = v14;
        int32_t v15; // 0x8f67420012
        int32_t v16; // 0x8f67420013
        int32_t v17; // 0x8f67420015
        int32_t v18; // 0x8f6742005
        int32_t v19; // 0x8f6742006
        int32_t v20; // 0x8f6742008
        int32_t result; // 0x8f674210_2
        int32_t v21;
        int32_t v22;
        int32_t v23;
        int32_t v24; // 0x8f6741fc
        if (v14 != 0) {
            int32_t v25 = *(int32_t *)v13; // 0x8f673f24
            g36 = v25;
            g38 = (int32_t)get_partition_by_name(v25, g32, g34, g35, v22, v21, 0, v10, 0, v1, v2);
            g40 = (int32_t)get_partition_by_name(g37, g32, g34, g35, v22, v21, 0, v10, 0, v1, v2);
            int32_t v26 = get_policy_executor(g36, g32, g34, g35, v22); // 0x8f673f44
            g31 = v26;
            int32_t v27 = g38; // 0x8f673f48
            int32_t v28; // 0x8f67420014
            int32_t v29; // 0x8f6742007
            if (v27 == 0) {
                // if_8f673f4c_0_true
                v28 = v22;
                v29 = v21;
                // branch -> 0x8f674104
                // 0x8f674104
                print_log(0, (int32_t)"No partition %s found\n", g36, g35, v28, v29, 0, v10, 0, v1, v2, v3, v4);
                v16 = v28;
                v19 = v29;
                // branch -> 0x8f6741f4
                // 0x8f6741f4
                v24 = *(int32_t *)g41;
                print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
                v15 = v16;
                v18 = v19;
                result = -1;
                // branch -> 0x8f6741e0
                goto lab_0x8f6741e0_5;
            } else {
                int32_t v30 = g40; // 0x8f673f58
                if (v30 == 0) {
                    // 0x8f673f60
                    g32 = (int32_t)"Backup partition %s not exist, ignore\n";
                    int32_t v31 = g37; // 0x8f673f68
                    g34 = v31;
                    print_log(1, (int32_t)"Backup partition %s not exist, ignore\n", v31, g35, v22, v21, 0, v10, 0, v1, v2, v3, v4);
                    v17 = v22;
                    v20 = v21;
                    // branch -> 0x8f6741d0
                    goto lab_0x8f6741d0_3;
                } else {
                    // 0x8f673f74
                    if (v26 == 0) {
                        // if_8f673f78_0_true
                        v28 = v22;
                        v29 = v21;
                        // branch -> 0x8f674104
                        // 0x8f674104
                        print_log(0, (int32_t)"No executor found for %s\n", g36, g35, v28, v29, 0, v10, 0, v1, v2, v3, v4);
                        v16 = v28;
                        v19 = v29;
                        // branch -> 0x8f6741f4
                        // 0x8f6741f4
                        v24 = *(int32_t *)g41;
                        print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
                        v15 = v16;
                        v18 = v19;
                        result = -1;
                        // branch -> 0x8f6741e0
                        goto lab_0x8f6741e0_5;
                    } else {
                        int32_t v32 = *(int32_t *)(v26 + 32); // 0x8f673f80
                        g35 = v32;
                        g32 = v27;
                        g34 = v30;
                        g30 = -0x7098c070;
                        ((int32_t (*)(int32_t, int32_t, int32_t))v32)(v27, v30, v32);
                        if (g31 == 0) {
                            v17 = v22;
                            v20 = v21;
                            goto lab_0x8f6741d0_3;
                        }
                        // 0x8f673f98
                        print_log(1, (int32_t)"try to update backup partition %s for %s\n", g37, g36, v22, v21, 0, v10, 0, v1, v2, v3, v4);
                        int32_t v33 = g38; // 0x8f673fac
                        char v34 = *(char *)(v33 + 41); // 0x8f673fac
                        char v35 = *(char *)(v33 + 40); // 0x8f673fb0
                        char v36 = *(char *)(v33 + 33); // 0x8f673fb4
                        char v37 = *(char *)(v33 + 42); // 0x8f673fbc
                        char v38 = *(char *)(v33 + 32); // 0x8f673fc0
                        char v39 = *(char *)(v33 + 43); // 0x8f673fc8
                        char v40 = *(char *)(v33 + 34); // 0x8f673fd0
                        int32_t v41 = 0x1000000 * (int32_t)v39 | 0x10000 * (int32_t)v37 | (int32_t)v35 | 256 * (int32_t)v34; // 0x8f673fd4
                        char v42 = *(char *)(v33 + 45); // 0x8f673fd8
                        char v43 = *(char *)(v33 + 44); // 0x8f673fdc
                        char v44 = *(char *)(v33 + 35); // 0x8f673fe4
                        uint32_t v45 = v41 + 1; // 0x8f673fe8
                        char v46 = *(char *)(v33 + 46); // 0x8f673ff0
                        char v47 = *(char *)(v33 + 47); // 0x8f673ff8
                        uint32_t v48 = (int32_t)v38 | 256 * (int32_t)v36 | 0x10000 * (int32_t)v40 | 0x1000000 * (int32_t)v44; // 0x8f674000
                        char v49 = *(char *)(v33 + 37); // 0x8f674004
                        char v50 = *(char *)(v33 + 36); // 0x8f67400c
                        char v51 = *(char *)(v33 + 38); // 0x8f674014
                        uint32_t v52 = v45 - v48; // 0x8f674024
                        int32_t v53 = 512 * ((0x1000000 * (int32_t)v47 | 0x10000 * (int32_t)v46 | (int32_t)v43 | 256 * (int32_t)v42) + (int32_t)(v41 == -1) + (int32_t)(v45 < v48) - ((int32_t)v50 | 256 * (int32_t)v49 | 0x10000 * (int32_t)v51)) | v52 / 0x800000; // 0x8f674038
                        int32_t v54 = 512 * v52; // 0x8f67403c
                        g35 = 0;
                        int32_t v55;
                        int32_t v56 = load_partition(v33, -0x70000000, 0, 0, v54, v53, 0, v10, 0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v55, 0, 0); // 0x8f67404c
                        int32_t v57 = v56; // R5
                        if (v56 == 0) {
                            int32_t v58 = g38; // 0x8f674060
                            char v59 = *(char *)(v58 + 41); // 0x8f674060
                            char v60 = *(char *)(v58 + 40); // 0x8f674064
                            char v61 = *(char *)(v58 + 33); // 0x8f674068
                            char v62 = *(char *)(v58 + 42); // 0x8f674070
                            char v63 = *(char *)(v58 + 32); // 0x8f674074
                            char v64 = *(char *)(v58 + 43); // 0x8f67407c
                            char v65 = *(char *)(v58 + 34); // 0x8f674084
                            int32_t v66 = v57; // 0x8f6740e8
                            g35 = v66;
                            if (validate_partition(v58, -0x70000000, 512 * ((0x1000000 * (int32_t)v64 || 0x10000 * (int32_t)v62 || (int32_t)v60 || 256 * (int32_t)v59) + 1 - ((int32_t)v63 || 256 * (int32_t)v61 || 0x10000 * (int32_t)v65)), v66, v54, v53, 0, v10, 0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v55, 0) == 0) {
                                int32_t v67 = g38; // 0x8f674110
                                char v68 = *(char *)(v67 + 41); // 0x8f674110
                                char v69 = *(char *)(v67 + 40); // 0x8f674114
                                char v70 = *(char *)(v67 + 33); // 0x8f674118
                                char v71 = *(char *)(v67 + 42); // 0x8f674120
                                char v72 = *(char *)(v67 + 32); // 0x8f674124
                                char v73 = *(char *)(v67 + 43); // 0x8f67412c
                                char v74 = *(char *)(v67 + 34); // 0x8f674134
                                int32_t v75 = 0x1000000 * (int32_t)v73 | 0x10000 * (int32_t)v71 | (int32_t)v69 | 256 * (int32_t)v68; // 0x8f674138
                                char v76 = *(char *)(v67 + 45); // 0x8f67413c
                                char v77 = *(char *)(v67 + 44); // 0x8f674140
                                char v78 = *(char *)(v67 + 35); // 0x8f674148
                                uint32_t v79 = v75 + 1; // 0x8f67414c
                                char v80 = *(char *)(v67 + 46); // 0x8f674154
                                char v81 = *(char *)(v67 + 47); // 0x8f67415c
                                uint32_t v82 = 0x1000000 * (int32_t)v78 | 0x10000 * (int32_t)v74 | (int32_t)v72 | 256 * (int32_t)v70; // 0x8f674164
                                char v83 = *(char *)(v67 + 37); // 0x8f674168
                                char v84 = *(char *)(v67 + 36); // 0x8f674170
                                char v85 = *(char *)(v67 + 38); // 0x8f674178
                                char v86 = *(char *)(v67 + 39); // 0x8f674180
                                uint32_t v87 = v79 - v82; // 0x8f67418c
                                g32 = -0x70000000;
                                g34 = 0;
                                int32_t v88 = 512 * ((0x1000000 * (int32_t)v81 | 0x10000 * (int32_t)v80 | (int32_t)v77 | 256 * (int32_t)v76) + (int32_t)(v75 == -1) - (0x1000000 * (int32_t)v86 | 0x10000 * (int32_t)v85 | (int32_t)v84 | 256 * (int32_t)v83) + (int32_t)(v79 < v82)) | v87 / 0x800000; // 0x8f6741a0
                                int32_t v89 = 512 * v87; // 0x8f6741a4
                                g35 = 0;
                                if (store_partition(g40, -0x70000000, 0, 0, v89, v88, 0, v10, 0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v55, 0, 0, 0, 0, 0) == 0) {
                                    v17 = v89;
                                    v20 = v88;
                                    goto lab_0x8f6741d0_3;
                                }
                                // 0x8f6741c0
                                print_log(-1, (int32_t)"Failed to update backup GPT\n", g34, g35, v89, v88, 0, v10, 0, v1, v2, v3, v4);
                                v16 = v89;
                                v19 = v88;
                                // branch -> 0x8f6741f4
                                // 0x8f6741f4
                                v24 = *(int32_t *)g41;
                                print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
                                v15 = v16;
                                v18 = v19;
                                result = -1;
                                // branch -> 0x8f6741e0
                                goto lab_0x8f6741e0_5;
                            } else {
                                // 0x8f6740fc
                                v28 = v54;
                                v29 = v53;
                                // branch -> 0x8f674104
                                // 0x8f674104
                                print_log(v57, (int32_t)"Invalid primary partition %s\n", g36, g35, v28, v29, 0, v10, 0, v1, v2, v3, v4);
                                v16 = v28;
                                v19 = v29;
                                // branch -> 0x8f6741f4
                                // 0x8f6741f4
                                v24 = *(int32_t *)g41;
                                print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
                                v15 = v16;
                                v18 = v19;
                                result = -1;
                                // branch -> 0x8f6741e0
                                goto lab_0x8f6741e0_5;
                            }
                          lab_0x8f6741e0_6:
                            // 0x8f6741e0
                            g31 = result;
                            v23 = g15;
                            g35 = v23;
                            if (v10 != v23) {
                                goto lab_0x8f6741f0_4;
                            }
                            // 0x8f67420c
                            g36 = v1;
                            g38 = v3;
                            g39 = v4;
                            g41 = v6;
                            g33 = v7;
                            return result;
                        }
                        // if_8f674054_0_true
                        v28 = v54;
                        v29 = v53;
                        // branch -> 0x8f674104
                        // 0x8f674104
                        print_log(0, (int32_t)"Failed to load partition from %s\n", g36, g35, v28, v29, 0, v10, 0, v1, v2, v3, v4);
                        v16 = v28;
                        v19 = v29;
                        // branch -> 0x8f6741f4
                        // 0x8f6741f4
                        v24 = *(int32_t *)g41;
                        print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
                        v15 = v16;
                        v18 = v19;
                        result = -1;
                        // branch -> 0x8f6741e0
                        goto lab_0x8f6741e0_6;
                    }
                }
            }
          lab_0x8f6741e0_7:
            // 0x8f6741e0
            g31 = result;
            v23 = g15;
            g35 = v23;
            if (v10 != v23) {
                goto lab_0x8f6741f0_4;
            }
            // 0x8f67420c
            g36 = v1;
            g38 = v3;
            g39 = v4;
            g41 = v6;
            g33 = v7;
            return result;
        }
        v17 = v22;
        v20 = v21;
      lab_0x8f6741d0_3:;
        int32_t v90 = g39 + 8; // 0x8f6741d0
        g39 = v90;
        if (v90 == 40) {
            v15 = v17;
            v18 = v20;
            result = 0;
          lab_0x8f6741e0_5:
            // 0x8f6741e0
            g31 = result;
            v23 = g15;
            g35 = v23;
            if (v10 == v23) {
                // 0x8f67420c
                g36 = v1;
                g38 = v3;
                g39 = v4;
                g41 = v6;
                g33 = v7;
                return result;
            }
          lab_0x8f6741f0_4:
            // 0x8f6741f0
            __stack_chk_fail();
            v16 = v15;
            v19 = v18;
            // branch -> 0x8f6741f4
            // 0x8f6741f4
            v24 = *(int32_t *)g41;
            print_log(5, (int32_t)"Failed to sync up backup partition for %s\n", v24, g35, v16, v19, 0, v10, 0, v1, v2, v3, v4);
            v15 = v16;
            v18 = v19;
            result = -1;
            // branch -> 0x8f6741e0
            goto lab_0x8f6741e0_5;
        } else {
          lab_0x8f6741d0_4:
            // 0x8f6741d0
            v11 = g33;
            v12 = v90;
            v22 = v17;
            v21 = v20;
            // branch -> 0x8f673f14
            continue;
        }
    }
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * calloc(size_t nmemb, size_t size);
// void free(void * ptr);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// char * strrchr(char * s, int c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 28
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:46:52
