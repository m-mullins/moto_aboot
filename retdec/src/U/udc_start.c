//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t __aeabi_idivmod(int32_t a1, int32_t a2);
int32_t __utag_describe(int32_t a1, int32_t a2, int32_t a3);
int32_t arg_free(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t atoull(char * a1, int32_t a2);
int32_t decode_hw_type(char * a1, int32_t a2, int32_t a3);
int32_t display_render_done(int32_t a1, int32_t a2);
int32_t fdt_pack(int32_t a1, int32_t a2, int32_t a3);
int32_t font_draw_char_moto(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t font_draw_char_moto_horizontal(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
void function_8f649e14(void);
void function_8f67b584(void);
int32_t get_timestamp(int32_t a1, int32_t a2, int32_t a3);
int32_t initialize_montgomery_alg(int32_t * a1, int32_t a2, int32_t a3);
int32_t is_charging_enabled(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_get_unlock_data_length(int32_t a1, int32_t a2, int32_t a3);
int32_t mot_sst_is_warranty_void(int32_t a1);
int32_t mot_sst_set_state_values_for_nonhlos(void);
int32_t mot_sst_validate_hash_password(int32_t a1, char * a2);
int32_t mp_mont_sqr(int32_t * a1, int32_t result, int32_t a3);
int32_t pm8x41_gpio_config(int32_t a1, int32_t * a2, int32_t a3);
int32_t pm8x41_set_boot_done(int32_t a1);
int32_t pmic_set_chg_set_mode(char a1, int32_t a2, int32_t a3);
int32_t qtimer_irq(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t SecGetSVNum(uint32_t a1, int32_t a2);
int32_t set_logo(char a1, int32_t a2, int32_t a3);
int32_t sod_update(char * a1, int32_t a2, int32_t a3);
int32_t target_set_prod_id(char * a1, int32_t a2, int32_t a3);
int32_t udc_start(int32_t a1, int32_t a2);
int32_t udc_stop(int32_t a1, int32_t a2);
int32_t wait_clogo(int32_t a1, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int32_t g16 = 0; // LR
int32_t g17 = 0; // R0
int32_t g18 = 0; // R1
int32_t g19 = 0; // R10
int32_t g20 = 0; // R2
int32_t g21 = 0; // R3
int32_t g22 = 0; // R4
int32_t g23 = 0; // R5
int32_t g24 = 0; // R6
int32_t g25 = 0; // R7
int32_t g26 = 0; // R8
int32_t g27 = 0; // R9
int32_t g1 = -0x16d2bf10; // 0x8f60569c
int32_t g2 = -1; // 0x8f6ac0e0
int32_t g3 = 1; // 0x8f6ac0f0
char * g4 = "\x01"; // 0x8f6afe10
int32_t g5 = 0; // 0x8f6b792c
char * g6; // 0x8f6b794c
int32_t g7 = 0; // 0x8f6b8abc
int32_t g8 = 0; // 0x8f6b8ac0
int32_t g9 = 0; // 0x8f6b8ac4
int32_t (*g10)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t) = NULL; // 0x8f6b8ac8
int32_t g11 = 0; // 0x8f6b8acc
int32_t g12 = 0; // 0x8f6e08b8
char * g13; // 0x8f6e08f9
char * g14; // 0x8f6e0b60
int32_t g15 = 0; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f605ed4 - 0x8f6061e3
int32_t udc_start(int32_t a1, int32_t a2) {
    int32_t v1 = g23; // 0x8f605ed4
    int32_t v2 = g25; // 0x8f605ed4
    g25 = &g15;
    g23 = (int32_t)&g6;
    int32_t v3 = g15;
    int32_t v4;
    print_log(-1, (int32_t)"udc_start()\n", g20, v3, a1, v3, g22, v1, g24, v2, g26, g16, v4);
    char * v5 = g6;
    if (v5 == NULL) {
        // if_8f605efc_0_true
        // branch -> 0x8f605f20
        // 0x8f605f20
        print_log(-1, (int32_t)"udc cannot start before init\n", g20, (int32_t)v5, a1, v3, g22, v1, g24, v2, g26, g16, v4);
        // branch -> 0x8f6061a8
        // 0x8f6061a8
        if (v3 != g15) {
            // 0x8f6061b8
            __stack_chk_fail();
            // branch -> 0x8f6061bc
        }
        // 0x8f6061bc
        g23 = v1;
        g25 = v2;
        return -1;
    }
    // 0x8f605f08
    int32_t result; // R0
    if (g5 == 0) {
        // 0x8f605f18
        // branch -> 0x8f605f20
        // 0x8f605f20
        print_log(-1, (int32_t)"udc has no gadget registered\n", g20, 0, a1, v3, g22, v1, g24, v2, g26, g16, v4);
        result = -1;
        // branch -> 0x8f6061a8
    } else {
        int32_t v6 = 2; // R6
        int32_t v7 = udc_descriptor_alloc(1, 0, 18, g5, a1, v3, g22, v1, g24, v2, g26, g16, v4); // 0x8f605f3c
        int32_t v8 = 0; // R3
        int32_t v9 = v7; // R4
        *(char *)(v7 + 10) = 0;
        *(char *)(v7 + 12) = (char)v8;
        *(char *)(v7 + 13) = (char)v8;
        *(char *)(v7 + 14) = (char)v8;
        *(char *)(v7 + 11) = (char)v6;
        *(char *)(v7 + 15) = 64;
        memcpy((char *)(v7 + 16), g6, v6);
        memcpy((char *)(v9 + 18), (char *)(v6 + (int32_t)g6), v6);
        int32_t v10 = (int32_t)g6 + 4; // 0x8f605f94
        memcpy((char *)(v9 + 20), (char *)v10, v6);
        int32_t v11 = (int32_t)g6;
        int32_t v12 = *(int32_t *)(v11 + 8); // 0x8f605fa0
        int32_t v13 = udc_string_desc_alloc(v12, v10, v6, v11, a1, v3, g22, v1, g24, v2, g26, g16); // 0x8f605fa4
        int32_t v14 = (int32_t)g6;
        *(char *)(v9 + 22) = (char)v13;
        int32_t v15 = *(int32_t *)(v14 + 12); // 0x8f605fb0
        int32_t v16 = udc_string_desc_alloc(v15, v10, v6, v14, a1, v3, g22, v1, g24, v2, g26, g16); // 0x8f605fb4
        int32_t v17 = (int32_t)g6;
        *(char *)(v9 + 23) = (char)v16;
        int32_t v18 = *(int32_t *)(v17 + 16); // 0x8f605fc0
        int32_t v19 = udc_string_desc_alloc(v18, v10, v6, v17, a1, v3, g22, v1, g24, v2, g26, g16); // 0x8f605fc4
        *(char *)(v9 + 25) = 1;
        *(char *)(v9 + 24) = (char)v19;
        udc_descriptor_register(v9, v10, v6, 1);
        int32_t v20 = *(int32_t *)(g5 + 20); // 0x8f605fe8
        int32_t v21 = (int32_t)*(char *)(g5 + 11); // 0x8f605fec
        int32_t v22; // 0x8f606004
        if (v20 == 0) {
            // after_if_8f606000_0.critedge
            g23 = 9;
            v22 = 18;
            // branch -> after_if_8f606000_0
        } else {
            int32_t v23 = (int32_t)*(char *)v20; // 0x8f605ff4
            g23 = v23 + 9;
            v22 = v23 + 18;
            // branch -> after_if_8f606000_0
        }
        int32_t v24 = v22 + 7 * v21; // 0x8f606008
        g23 = v24;
        int32_t v25 = udc_descriptor_alloc(2, 0, v24, v21, a1, v3, g22, v1, g24, v2, g26, g16, v4); // 0x8f606010
        int32_t v26 = 9; // R2
        v8 = 1;
        *(char *)(v25 + 10) = (char)g23;
        *(char *)(v25 + 11) = (char)(g23 / 256);
        v9 = v25;
        g23 = g5;
        *(char *)(v25 + 8) = (char)v26;
        *(char *)(v25 + 12) = (char)v8;
        *(char *)(v25 + 13) = (char)v8;
        v8 = 0;
        *(char *)(v25 + 15) = -128;
        *(char *)(v25 + 17) = (char)v26;
        *(char *)(v25 + 14) = (char)v8;
        *(char *)(v25 + 18) = 4;
        *(char *)(v25 + 16) = -6;
        *(char *)(v25 + 19) = (char)v8;
        *(char *)(v25 + 20) = (char)v8;
        *(char *)(v25 + 21) = *(char *)(g23 + 11);
        *(char *)(v25 + 22) = *(char *)(g23 + 8);
        *(char *)(v25 + 23) = *(char *)(g23 + 9);
        char v27 = *(char *)(g23 + 10); // 0x8f606080
        *(char *)(v25 + 24) = v27;
        int32_t v28 = *(int32_t *)(g23 + 12); // 0x8f606088
        int32_t v29 = udc_string_desc_alloc(v28, -6, 4, (int32_t)v27, a1, v3, g22, v1, g24, v2, g26, g16); // 0x8f60608c
        int32_t v30 = v9; // 0x8f606090
        v8 = v30 + 26;
        *(char *)(v30 + 25) = (char)v29;
        int32_t v31 = g23; // 0x8f606098
        int32_t * v32 = (int32_t *)(v31 + 20); // 0x8f606098_0
        int32_t v33 = v8;
        int32_t v34 = v31; // 0x8f6060d415
        int32_t v35;
        int32_t * v36; // 0x8f606194_0
        int32_t v37; // R1
        int32_t v38; // 0x8f606188
        int32_t v39; // 0x8f606178
        int32_t v40;
        int32_t v41; // 0x8f6060f0
        int32_t v42; // 0x8f606134
        int32_t v43; // 0x8f606160
        char v44; // 0x8f6060d418
        char v45; // 0x8f6060f4
        char v46; // 0x8f60610c
        int16_t v47; // 0x8f606120
        uint16_t v48; // 0x8f606128
        int32_t v49; // 0x8f60617c
        if (*v32 != 0) {
            int32_t v50 = *v32; // 0x8f6060a873
            if (*(char *)v50 != 0) {
                *(char *)v33 = *(char *)v50;
                int32_t v51 = g23;
                int32_t v52 = v33 + 1;
                int32_t v53 = *(int32_t *)(v51 + 20); // 0x8f6060a8
                v33 = v52;
                while (v52 - v8 < (int32_t)*(char *)v53) {
                    int32_t v54 = v52 - v8; // 0x8f6060ac80
                    v33 = v52;
                    *(char *)v33 = *(char *)(v53 + v54);
                    v51 = g23;
                    v52 = v33 + 1;
                    v53 = *(int32_t *)(v51 + 20);
                    v33 = v52;
                    // continue -> if_8f6060b8_0_true
                }
                // 0x8f6060c4
                v8 = v33;
                v34 = v51;
                // branch -> 0x8f6060c8
                // 0x8f6060c8
                v37 = 0;
                v44 = *(char *)(v34 + 11);
                int32_t v55 = v33; // 0x8f606168
                int32_t v56 = 0; // 0x8f606168
                int32_t v57 = v44;
                if (v44 == 0) {
                    char v58 = 7;
                    int32_t v59 = v33; // 0x8f6060e8
                    int32_t v60 = 0; // 0x8f6060e4
                    int32_t v61 = v34; // 0x8f6060e0
                    while (true) {
                        // 0x8f6060e0
                        v26 = *(int32_t *)(*(int32_t *)(v61 + 24) + 4 * v60);
                        *(char *)v59 = v58;
                        *(char *)(v8 + 1) = (char)5;
                        v41 = v26;
                        v45 = *(char *)(v41 + 16);
                        v35 = *(char *)(v41 + 17) == 0 ? 0 : 128;
                        *(char *)(v8 + 2) = (char)(v35 | (int32_t)v45);
                        v46 = *(char *)(v26 + 18);
                        *(char *)(v8 + 3) = (char)(v46 == 0 ? 2 : 3);
                        v47 = *(int16_t *)(v26 + 20);
                        *(char *)(v8 + 4) = (char)v47;
                        v48 = *(int16_t *)(v26 + 20);
                        *(char *)(v8 + 5) = (char)(v48 / 256);
                        v42 = v26;
                        v40 = 1;
                        if (*(char *)(v42 + 18) == 0) {
                          lab_0x8f606144:;
                            unsigned char v62 = *(char *)(v42 + 17); // 0x8f606144
                            v40 = v62 > 1 ? 0 : 1 - (int32_t)v62;
                            // branch -> 0x8f606150
                        }
                      lab_0x8f606150:
                        // 0x8f606150
                        *(char *)(v8 + 6) = (char)v40;
                        int32_t v63 = v37 + 1; // 0x8f606154
                        v37 = v63;
                        int32_t v64 = v8 + 7; // 0x8f606158
                        v8 = v64;
                        int32_t v65 = g23; // 0x8f6060d4
                        int32_t v66 = (int32_t)*(char *)(v65 + 11); // 0x8f6060d4
                        if (v63 >= v66) {
                            // 0x8f606150
                            v58 = 7;
                            v59 = v64;
                            v60 = v63;
                            v61 = v65;
                            // branch -> 0x8f6060e0
                            continue;
                        } else {
                            v55 = v64;
                            v56 = v63;
                            v57 = v66;
                        }
                    }
                }
                // 0x8f606160
                v43 = v9;
                v9 = 0x78d9000;
                udc_descriptor_register(v43, v56, v57, v55);
                v39 = register_int_handler(166, (int32_t)&g1, 0, v8);
                v49 = v39 & -0x10000 | 325;
                *(int32_t *)(v9 + 328) = v49;
                v38 = unmask_interrupt(166, (int32_t)&g1, 0, v49);
                mdelay(600, (int32_t)&g1, v38, v49);
                v36 = (int32_t *)(v9 + 320);
                *v36 = *v36 | 0x80001;
                // branch -> 0x8f6061a8
                // 0x8f6061a8
                if (v3 != g15) {
                    // 0x8f6061b8
                    __stack_chk_fail();
                    // branch -> 0x8f6061bc
                }
                // 0x8f6061bc
                g23 = v1;
                g25 = v2;
                return 0;
            }
            // 0x8f6060c4
            v8 = v33;
            v34 = v31;
            // branch -> 0x8f6060c8
        }
        // 0x8f6060c8
        v37 = 0;
        v44 = *(char *)(v34 + 11);
        if (v44 == 0) {
            while (true) {
                // 0x8f6060e0
                v26 = *(int32_t *)*(int32_t *)(v34 + 24);
                *(char *)v33 = 7;
                *(char *)(v8 + 1) = (char)5;
                v41 = v26;
                v45 = *(char *)(v41 + 16);
                v35 = *(char *)(v41 + 17) == 0 ? 0 : 128;
                *(char *)(v8 + 2) = (char)(v35 | (int32_t)v45);
                v46 = *(char *)(v26 + 18);
                *(char *)(v8 + 3) = (char)(v46 == 0 ? 2 : 3);
                v47 = *(int16_t *)(v26 + 20);
                *(char *)(v8 + 4) = (char)v47;
                v48 = *(int16_t *)(v26 + 20);
                *(char *)(v8 + 5) = (char)(v48 / 256);
                v42 = v26;
                if (*(char *)(v42 + 18) == 0) {
                    goto lab_0x8f606144;
                }
                v40 = 1;
                goto lab_0x8f606150;
            }
        }
        // 0x8f606160
        v43 = v9;
        v9 = 0x78d9000;
        udc_descriptor_register(v43, 0, (int32_t)v44, v33);
        v39 = register_int_handler(166, (int32_t)&g1, 0, v8);
        v49 = v39 & -0x10000 | 325;
        *(int32_t *)(v9 + 328) = v49;
        v38 = unmask_interrupt(166, (int32_t)&g1, 0, v49);
        mdelay(600, (int32_t)&g1, v38, v49);
        v36 = (int32_t *)(v9 + 320);
        result = 0;
        *v36 = *v36 | 0x80001;
        // branch -> 0x8f6061a8
    }
    // 0x8f6061a8
    if (v3 != g15) {
        // 0x8f6061b8
        __stack_chk_fail();
        // branch -> 0x8f6061bc
    }
    // 0x8f6061bc
    g23 = v1;
    g25 = v2;
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void free(void * ptr);
// int isdigit(int c);
// int isxdigit(int c);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 30
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 19:31:19
