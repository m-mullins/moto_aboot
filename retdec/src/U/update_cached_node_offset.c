//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int32_t dt_entry_list_init(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t fdt32_to_cpu(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8f60e20c(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mdp_set_revision(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_commands_send_part_1(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_dsi_panel_identify(int32_t a1);
int32_t mdss_dsi_panel_power_on_reset(int32_t a1, int32_t a2);
int32_t mdss_dual_dsi_cmd_dma_trigger_for_panel(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_mdp_set_flush_isra_1(int32_t a1, int32_t * a2);
int32_t mdss_smp_setup(int32_t a1, int32_t a2, int32_t a3);
int32_t mdss_vbif_setup(int32_t a1, int32_t a2);
int32_t mipi_dsi_calibration(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_cmds_rx(int32_t * a1, int32_t result);
int32_t mipi_dsi_panel_initialize(int32_t a1, int32_t a2, int32_t a3);
int32_t mipi_dsi_phy_init(int32_t a1, int32_t a2);
int32_t qup_i2c_interrupt(int32_t a1, int32_t a2, int32_t a3);
int32_t qup_i2c_poll_state_isra_4(int32_t * a1, int32_t a2);
int32_t qup_i2c_xfer(int32_t a1);
int32_t qup_set_read_mode(int32_t a1, int32_t a2);
int32_t qup_update_state(int32_t a1, int32_t a2, int32_t a3);
int32_t read_rdata_into_array(int32_t a1, int32_t a2, int32_t a3, char * a4);
int32_t spmi_init(int32_t result2, int32_t a2, int32_t a3);
int32_t update_cached_node_offset(char * a1, int32_t a2, int32_t a3);
int32_t write_wdata_from_array(int32_t a1, int32_t a2, int32_t a3, char * a4);

// --------------------- Global Variables ---------------------

int32_t g19 = 0; // LR
int32_t g20 = 0; // R0
int32_t g21 = 0; // R1
int32_t g22 = 0; // R12
int32_t g23 = 0; // R2
int32_t g24 = 0; // R3
int32_t g25 = 0; // R4
int32_t g26 = 0; // R5
int32_t g27 = 0; // R6
int32_t g28 = 0; // R7
int32_t g29 = 0; // R8
int32_t g30 = 0; // R9
bool g1 = false; // flagz
int32_t g2 = 0x6d0f0703; // 0x8f67f1bd
int32_t g3 = 0; // 0x8f67f620
int32_t g4 = 8; // 0x8f67f624
int32_t g5 = 255; // 0x8f67f630
char * g6; // 0x8f67f640
int32_t g7 = 0x65440030; // 0x8f69c66f
int32_t g8; // 0x8f6ac0ac
int32_t g9 = -1; // 0x8f6ac0bc
int32_t g10 = -1; // 0x8f6ac0c0
int32_t g11 = 0; // 0x8f6b8af8
int32_t g12 = 0; // 0x8f6b8afc
int32_t g13 = 0; // 0x8f6b8b00
int32_t g14 = 0; // 0x8f6b8b04
int32_t g15 = 0; // 0x8f6b8b08
int32_t g16 = 0; // 0x8f6b8b0c
int32_t g17 = 0; // 0x8f6b8b10
int16_t * g18 = NULL; // 0x8f7112f4

// ------------------------ Functions -------------------------

// Address range: 0x8f612f5c - 0x8f613087
int32_t update_cached_node_offset(char * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = &g9; // R7
    int16_t * v3 = g18;
    int32_t v4 = (int32_t)v3;
    int32_t v5 = g9;
    if (v5 == a2) {
        // 0x8f613050
        if (v3 != g18) {
            // 0x8f613060
            __stack_chk_fail();
            // branch -> 0x8f613064
        }
        // 0x8f613064
        return 0;
    }
    int32_t v6 = &g10; // R5
    int32_t v7 = 4 * a2; // 0x8f612f88
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g10); // 0x8f612f88
    int32_t v9; // 0x8f613004
    int32_t v10; // R2
    int32_t v11; // R3
    int32_t v12; // R6
    int32_t result;
    int32_t v13;
    int32_t v14; // 0x8f612fec
    int32_t v15; // 0x8f612fe0
    int32_t v16; // 0x8f612fe8
    int32_t v17; // 0x8f61303c
    int32_t v18; // 0x8f612fa4
    int32_t v19; // 0x8f612fbc
    int32_t v20; // 0x8f613000
    int32_t v21; // 0x8f613018
    int32_t v22; // 0x8f61303c
    if (v8 == -1) {
        // if_8f612f90_0_true
        // branch -> 0x8f612fa4
        // 0x8f612fa4
        v18 = *(int32_t *)(4 * v5 + (int32_t)&g10);
        if (v18 < v8) {
            // 0x8f612fb0
            v19 = *(int32_t *)(v7 - 0x70953f54);
            print_log(-1, (int32_t)"restart search offset %s, this might cause performance issue", v19, (int32_t)&g8, v1, v4, a3, g25, g26, g27, g28, g29, g30);
            v13 = g9;
            v10 = v13;
            v11 = 0;
            v16 = 0;
            v15 = v13;
            // branch -> 0x8f612fd4
            while (true) {
                // 0x8f612fd4
                if (v16 == v15) {
                    v14 = v16;
                    goto lab_0x8f612fec;
                }
                goto lab_0x8f612fdc;
            }
        }
        // 0x8f612ff8
        v12 = &g8;
        v20 = *(int32_t *)(4 * a2 + (int32_t)&g8);
        v9 = fdt_path_offset((char *)v1, v20, 1, v18, v1, v4, a3, g25, g26, g27, g28, g29, g30);
        if (v9 > -1) {
            // 0x8f613034
            v17 = 4 * a2;
            v22 = *(int32_t *)(v17 + v12);
            *(int32_t *)(v6 + v17) = v9;
            print_log(2, (int32_t)"%s @ 0x%x\n", v22, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
            // branch -> 0x8f613048
            // 0x8f613048
            *(int32_t *)v2 = a2;
            result = 0;
            // branch -> 0x8f613050
        } else {
            // 0x8f613010
            v21 = *(int32_t *)(4 * a2 + v12);
            print_log(-1, (int32_t)"Could not find %s node.\n", v21, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
            result = -1;
            // branch -> 0x8f613050
        }
        // 0x8f613050
        if (v3 != g18) {
            // 0x8f613060
            __stack_chk_fail();
            // branch -> 0x8f613064
        }
        // 0x8f613064
        return result;
    }
    // 0x8f612f98
    int32_t v23; // 0x8f613028
    if (v5 == -1) {
        // if_8f612fa0_0_true
        v23 = 1;
        // branch -> 0x8f612fa4
    } else {
        // if_8f612f9c_0_true
        v23 = 0;
        // branch -> 0x8f612fa4
    }
    // 0x8f612fa4
    v18 = *(int32_t *)(4 * v5 + (int32_t)&g10);
    if (v18 < v8) {
        // 0x8f612fb0
        v19 = *(int32_t *)(v7 - 0x70953f54);
        print_log(-1, (int32_t)"restart search offset %s, this might cause performance issue", v19, (int32_t)&g8, v1, v4, a3, g25, g26, g27, g28, g29, g30);
        v13 = g9;
        v10 = v13;
        v11 = 0;
        v16 = 0;
        v15 = v13;
        // branch -> 0x8f612fd4
        while (true) {
            // 0x8f612fd4
            v14 = v16;
            if (v16 != v15) {
              lab_0x8f612fdc:;
                int32_t v24 = 4 * v16; // 0x8f612fdc
                int32_t v25 = *(int32_t *)(v6 + 4 * v15); // 0x8f612fe0
                if (*(int32_t *)(v6 + v24) > v25) {
                    // if_8f612fe8_0_true
                    *(int32_t *)((int32_t)&g10 + v24) = -1;
                    v14 = v11;
                    // branch -> 0x8f612fec
                } else {
                    v14 = v16;
                }
            }
          lab_0x8f612fec:;
            int32_t v26 = v14 + 1; // 0x8f612fec
            v11 = v26;
            if (v26 == 4) {
                // 0x8f612ff8
                // branch -> 0x8f612ff8
                // 0x8f612ff8
                v12 = &g8;
                v20 = *(int32_t *)(4 * a2 + (int32_t)&g8);
                v9 = fdt_path_offset((char *)v1, v20, v10, 4, v1, v4, a3, g25, g26, g27, g28, g29, g30);
                if (v9 > -1) {
                    // 0x8f613034
                    v17 = 4 * a2;
                    v22 = *(int32_t *)(v17 + v12);
                    *(int32_t *)(v6 + v17) = v9;
                    print_log(2, (int32_t)"%s @ 0x%x\n", v22, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
                    // branch -> 0x8f613048
                    // 0x8f613048
                    *(int32_t *)v2 = a2;
                    result = 0;
                    // branch -> 0x8f613050
                } else {
                    // 0x8f613010
                    v21 = *(int32_t *)(4 * a2 + v12);
                    print_log(-1, (int32_t)"Could not find %s node.\n", v21, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
                    result = -1;
                    // branch -> 0x8f613050
                }
                // 0x8f613050
                if (v3 != g18) {
                    // 0x8f613060
                    __stack_chk_fail();
                    // branch -> 0x8f613064
                }
                // 0x8f613064
                return result;
            }
            // 0x8f612fec
            v16 = v26;
            v15 = v10;
            // branch -> 0x8f612fd4
        }
    } else {
        // 0x8f613028
        if (v23 == 0) {
            // 0x8f613048
            *(int32_t *)(int32_t)&g9 = a2;
            // branch -> 0x8f613050
            // 0x8f613050
            if (v3 != g18) {
                // 0x8f613060
                __stack_chk_fail();
                // branch -> 0x8f613064
            }
            // 0x8f613064
            return 0;
        }
    }
    // 0x8f612ff8
    v12 = &g8;
    v20 = *(int32_t *)(4 * a2 + (int32_t)&g8);
    v9 = fdt_path_offset((char *)v1, v20, 1, v18, v1, v4, a3, g25, g26, g27, g28, g29, g30);
    if (v9 > -1) {
        // 0x8f613034
        v17 = 4 * a2;
        v22 = *(int32_t *)(v17 + v12);
        *(int32_t *)(v6 + v17) = v9;
        print_log(2, (int32_t)"%s @ 0x%x\n", v22, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
        // branch -> 0x8f613048
        // 0x8f613048
        *(int32_t *)v2 = a2;
        result = 0;
        // branch -> 0x8f613050
    } else {
        // 0x8f613010
        v21 = *(int32_t *)(4 * a2 + v12);
        print_log(-1, (int32_t)"Could not find %s node.\n", v21, v9, v1, v4, a3, g25, g26, g27, g28, g29, g30);
        result = -1;
        // branch -> 0x8f613050
    }
    // 0x8f613050
    if (v3 != g18) {
        // 0x8f613060
        __stack_chk_fail();
        // branch -> 0x8f613064
    }
    // 0x8f613064
    return result;
}

// --------------- Statically Linked Functions ----------------

// void __stack_chk_fail(void);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: android-ndk-r8 (4.4.3 armv5te, armv7a(arm-linux-androideabi-gcc))
// Detected functions: 24
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-08-06 18:34:23
